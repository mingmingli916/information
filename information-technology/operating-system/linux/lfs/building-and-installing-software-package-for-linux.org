:PROPERTIES:
:ID:       BB16B28A-EDD0-42EB-8132-7C224666E1A4
:END:
#+title: building and installing software package

* Introduction
Many software packages for the various flavors of UNIX and Linux come as compressed archives of source files. The same package may be "built" to run on different target machines, and this saves the author of the software from having to produce multiple versions. A single distribution of a software package may thus end up running, in various incarnations, on an Intel box, a DEC Alpha, a RISC workstation, or even a mainframe.


* Unpackaging the Files

You have downloaded or otherwise acquired a software package. Most likely it is archived (*tarred*) and compressed (*gzipped*), in =.tar.gz= or =.tgz= form (familiarly known as a "<<<tarball>>>"). First copy it to a working directory. Then *untar* and *gunzip* it. The appropriate command for this is =tar xzvf filename=, where =filename= is the name of the software file.


#+begin_src shell
  tar xzvf filename
  # -x, --extract: extract files from archive.
  # -z, --gzip, --gunzip, --ungzip: filter the archive through gzip.
  # -v, --verbose: verbosely list files processed.
  # -f, --file=ARCHIVE: Use arhive file or device ARCHIVE.
#+end_src


If the package name has a =.Z= suffix, then the above procedure will serve just as well, though running *uncompress*, followed by a =tar xvf= also works. 


You may preview this process by a =tar tzvf filename=, which lists the files in the archive without actually unpacking them.



The above method of unpacking "tarballs" is equivalent to either of the following:
#+begin_src shell
  gzip -cd filename | tar xvf -
  gunzip -c filename | tar xvf -
  # The '-' causes the tar command to take its input from stdin.

  # gzip
  # -c, --stdout, --to-stdout: Write output on standard output; keep original files unchaged.
  # -d: decompress

  # gunzip
  # -c, --stdout, --to-stdout: Write output on standard output; keep original files unchaged.  
#+end_src




Source files in the new =bzip2= (=.bz2=) format can be unarchived by a =bzip2 -cd filename | tar xvf -=, or, more simply by a =tar xyvf filename=, assuming that tar has been appropriately patched.
#+begin_src shell
  bzip2 -cd filename | tar xvf -
  # or
  tar xyvf filename
#+end_src


Sometimes the archived file must be untarred and installed from the user's home directory, or perhaps in a certain other directory, such as =/, /usr/src=, or =/opt=, as specified in the package's config info. Should you get an error message attempting to untar it, this may be the reason. Read the package docs, especially the =README= and/or =Install= files, if present, and edit the config files and/or =Makefiles= as necessary, consistent with the installation instructions. Note that you would not ordinarily alter the =Imake= file, since this could have unforseen consequences. Most software packages permit automating this process by running =make install= to emplace the binaries in the appropriate system areas.



Occasionally, you may need to update or incorporate bug fixes into the unarchived source files using a =patch= or =diff= file that lists the changes. The doc files and/or README file will inform you should this be the case. The normal syntax for invoking Larry Wall's powerful =patch= utility is =patch < patchfile=.


* Using <<<Make>>>
The =Makefile= is the key to the build process. In its simplest form, a Makefile is a script for compiling or building the "binaries", thex executable portions of a package.


At some point, the Makefile lauches =cc= or =gcc=. This is actually a processor, a C (or C++) compiler, and a linker, invoked in that order. This process converts the source into the binaries, the actual executables.


Invoking *make* usually involves just typing =make=. This generally builds all the necessary executable files for the package in question. However, make can also do other tasks, such as installing the files in their proper directories (=make install=) and removing stale object files (=make clean=). Running =make -n= permits previewing the build process, as it prints out all the commands that would be triggered by a make, without actually executing them.



Only the simplest software uses a generic Makefile. More complex installations require tailoring the Makefile according to the location of libraries, include files, and resources on your particular machine. This is especially the case when the build needs the X11 libraries to install. <<<Imake>>> and <<<xmkmf>>> accomplish this task.


An =Imakefile= is, to quote the man page, a "template" Makefile. The imake utility constructs a Makefile appropriate for your system from the Imakefile. In almost all cases, however, you would run =xmkmf=, a shell script that invokes imake, a front end for it. Check the =README= or =INSTALL= file included in the software archive for specific instructions. (If, after dearchiving the source files, there is an Imake file present in the base directory, this is a dead giveaway that xmkmf should be run.) Read the Imake and xmkmf man pages for a more detailed analysis of the procedure.



Be aware that =xmkmf= and =make= may need to be invoked as root, especially when doing a make install to move the binaries over to the =/usr/bin= or =/usr/local/bin= directories. Using make as an ordinary user without root privileges will likely result in write access denied error messages because you lack write permission to system directories. Check also that the binaries created have the proper execute permissions for you and any other appropriate users.



Invoking =xmkmf= uses the Imake file to build a new Makefile appropriate for your system. You would normally invoke =xmkmf= with the =-a= argument, to automatically do a make Makefiles, make includes, and make depend. This sets the variables and defines the library locations for the compiler and linker. Sometimes, there will be no =Imake= file, instead there will be an =INSTALL= or =configure= script that will accomplish this purpose. Note that if you run =configure=, it should be invoked as =./configure= to ensure that the correct =configure= script in the current directory is called. In most cases, the =README= file included with the distribution will explain the install procedure.




It is usually a good idea to visually inspect the =Makefile= that =xmkmf= or one of the install scripts builds. The Makefile will normally be correct for your system, but you may occasionally be required to "tweak" it or correct errors manually.



Installing the freshly built binaries into the appropriate system directories is usually a matter of running =make install= as root. The usual directories for system-wide binaries on modern Linux distributions are =/usr/bin, /usr/X11R6/bin=, and =/usr/local/bin=. The preferred directory for new packages is =/usr/local/bin=, as this will keep separate binaries not part of the original Linux installation.


Packages originally targeted for commercial versions of UNIX may attempt to install in the =/opt= or other unfamiliar directory. This will, of course, result in an installation error if the intended installation directory does not exist. The simplest way to deal with this is to create, as root, an =/opt= directory, let the package install there, then add that directory to the =PATH= environmental variable. Alternatively, you may create symbolic links to the /usr/local/bin directory.


Your general installation procedure will therefore be:

1. Read the =README= file and other applicable docs.
2. Run =xmkmf -a=, or the =INSTALL= or =configure= script.
3. Check the =Makefile=.
4. If necessary, run =make clean=, =make Makefiles=, =make includes=, and =make depend=.
5. Run =make=.
6. Check file permissions.
7. If necessary, run =make install=.
