:PROPERTIES:
:ID:       BB16B28A-EDD0-42EB-8132-7C224666E1A4
:END:
#+title: building and installing software package

* Introduction
Many software packages for the various flavors of UNIX and Linux come as compressed archives of source files. The same package may be "built" to run on different target machines, and this saves the author of the software from having to produce multiple versions. A single distribution of a software package may thus end up running, in various incarnations, on an Intel box, a DEC Alpha, a RISC workstation, or even a mainframe.


* Unpackaging the Files

You have downloaded or otherwise acquired a software package. Most likely it is archived (*tarred*) and compressed (*gzipped*), in =.tar.gz= or =.tgz= form (familiarly known as a "<<<tarball>>>"). First copy it to a working directory. Then *untar* and *gunzip* it. The appropriate command for this is =tar xzvf filename=, where =filename= is the name of the software file.


#+begin_src shell
  tar xzvf filename
  # -x, --extract: extract files from archive.
  # -z, --gzip, --gunzip, --ungzip: filter the archive through gzip.
  # -v, --verbose: verbosely list files processed.
  # -f, --file=ARCHIVE: Use arhive file or device ARCHIVE.
#+end_src


If the package name has a =.Z= suffix, then the above procedure will serve just as well, though running *uncompress*, followed by a =tar xvf= also works. 


You may preview this process by a =tar tzvf filename=, which lists the files in the archive without actually unpacking them.



The above method of unpacking "tarballs" is equivalent to either of the following:
#+begin_src shell
  gzip -cd filename | tar xvf -
  gunzip -c filename | tar xvf -
  # The '-' causes the tar command to take its input from stdin.

  # gzip
  # -c, --stdout, --to-stdout: Write output on standard output; keep original files unchaged.
  # -d: decompress

  # gunzip
  # -c, --stdout, --to-stdout: Write output on standard output; keep original files unchaged.  
#+end_src




Source files in the new =bzip2= (=.bz2=) format can be unarchived by a =bzip2 -cd filename | tar xvf -=, or, more simply by a =tar xyvf filename=, assuming that tar has been appropriately patched.
#+begin_src shell
  bzip2 -cd filename | tar xvf -
  # or
  tar xyvf filename
#+end_src


Sometimes the archived file must be untarred and installed from the user's home directory, or perhaps in a certain other directory, such as =/, /usr/src=, or =/opt=, as specified in the package's config info. Should you get an error message attempting to untar it, this may be the reason. Read the package docs, especially the =README= and/or =Install= files, if present, and edit the config files and/or =Makefiles= as necessary, consistent with the installation instructions. Note that you would not ordinarily alter the =Imake= file, since this could have unforseen consequences. Most software packages permit automating this process by running =make install= to emplace the binaries in the appropriate system areas.



Occasionally, you may need to update or incorporate bug fixes into the unarchived source files using a =patch= or =diff= file that lists the changes. The doc files and/or README file will inform you should this be the case. The normal syntax for invoking Larry Wall's powerful =patch= utility is =patch < patchfile=.


* Using <<<Make>>>
The =Makefile= is the key to the build process. In its simplest form, a Makefile is a script for compiling or building the "binaries", thex executable portions of a package.


At some point, the Makefile lauches =cc= or =gcc=. This is actually a processor, a C (or C++) compiler, and a linker, invoked in that order. This process converts the source into the binaries, the actual executables.


Invoking *make* usually involves just typing =make=. This generally builds all the necessary executable files for the package in question. However, make can also do other tasks, such as installing the files in their proper directories (=make install=) and removing stale object files (=make clean=). Running =make -n= permits previewing the build process, as it prints out all the commands that would be triggered by a make, without actually executing them.



Only the simplest software uses a generic Makefile. More complex installations require tailoring the Makefile according to the location of libraries, include files, and resources on your particular machine. This is especially the case when the build needs the X11 libraries to install. <<<Imake>>> and <<<xmkmf>>> accomplish this task.


An =Imakefile= is, to quote the man page, a "template" Makefile. The imake utility constructs a Makefile appropriate for your system from the Imakefile. In almost all cases, however, you would run =xmkmf=, a shell script that invokes imake, a front end for it. Check the =README= or =INSTALL= file included in the software archive for specific instructions. (If, after dearchiving the source files, there is an Imake file present in the base directory, this is a dead giveaway that xmkmf should be run.) Read the Imake and xmkmf man pages for a more detailed analysis of the procedure.



Be aware that =xmkmf= and =make= may need to be invoked as root, especially when doing a make install to move the binaries over to the =/usr/bin= or =/usr/local/bin= directories. Using make as an ordinary user without root privileges will likely result in write access denied error messages because you lack write permission to system directories. Check also that the binaries created have the proper execute permissions for you and any other appropriate users.



Invoking =xmkmf= uses the Imake file to build a new Makefile appropriate for your system. You would normally invoke =xmkmf= with the =-a= argument, to automatically do a make Makefiles, make includes, and make depend. This sets the variables and defines the library locations for the compiler and linker. Sometimes, there will be no =Imake= file, instead there will be an =INSTALL= or =configure= script that will accomplish this purpose. Note that if you run =configure=, it should be invoked as =./configure= to ensure that the correct =configure= script in the current directory is called. In most cases, the =README= file included with the distribution will explain the install procedure.




It is usually a good idea to visually inspect the =Makefile= that =xmkmf= or one of the install scripts builds. The Makefile will normally be correct for your system, but you may occasionally be required to "tweak" it or correct errors manually.



Installing the freshly built binaries into the appropriate system directories is usually a matter of running =make install= as root. The usual directories for system-wide binaries on modern Linux distributions are =/usr/bin, /usr/X11R6/bin=, and =/usr/local/bin=. The preferred directory for new packages is =/usr/local/bin=, as this will keep separate binaries not part of the original Linux installation.


Packages originally targeted for commercial versions of UNIX may attempt to install in the =/opt= or other unfamiliar directory. This will, of course, result in an installation error if the intended installation directory does not exist. The simplest way to deal with this is to create, as root, an =/opt= directory, let the package install there, then add that directory to the =PATH= environmental variable. Alternatively, you may create symbolic links to the /usr/local/bin directory.


Your general installation procedure will therefore be:

1. Read the =README= file and other applicable docs.
2. Run =xmkmf -a=, or the =INSTALL= or =configure= script.
3. Check the =Makefile=.
4. If necessary, run =make clean=, =make Makefiles=, =make includes=, and =make depend=.
5. Run =make=.
6. Check file permissions.
7. If necessary, run =make install=.




* Prepackaged Binaries
Manually building and installing packages from source is apparently so daunting a task for some Linux users that they have embraced the popular rpm and deb or the newer Stampede slp package formats. But there are some disadvantages of this prepackaged binaries.


*(later than tarball)*
First, be aware that software packages are normally released first as "tarballs", and that prepackaged binaries follow days, weeks, even months later. A current rpm package is typically at least a couple of minor version behind the latest "tarball". So, if you wish to keep up with all the 'bleeding edge' software, you might not wish to wait for an rpm or deb to appear. Some less popular packages may never be rpm'ed.


*(may be missing functionality)*
Second, the "tarball" package may well be more complete, have more options, and lend itself better to customization and tweaking. The binary rpm version may be missing some of the functionality of the full release. Source rpm's contain the full source code and are equivalent to the corresponding "tarballs", and they likewise need to be built and installed using either of the =rpm --recompile packagename.rpm= or =rpm --rebuild packagename.rpm= options.


*(may not work correctly)*
Third, some prepackaged binaries will not properly install, and even if they do install, they could crash and core-dump. They may depend on different library versions than are present in your system, or they may be improperly prepared or just plain broken. In any case, when installing an rpm or deb you necessarily trust the expertise of the persons who have packaged it.

*(separate source code)*
Finally, it helps to have the source code on hand, to be able to tinker with and learn from it. It is much more straightforward to have the source in the archive you are building the binaries from, and not in a separate source rpm.




You must install rpm's and deb's as root, in order to have the necessary write permissions, and this opens a potentially serious security hole, as you may inadvertently clobber system binaries and libraries, or even install a Trojan horse that might wreak havoc upon your system. It is therefore important to obtain rpm and deb packages from a "trusted source". In any case, you should run a 'signature check' (against the MD5 checksum) on the package, =rpm --checksig packagename.rpm=, before installing. Likewise highly recommended is running =rpm -K --nopgp packagename.rpm=. The corresponding commands for deb packages are =dpkg -I | --info packagename.deb= and =dpkg -e | --control packagename.deb=.

#+begin_src shell
  rpm --checksig gnucash-1.1.23-4.i386.rpm
  gnucash-1.1.23-4.i386.rpm: size md5 OK

  rpm -K --nopgp gnucash-1.1.23-4.i386.rpm
  gnucash-1.1.23-4.i386.rpm: size md5 OK  
#+end_src


* Final Steps
Read the software package documentation to determine whether certain environmental variables need setting and if the =.Xdefaults= and =.Xresources= files need customizing.



There may be an applications default file, usually named =Xfoo.ad= in the original Xfoo distribution. If so, edit the =Xfoo.ad= file to customize it for your machine, then rename it =Xfoo= and install it in the =/usr/lib/X11/app-defaults= directory, as root. Failure to do this may cause the software to behave strangely or even refuse to run.


Most software packages come with one or more preformatted man pages. As root, copy the =Xfoo.man= file to the appropriate =/usr/man=, =/usr/local/man=, or =/usr/X11R6/man= directory (man1 - man9), and rename it accordingly. For example, if =Xfoo.man= ends up in =/usr/man/man4=, it should be renamed =Xfoo.4=. By convention, user commands go in man1, games in man6, and administration packages in man8 (see the man docs for more details). Of course, you may deviate from this on your own system, if you like.


A few packages will not install the binaries in the appropriate system directories, that is, they are missing the =install= option in the Makefile. Should this be the case, you can install the binaries manually by copying the binaries to the appropriate system directory, =/usr/bin=, =/usr/local/bin= or =/usr/X11R6/bin=, as root. Note that =/usr/local/bin= is the preferred directory for binaries that are not part of the Linux distribution's base install.



Some or all of the above procedures should, in most cases, be handled automatically by a =make install=, and possibly a =make install.man= or =make install_man=. If so, the =README= or =INSTALL= doc file will specify this.



