:PROPERTIES:
:ID:       2EB7965E-9922-4197-B40C-1EC0CE7A9BF4
:END:
#+title: common lisp

[[id:E8EE0CF6-A8D8-4A9C-A2EF-F8B0FF466E25][cl web]]


* DONE Introduction
:LOGBOOK:
- State "DONE"       from              [2024-02-13 Tue 08:36]
:END:


Lisp has the following properites:
- Lisp is designed to evolve.
- Lisp gives you tools that other languages don't provide. 
- Lisp is natrual for bottom-up programming.
- Lisp style depend less on planning and more on exploration.

Programming languages teach you not to want what they cannot provide. You have to think in a language to write programs in it, and it's hard to want something you can't describe. That's also why a programming language can evolve is important.


A new model of programming is that instead of hoping that people won't make mistakes, it tries to make the cost of mistakes very low.
The cost of a mistake is the time required to correct it.


* IDE

** SBCL
<<<SBCL>>>: Steel Bank Common Lisp system.
It is a common lisp implementation.


On MacOS:
#+begin_src shell
  brew install sbcl
#+end_src

** Emacs
Emacs is the prefered eidtor for common lisp.

** SLIME
<<<SLIME>>>: The Superior Lisp Interaction Mode for Emacs
SLIME is a Emacs mode for Common Lisp development.

#+begin_src emacs-lisp
(use-package slime
  :ensure t
  :config
  (setq inferior-lisp-program "/opt/sbcl/bin/sbcl"))
#+end_src

*** Top Level
After installed package, you can you =M-x slime= to invoke Lisp top-level.
In top-level, you can use
#+begin_src lisp
(declaim (sb-ext:muffle-conditions cl:warning))  
#+end_src
to deprecate the warnnings.

** Quicklisp

Quicklisp is more than a package manager, it is also a central repository (a dist) that ensures that all libraries build together.
It provides its own dist but it is also possible to build our own.

To install it:
1. Download the file.
   #+begin_src shell
     curl -O https://beta.quicklisp.org/quicklisp.lisp
   #+end_src
2. Enter a Lisp REPL (Read Eval Print Loop) and load this file.
   #+begin_src shell
     sbcl --load quicklisp.lisp  
   #+end_src
3. Run the command in REPL.
   #+begin_src shell
     (quicklisp-quickstart:install)
   #+end_src
   This will create the =~/quicklisp/= directory, where Quicklisp will maintain its state and downloaded projects.
4. (Optional) If you want Quicklisp to always be loaded in you Lisp session.
   #+begin_src shell
   (ql:add-to-init-file)
   #+end_src
   #+begin_example
    To load a system, use: (ql:quickload "system-name")

    To find systems, use: (ql:system-apropos "term")

    To load Quicklisp every time you start Lisp, use: (ql:add-to-init-file)

    For more information, see http://www.quicklisp.org/beta/
   #+end_example


*** Advanced Dependencies Management
#+begin_src shell
(asdf/source-registry:default-user-source-registry)
(:SOURCE-REGISTRY (:TREE (:HOME "common-lisp/"))
 (:DIRECTORY (:HOME ".sbcl/systems/"))
 (:DIRECTORY #P"/Users/mingmingli/.local/share/common-lisp/systems/")
 (:TREE #P"/Users/mingmingli/.local/share/common-lisp/source/")
 :INHERIT-CONFIGURATION)
#+end_src

A library installed in the previous lists is a vailable for every project.


* DONE Welcome to Lisp
:LOGBOOK:
- State "DONE"       from              [2024-02-03 Sat 20:12]
:END:

** Form                                                           :important:

It is particularly true of Lisp that you learn it by using it, because Lisp is an interactive language. Any Lisp system will include an interactive front-end called the *<<<toplevel>>>*. You type Lisp expressions into the toplevel, and the system displays their values. 

Lisp usually displays a prompt to tell you that it's waiting for you to type something. Many implementations of Common Lisp use =>= as the toplevel prompt. 


#+begin_src lisp
CL-USER> 1
1
CL-USER> (+ 2 3)
5
CL-USER> (/ (- 7 1) (- 4 2))
3
#+end_src

In the expression (+ 2 3), the + is called the *operator*, and the numbers 2 and 3 are called *arguments*.
This is called *<<<prefix notation>>>*, because the operator comes first.
In our real life, you usually write like $1 + 2 + 3$. This is called infix notation.

All Lisp expressions are either *<<<atoms>>>*, like 1, or *<<<list>>>*, which consist of zero or more expressions enclosed in parentheses. All Lisp code take this form.

** Evaluation                                                     :important:
In the expression (+ 2 3), + is a function and an expression like (+ 2 3) is a function call. When lisp evaluates a function call. it does so in two steps:
1. The arguments are evaluated, from left to right. In this case, each argument evaluates to itself, so the values of the arguments are 2 and 3, respectively.
2. The values of the arguments are passed to the function named by the operator. In this case, it is the + function, which returns 5.


Not all the operators in Common Lisp are functions, but most are. And function calls are always evaluated this way. The arguments are evaluated left-to-right, and their values are passed to the function, which returns the value of the expression as a whole. This is called the *<<<evaluation rule>>>* for Common Lisp.



One operator that doesn't follow the Common Lisp evaluation rule is =quote=. The =quote= operator is a *<<<special operator>>>*, meaning that it has a distinct evaluation rule of its own. And the rule is: do nothing. The =quote= operator takes a single argument, and just returns it verbatim:
#+begin_src lisp
CL-USER> (quote (+ 3 5))
(+ 3 5)
#+end_src

For convenience, Common Lisp defines ' as an abbreviation for =quote=.
You can get the effect of calling =quote= by affixing a ' to the front of any expression:
#+begin_src lisp
CL-USER> '(+ 3 5)
(+ 3 5)
#+end_src


It is much more common to use the abbreviation than to write out the whole =quote= expression.


Lisp provides the quote as a way of protecting expressions from evaluation.
** Data
*** Integer
Integer is written as a series of digits.
#+begin_src lisp
CL-USER> 1024
1024  
#+end_src
*** String
String is represented as a series of characters surrounded by double-quotes.
#+begin_src lisp
CL-USER> "China"
"China"
#+end_src

Intergers and strings are both evaluate to themselves.
*** Symbol
Symbols ae words. Ordinarily they are converted to uppercase, regardless of how you type them.
#+begin_src lisp
CL-USER> 'China
CHINA  
#+end_src

Symbols do not (usually) evaluate to themselves, so if you want to refer to a symbol, you should quote it, as above.
*** List
Lists are represented as zero or more elements enclosed in parentheses. The elements can be of any type, including lists. You have to quote lists, or Lisp would take them for function calls.

#+begin_src lisp
CL-USER> '(the list (a b c) has 3 elements)
(THE LIST (A B C) HAS 3 ELEMENTS)  
#+end_src

One quote protects a whole expressions, including expressings within it.



You can build lists by calling =list= . Since =list= is a function, its arguments are evaluated.
#+begin_src lisp
CL-USER> (list 'i 'have (- 3 1) "computers")
(I HAVE 2 "computers")  
#+end_src

We are now in a position to appreciate one of the most remarkable features of Lisp. *Lisp programs are expressed as lists*. It means that Lisp programs can generate Lisp code. Lisp programmers can (and often do) write programs to write their programs for them.

The relation between expressions and lists is: if a list is quoted, evaluation returns the list itself; if it is not quoted, the  list is treated as code, and evaluation returns its values.

In Common Lisp, there are two ways of representing the empty list.
#+begin_src lisp
CL-USER> ()
NIL
CL-USER> nil
NIL
#+end_src


** List Operations

There are three basic functions:
- cons :: build list
- car :: the first element of a list
- cdr :: everything after the first element


#+begin_src lisp
CL-USER> (cons 'a '(b c d))
(A B C D)
CL-USER> (car '(a b c))
A
CL-USER> (cdr '(a b c))
(B C)  
#+end_src

** Truth
The symbol =t= is the default representation for truth. Like =nil= , =t= evaluates to itself. The function =listp= returns true if its argument is a list:
#+begin_src lisp
CL-USER> (listp '(a b c))  
T
#+end_src

A function whose return value is intended to be interpreted as truth or falsity is called a *predicate*. Common Lisp predicates often have names that end with =p=.


Falsity is represented by =nil= , the empty list.
#+begin_src lisp
CL-USER> (listp 123)
NIL
#+end_src

Because =nil= plays two roles in Common Lisp, the function =null=, whick returns true of the empty list
#+begin_src lisp
CL-USER> (null nil)
T  
#+end_src
and the function =not=, which return true if its arguments is false
#+begin_src lisp
CL-USER> (not nil)
T  
#+end_src
do the exactly the same thing.



The simplest conditional in Common Lisp is =if=. It usually takes three arguments: a test expression, a then expression, and an else expression. The test expression is evaluated. If it returns true, the then expression is evaluated and its value is returned. If the test expression returns false, the else expression is evaluated and its value is returned:
#+begin_src lisp
CL-USER> (if (listp '(a))
	     (+ 1 2)
	     (+ 5 6))
3
CL-USER> (if (listp 1)
	     (+ 1 2)
	     (+ 5 6))
11  
#+end_src
Like =quote=, =if= is a special operator. It could not possibly be implemented as a function, because the arguments in a function call are always evaluated, and the whole point of =if= is that only one of the last two arguments is evaluated.

The last argument is optional. If you omit it, it defaults to =nil=.
#+begin_src lisp
CL-USER> (if (listp 1)
	     (+ 1 2))
NIL 
#+end_src


Although =t= is the default representation for truth, everything except =nil= also counts as true in a logical context.


The logical operators =and= and =or= resemble conditionals. Both take any number of arguments, but only evaluates as many as they need to in order to decide what to return. If all its arguments are true, then =and= returns the value of the last one:
#+begin_src lisp
CL-USER> (and t (+ 1 2))
3
#+end_src
But if one of the arguments turns out to be false, none of the arguments after that get evaluated. Similarly for =or=, which stops as soon as it finds an argument that is true:
#+begin_src lisp
CL-USER> (or nil 3 (listp '(a)))
3  
#+end_src


These two operators are *macros*. Like special operators, macros can circumvent the usual evaluation rule.


** Functions
You can define new functions with =defun=. It usually takes three or more arguments: a name, a list of parameters, and one or more expressions that will make up the body of the function. Here is how we might define third:
#+begin_src lisp
CL-USER> (defun our-third (x)
	   (car (cdr (cdr x))))
OUR-THIRD  
#+end_src


The first argument says that the name of this function will be *our-third*. The second argument, the list =(x)=, says that the function will take exactly one argument: =x=. A symbol used as a placeholder in this way is called a *<<<variable>>>*. When the variable represents an argument to a function, as =x= does, it is also called a *<<<parameter>>>*.

The rest of the definition, =(car (cdr (cdr x)))=, is known as the body of the function. It tells Lisp what it has to do to calculate the return value of the function.



Now that we've seen variables, it's easier to understand what symbols are. They are variable names, existing as objects in their own right. And that's why symbols, like lists, have to be quoted. A list has to be quoted because otherwise it will be treated as code; a symbol has to be quoted because otherwise it will be treated as a variable.


You can think of a function definition as a generalized version of a Lisp expression. The following expression tests whether the sum of 1 and 4 is greater than 3:
#+begin_src lisp
CL-USER> (> (+ 1 4) 3)
T  
#+end_src
By replacing these particular numbers with variables, we can write a function that will test whether the sum of any two numbers is greater than a third:
#+begin_src lisp
CL-USER> (defun sum-greater (x y z)
	   (> (+ x y) z))
SUM-GREATER
CL-USER> (sum-greater 1 4 3)
T  
#+end_src


** Recursion
The functions we defined in the previous section called other functions to do some of their work for them. For example, =sum-greater= called =+= and =>=. A function can call any function, including itself.

A function that calls itself is *<<<recursive>>>*. The Common Lisp function =member= tests whether something is an element of a list. Here is a simplified version defined as a recursive function:
#+begin_src lisp
  (defun our-member (obj lst)
    (if (null lst)
	nil
	(if (eql (car lst) obj)
	lst
	(our-member obj (cdr lst)))))  
#+end_src

The predicate =eql= tests whether its two arguments are identical. Here is in action:
#+begin_src lisp
CL-USER> (our-member 'b '(a b c))
(B C)
CL-USER> (our-member 'z '(a b c))
NIL  
#+end_src

The definition of =our-member= corresponds to the following English description. To test whether an object =obj= is a member of a list =lst=, we
1. First check whether =lst= is empty. If it is, then =obj= is clearly not a member of it, and we're done.
2. Otherwise, if =obj= is the first element of =lst=, it is a member.
3. Otherwise =obj= is only a member of =lst= if it is a member of the rest of =lst=.
When you want to understand how a recursive function works, it can help to translate it into a description of this kind.

** Reading Lisp
The pseudo-=member= defined in the preceding section ends with five parentheses. More elaborate function definitions might end with seven or eight. How is one to see which parenthesis matches which?

The answer is, one doesn't have to. Lisp programmers read and write code by *indentation*, not by parentheses. When they're writing code, they let the text editor show which parenthesis matches which.

With a good editor, matching parentheses ceases to be an issue when you're writing code. And because there are universal conventions for Lisp indentation, it's not an issue when you're reading code either. Because everyone uses the same conventions, you can read code by the indentation, and ignore the parentheses.

** Input and Output
The most general output function in Common Lisp is =format=. It takes two or more arguments: the first indicates where the output is to be printed, the second is a string template, and the remaining arguments are usually objects whose printed representations are to be inserted into the template. Here is a typical example:
#+begin_src lisp
CL-USER> (format t "~A plus ~A equals ~A ~%" 2 3 (+ 2 3))
2 plus 3 equals 5 
NIL  
#+end_src

Notice that two things get displayed here. The first line is displayed by =format=. The second line is the value returned by the call to =format=, displayed in the usual way by the toplevel. Ordinarily a function like =format= is not called directly from the toplevel, but used within programs, so the return value is never seen.


The first argument to =format=, =t=, indicates that the output is to be sent to the default place. Ordinarily this will be the toplevel. The second argument is a string that serves as a template for output. Within this string, each =~A= indicates a position to be filled, and the =~%= indicates a newline. The positions are filled by the values of the remaining arguments, in order.



The standard function for input is =read=. Then given no arguments, it reads from the default place, which will usually the the toplevel. 
#+begin_src lisp
CL-USER> (read)
16
16
#+end_src

=read= will sit waiting indefinitely until you type something and (usually) hit reuturn. =read= is very powerful: =read= is a complete Lisp parser. It doesn't just read characters and return them as a string. It parses what it reads, and returns the Lisp object that results. In the case above, it returned a number.

"Pure" Lisp is Lisp without side-effects. A *<<<side-effect>>>* is some change to the state of the world that happens as a consequence of evaluating an expression. When we evaluate a pure Lisp expression like =(+ 1 2)=, there are no side-effects; it just returns a value. But when we call =format=, it prints something. That's one kind of side-effect.


When we are writing code without side-effects, there is no point in defining functions with bodies of more than one expression. The value of the last expression is returned as the value of the function, but the values of any preceding expressions are thrown away. If such expressions didn't have side-effects, you would have no way of telling whether Lisp bothered to evaluate them at all.




** Variables
One of the most frequently used operators in Common Lisp is =let=, which allows you to introduce new local variables:
#+begin_src lisp
CL-USER> (let ((x 1) (y 2))
	   (+ x y))
3
#+end_src

A =let= expression has two parts. First comes a list of instructions for creating variables, each of the form =(variable expression)=. Each =variable= will initially be set to the value of the corresponding =expression=. So in the example above, we create two new variables, =x= and =y=, which are initially set to 1 and 2, respectively. These variables are valid within the body of the =let=.


After the list of variables and values comes a body of expressions, which are evaluated in order. In this case there is only one, a call to =+=. The value of the last expression is returned as the value of the =let=.



Variables like those we have seen so far are called *<<<local variables>>>*. They are only valid within a certain context. There is another kind of variable, called a *<<<global variable>>>*, that can be visible everywhere.


You can create a global variable by giving a symbol and a value to =defparameter=:
#+begin_src lisp
CL-USER> (defparameter *glob* 99)
*GLOB*  
#+end_src
Such a variable will then be accessible everywhere, except in expressions that create a new local variable with the same name. To avoid the possibility of this happening by accident, it's conventional to give global variables names hat begin and end with asterisks.

You can also define global constants, by calling =defconstant=:
#+begin_src lisp
CL-USER> (defconstant limit (+ *glob* 1))
LIMIT  
#+end_src

There is no'need to give constants distinctive names, because it will cause an error if anyone uses the same name for a variable. If you want to check whether some symbol is the name of a global variable or constant, use =boundp=:


#+begin_src lisp
CL-USER> (boundp '*glob*)
T
CL-USER> (boundp 'limit)
T  
#+end_src



** Assignment
In Common Lisp the most general assignment operator is =setf=. We can use it to do assignments to either kind of variable:
#+begin_src lisp
CL-USER> (setf *glob* 98)
98
CL-USER> (let ((n 10))
	   (setf n 2)
	   n)
2  
#+end_src

When the first argument to =setf= is a symbol that is not the name of a local variable, it is taken to be a global variable:
#+begin_src lisp
CL-USER> (setf x (list 'a 'b 'c))
; in: SETF X
;     (SETF X (LIST 'A 'B 'C))
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::X
; 
; compilation unit finished
;   Undefined variable:
;     X
;   caught 1 WARNING condition
(A B C)  
#+end_src
That is, you can create global variables implicitly, just by assigning them values. In source files, at least, it is better style to use explicit =defparameters=.


You can do more than just assign values to variables. The first argument to =setf= can be an expression as well as a variable name. In such cases, the
value of the second argument is inserted in the place referred to by the first:
#+begin_src lisp
CL-USER> (setf (car x) 'n)
N
CL-USER> x
(N B C)  
#+end_src

The first argument to =setf= can be almost any expression that refers to a particular place.


You can give any (even) number of arguments to =setf=.
#+begin_src lisp
  (setf a 1
	b 2
	c 3)

  ;; equal to
  (setf a 1)
  (setf b 2)
  (setf c 3)
#+end_src


** Functional Programming
*<<<Functional programming>>>* means writing programs that work by returning values, instead of by modifying things. It is the dominant paradigm in Lisp. Most built-in Lisp functions are meant to be called for the values they return, not for side-effects.



#+begin_src lisp
CL-USER> (setf lst '(a b c d e f))
(A B C D E F)
CL-USER> (remove 'a lst)
(B C D E F)
CL-USER> lst
(A B C D E F)
CL-USER>   
#+end_src
In this example, the function =remove= returned a new list and did not change the original list.

So what if you really do want to remove something from a list? In Lisp you generally do such things by passing the list as an argument to some function, and using =setf= with the return value. To remove all the as from a list =x=, we say:
#+begin_src lisp
(setf x (remove 'a x))  
#+end_src


The more side-effect you do without, the better off you'll be.

One of the most import advantage of functional programming is that it allows *interactice testing*. In purely functional code, you can test each function as you write it. If it returns the values you expect, you can be confident that it is correct.

** Iteration
When we want to do something repeatedly, it is sometimes more natural to use iteration than recursion. A typical case for iteration is to generate some sort of table. This function
#+begin_src lisp
  (defun show-squares (start end)
    (do ((i start (+ i 1)))
	((> i end) 'done)
      (format t "~A ~A~%" i (* i i))))
#+end_src
prints out the squares of the integers from =start= to =end=.
#+begin_src lisp
CL-USER> (show-squares 2 5)
2 4
3 9
4 16
5 25
DONE  
#+end_src

The =do= macro is the fundamental iteration operator in Common Lisp. Like =let=, =do= can create variables, and the first argument is a list of variable specifications. Each element of this list can be of the form
#+begin_example
(variable initial update)
#+end_example
where =variable= is a symbol, and =initial= and =update= are expressions. Initially each =variable= will be set to the value of the corresponding =initial=, on each iteration it will be set to the value of the corresponding =update=. The =do= in =show-squares= creates just one variable, =i=. On the first iteration =i= will be set to the value of =start=, and on successive iterations its value will be incremented by one.


The second argument to =do= should be a list containing one or more expressions. The first expression is used to test whether iteration should stop. In the case above, the test expression is =(> i end)=. The remaining expressions in this list will be evaluated in order when iteration stops, and the value of the last will be returned as the value of the =do=. So =show-squares= will always return =done=.


The remaining arguments to =do= comprise the body of the loop. They will be evaluated, in order, on each iteration. On each iteration the variables are updated, then the termination test is evaluated, and then (if the test failed) the body is evaluated.


Common Lisp has simpler iteration operators for special cases. To iterate through the elements of a list, for example, you would be more likely to use =dolist=. Here is a function that returns the length of a list:
#+begin_src lisp
  (defun our-length (lst)
    (let ((len 0))
      (dolist (obj lst)
	(setf len (+ len 1)))
      len))
#+end_src
Here =dolist= takes an argument of the form =(variable expression)=, followed by a body of expressions. The body will be evaluated with =variable= bounded to successive elements of the list returned by =expression=. So the loop above says, for each =obj= in =lst=, increment =len=.


** Functions as Objects
In Lisp, functions are regular objects, like symbols or strings or lists. If we give the name of a function to =function=, it will return the associated object. Like =quote=, =function= is a special operator, so we don't have to quote the argument:

#+begin_src lisp
CL-USER> (function +)
#<FUNCTION +>  
#+end_src

Until now we have only dealt with objects that look the same when Lisp displays them as when we typed them in. This convention does not apply to functions. Internally, a built-in function like =+= is likely to be a segment of machine language code. A Common Lisp implementation may choose whatever external representation it likes.


Just as we can use ='= as an abbreviation for =quote=, we can use =#'= as an abbreviation for =function=:
#+begin_src lisp
CL-USER> #'+
#<FUNCTION +>  
#+end_src
This abbreviation is known as sharp-quote.

Like any other kind of object, we can pass functions as arguments. One function that takes a function as an argument is =apply=. It takes a function and a list of arguments for it, and returns the result of applying the function to the arguments:
#+begin_src lisp
CL-USER> (apply #'+ '(1 2 3))
6
CL-USER> (+ 1 2 3)
6
#+end_src
It can be given any number of arguments, so long as the last is a list:
#+begin_src lisp
CL-USER> (apply #'+ 1 2 '(3 4 5))
15  
#+end_src


The function =funcall= does the same thing but does not need the arguments to be packaged in a list:
#+begin_src lisp
CL-USER> (funcall #'+ 1 2 3)
6  
#+end_src

The =defun= macro creates a function and gives it a name. But functions don't have to have names, and we don't need =defun= to define them. Like most other kinds of Lisp objects, we can refer to functions literally.

To refer literally to an integer, we use a series of digits; to refer literally to a function, we use what's called a *lambda expression*. A lambda expression is a list containing the symbol =lambda=, followed by a list of parameters, followed by a body of zero or more expressions.

Here is a lambda expression representing a function that takes two numbers and returns their sum:
#+begin_src lisp
  (lambda (x y)
    (+ x y))  
#+end_src
The list =(x y)= is the parameter list, and after it comes the body of the function.


A lambda expression can be considered as the name of a function. Like an ordinary function name, a lambda expression can be the first element of a function call
#+begin_src lisp
CL-USER> ((lambda (x) (+ x 100)) 1)
101  
#+end_src
and by affixing a sharp-quote to a lambda expression, we get the corresponding function,
#+begin_src lisp
CL-USER> (funcall #'(lambda (x) (+ x 100))
		  1)
101  
#+end_src

** Types
Lisp has an unusually flexible approach to *<<<types>>>*. In many languages, variables are what have types, and you can't use a variable without specifying its type. In Common Lisp, values have types, not variables. You could imagine that every object had a label attached to it, identifying its type. This approach is called *<<<manifest typing>>>*. You don't have to declare the types of variables, because any variable can hold objects of any type.

Though type declarations are never required, you may want to make them for reasons of efficiency.

The built-in Common Lisp types form a hierarchy of subtypes and supertypes. An object always has more than one type. For example, the number 27 is of type =fixnum, integer, rational, real, number, atom=, and =t=, in order of increasing generality. The type =t= is the supertype of all types, so everything is of type =t=.

The function =typep= takes an object and a type specifier, and returns true if the object is of that type:
#+begin_src lisp
CL-USER> (typep 27 'integer)
T
#+end_src


** Summary
Richard Gabriel once half-jokingly described C as a language for writing Unix. We could likewise describe Lisp as a language for writing Lisp. But this is a different kind of statement. A language that can be written in itself is fundamentally different from a language good for writing some particular class of applications. It opens up a new way of programming: as well as writing your program in the language, you can improve the language to suit your program. If you want to understand the essence of Lisp programming, this idea is a good place to begin.

* DONE Lists
:LOGBOOK:
- State "DONE"       from              [2024-02-13 Tue 08:51]
:END:
Lists are one the fundamental data structures in Lisp. In the earliest dialects they are the only data structure: the name "Lisp" originally stood for "LISt Processor". But Lisp has long since outgrown this acronym. Common Lisp is a general-purpose programming language with a wide variety of data structures.



The development of Lisp programs often echoes the development of Lisp itself. In the initial version of a Lisp program, you may use a lot of lists. Then in later versions you may switch to faster, specialized data structures.


This chapter describes the many things you can do with lists, and uses them to illustrate some general Lisp concepts.

** Conses

What =cons= really do is combine two objects into a two-part object called *<<<cons>>>*. Conceptuallly, a cons is a paire of pointers; the first one is the car and the second is the cdr. This provide the possiblity to build lists with conses. Any nonempty list can be considered as a pair of the first element and the rest of the list. Lisp lists are the embodiment of this idea. We use one half of the cons to point to the first element of the list, and the other to point to the rest of the list (which is either another cons or =nil=). So lists are not a distinct kind of object, but conses linked together in this way.

#+begin_src lisp
CL-USER> (setf x (cons 'a nil))
(A)
CL-USER> (car x)
A
CL-USER> (cdr x)
NIL
#+end_src

The function =consp= return true if its argument is a cons. So listp could be defined:
#+begin_src lisp
  (defun our-listp (x)
    (or (null x) (consp x)))
#+end_src

Since everything that is not a cons is an atom, the preidcate =atom= could be defined:
#+begin_src lisp
  (defun our-atom (x) (not (consp x)))
#+end_src

=nil= is both an atom and a list.



** Equality
Each time you cal =cons=, Lisp allocates a new piece of memory with room for two pointers. So if we call =cons= twice with the same arguments, we get back two values that look the same, but are in fact distince objects:
#+begin_src lisp
CL-USER> (eql (cons 'a nil) (cons 'a nil))
NIL  
#+end_src
It would be convenient if we could also ask whether two lists had the same
elements. Common Lisp provides another equality predicate for this purpose: =equal=. While =eql= returns true only if its arguments are the same object,
#+begin_src lisp
CL-USER> (setf x (cons 'a nil))
(A)
CL-USER> (eql x x)
T  
#+end_src
=equal= returns true if its arguments would print the same,
#+begin_src lisp
CL-USER> (equal (cons 'a nil) (cons 'a nil))
T  
#+end_src

** Why Lisp Has No Pointers
One of the secrets to understanding Lisp is to realize that variables have values in the same way that lists have elements. As conses have pointers to their elements, variables have pointers to their values.

In other languages like C, pointers were manipulated explicitly. In Lisp you never have to do this, because the language handles pointers for you. We've already seen how this happens with lists. Something similar happens with variables. Suppose, for example, we set two variables to the same list:
#+begin_src lisp
CL-USER> (setf x '(a b c))
(A B C)
CL-USER> (setf y x)
(A B C)
#+end_src

What actually happens when we set =y= to the value of =x=? The location in memory associated with the variable =x= does not contain the list itself, but a pointer to it. When we assign the same value to =y=, Lisp copies the pointer, not the list. So whenever you assign one variable the value of another, the two variables will have =eql= values:
#+begin_src lisp
CL-USER> (eql x y)
T  
#+end_src

The reason Lisp has no pointers is that every value is conceptually a pointer. When you assign a value to a variable or store it in a data structure, what gets stored is actually a pointer to the value. When you ask for the contents of the data structure or the value of the variable, Lisp returns what it points to. But all this happens beneath the surface. You can just put values in structures or "in" variables without thinking about it.


** Building Lists
The function =copy-list= takes a list and returns a copy of it. The new list will have the same elements, but contained in new conses.
#+begin_src lisp
CL-USER> (setf x '(a b c)
	       y (copy-list x))
(A B C)
CL-USER> (equal x y)
T
CL-USER> (eql x y)
NIL  
#+end_src

We could think of =copy-list= as being defined,
#+begin_src lisp
  (defun our-copy-list (lst)
    (if (atom list)
	lst
	(cons (car lst) (our-copy-list (cdr lst)))))  
#+end_src




The function =append= returns the concatenation of any number of list.
#+begin_src lisp
CL-USER> (append '(a b) '(c d) '(e))
(A B C D E)  
#+end_src
In doing so, it copies all the arguments except the last.
#+begin_src lisp
CL-USER> (let ((x '(a)) (y '(b c)) (lst))
	   (setf lst (append x y))
	   (format t "lst: ~A~%" lst)
	   (eql y (cdr lst)))
lst: (A B C)
T  
#+end_src

** Access

Common Lisp has additional accesss functions defined in terms of =car= and =cdr=. To find the element at a given position in a slit we call =nth=,
#+begin_src lisp
CL-USER> (nth 0 '(a b c))
A  
#+end_src
and to find the nth cdr, we call =nthcdr=,
#+begin_src lisp
CL-USER> (nth 1 '(a b c))
B  
#+end_src
Both =nth= and =nthcdr= are zero-indexed. In Common Lisp, whenever you use a number to refer to an element of a data structure, the numbering start at zero.


The function =last= return the last cons in a list,
#+begin_src lisp
CL-USER> (last '(a b c))
(C)  
#+end_src
This is not the same as getting the last element. To get the last element of a list, you would take the =car= of =last=.


Common Lisp define =first= through =tenth= as functions that retrieve the corresponding element of a list. These function are not zero-indexed,
#+begin_src lisp
CL-USER> (first '(a b c))
A  
#+end_src



** Mapping Functions
Common Lisp provides several functions for calling functions on the elements of a list. The most frequently used is =mapcar=, which takes a function and one or more lists, and returns the result of applying the function to elements taken from each list, until some list runs out,
#+begin_src lisp
CL-USER> (mapcar #'(lambda (x) (+ x 10))
		 '(1 2 3))
(11 12 13)
CL-USER> (mapcar #'list
		 '(a b c)
		 '(1 2 3 4))
((A 1) (B 2) (C 3))  
#+end_src

The related =maplist= takes the same arguments, but calls the function on successive cdrs of the lists,
#+begin_src lisp
CL-USER> (maplist #'(lambda (x) x)
		  '(a b c))
((A B C) (B C) (C))
CL-USER> (maplist #'length '(a b c))
(3 2 1)  
#+end_src

** Trees
Conses can also be considered as binary *<<<trees>>>*, with the car representing the left subtree and the cdr the right. For examle, the list
#+begin_src lisp
  (a (b c) d)
#+end_src
is also the tree represented in the Figure [[fig:binary-tree]].
#+caption: Binary tree
#+label: fig:binary-tree
[[file:images/binary-tree.png]]


Common Lisp has several built-in functions for use with trees. For example, =copy-tree= takes a tree and returns a copy of it. It might be defined,
#+begin_src lisp
  (defun our-copy-tree (tr)
    (if (atom tr)
	tr
	(cons (our-copy-tree (car tr))
	      (our-copy-tree (cdr tr)))))
#+end_src

Comparing this to the sketch of =copy-list=.
#+begin_src lisp
  (defun our-copy-list (lst)
    (if (atom list)
	lst
	(cons (car lst) (our-copy-list (cdr lst)))))  
#+end_src
=copy-tree= copies both the car and cdr of each cons, while copy-list copies only the cdr.


Common Lisp includes functions for operating on trees not because one needs trees as such, but because one needs a way to do something to a list and all the lists within it. For example, suppose we have a list like
#+begin_src lisp
  (and (integerp x) (zerop (mod x 2)))
#+end_src
and we want to substitute =y= for =x= throughtout. It won't do to call =substitute=, which replaces elements in a sequence,
#+begin_src lisp
CL-USER> (substitute 'y 'x '(and (integerp x) (zerop (mod x 2))))
(AND (INTEGERP X) (ZEROP (MOD X 2)))  
#+end_src
Because the list has tree elements and none of them are =x=. What we need here is a =subst=, which replaces elements in a tree,
#+begin_src lisp
CL-USER> (subst 'y 'x '(and (integerp x) (zerop (mod x 2))))
(AND (INTEGERP Y) (ZEROP (MOD Y 2)))  
#+end_src

If we define a version of subst, it comes out looking a lot like =copy-tree=,
#+begin_src lisp
  (defun our-subst (new old tree)
    (if (eql tree old)
	new
	(if (atom tree)
	    tree
	    (cons (our-subst new old (car tree))
		  (our-subst new old (cdr tree))))))  
#+end_src
Functions that operate on trees usually have this form, recursing down both the car and cdr. Such functions are said to be *doubly recursive*.


** Understanding Recursion
Students learning about recursion are sometimes encouraged to trace all the invocations of a recursive function on a piece of paper. This exercise could be misleading: a programmer defining a recursive function usually does not think explicitly about the sequence of invocations that results from calling it.


If one always had to think of a program in such terms, recursion would be burdensome, not helpful. The advantage of recursion is precisely that it lets us view algorithms in a more abstract way. You can judge whether or not a recursive function is correct without considering all the invocations that result when the function is actually called.


To see if a recursive function does what it's supposed to, all you have to ask is, does it cover all the cases? This is similar to *mathematical induction*.

For example, here is a recursive function for finding the length of a list:
#+begin_src lisp
  (defun len (lst)
    (if (null lst)
	0
	(+ (len (cdr lst)) 1)))
#+end_src

We can assure that this function is correct by verifying two things:
1. That it works for lists of length 0.
2. Given that it works for lists of length $n$, that it also works for lists of length $n+1$.
If we can establish both points, then we know that the function is correct for all possible lists.


Our definition obviously satisfies the first point: =if 1st is nil= , the function immediately returns 0. Now suppose that the function works for lists of length $n$. We give it a list of length $n+1$. The definition says that the function will return the =len= of the cdr of this list, plus 1. The cdr is a list of length $n$. We know by our assumption that its =len= is $n$. Thus the len of the whole list is $n+1$.


Being able to judge whether or not a recursive function is correct is only the first half of understanding recursion. The other half is being able to write a recursive function that does what you want.

   


** Sets
Lists are a good way to represent small *<<<sets>>>*. Every element of a list is a member of the set it represents:
#+begin_src lisp
CL-USER> (member 'b '(a b c))
(B C)  
#+end_src
When =member= returns true, instead of simply returning =t=, it returns the part of list beginning with the object it was looking for. Logically, a cons serves
just as well as =t=, and this way the function returns more information.


By default, =member= compares objects using =eql=. You can override this default by using something called a *keyword* argument. Many Common Lisp functions take one or more keyword arguments. The unusual thing about these arguments is that they are not matched with the corresponding parameters by their position, but by special tags, called keywords, that must precede them in the call. A keyword is a symbol preceded by a colon.

One of the keyword arguments accepted by member is a =:test= argument.
If you pass some function as the =:test= argument in a call to member, then that function will be used to test for equality instead of =eql=. So if we want to find a member of a list that is =equal= to a given object, we might say:
#+begin_src lisp
CL-USER> (member '(b) '((a) (b) (c)))
NIL
CL-USER> (member '(b) '((a) (b) (c)) :test #'equal)
((B) (C))  
#+end_src

Keyword arguments are always optional. If any are included in a call, they come last; if more than one keyword argument is given, their order doesn't matter.


The other keyword argument accepted by member is a =:key= argument. By providing this argument you can specify a function to be applied to each element before comparison:
#+begin_src lisp
CL-USER> (member 'b '((a b) (b c) (c d)))
NIL
CL-USER> (member 'b '((a b) (b c) (c d)) :key #'car)
((B C) (C D))  
#+end_src


If we want to find an element satisfying an arbitrary *predicate* - like =oddp=, which returns true for odd integers - we can use =member-if=:
#+begin_src lisp
CL-USER> (member-if #'oddp '(1 2 3 4))
(1 2 3 4)
CL-USER> (member-if #'oddp '(2 3 4))
(3 4)
#+end_src

We could imagine a limited version of =member-if= being written:
#+begin_src lisp
  (defun our-member-if (fn lst)
    (and (consp lst)
	 (if (funcall fn (car lst))
	     lst
	     (our-member-if fn (cdr lst)))))
#+end_src

The function =adjoin= is like a conditional =cons=. It takes an ojbect and a list, and conses the object onto the list only if it is not already a member:
#+begin_src lisp
CL-USER> (adjoin 'b '(a b c))
(A B C)
CL-USER> (adjoin 'z '(a b c))
(Z A B C)  
#+end_src

The operations of set union, intersection, and complement are implemented by the functions =union, intersection=, and =set-difference=. These functions expect exactly two lists, but also take the same keyword arguments as member.
#+begin_src lisp
CL-USER> (union '(a b c) '(c d e))
(B A C D E)
CL-USER> (intersection '(a b c) '(b b c d))
(C B)
CL-USER> (set-difference '(a b c d e) '(b e))
(D C A)  
#+end_src
Since there is no notion of ordering in a set, these functions do not necessarily bother to preserve the order of elements found in the original lists.

** Sequences
Another way to think of a list is as a series of objects in a particular order. In Common Lisp, *<<<sequence>>>* include both lists and vectors. This section introduces some of the sequence functions that are especially applicable to lists.

#+begin_src lisp
CL-USER> (length '(a b c))
3
#+end_src

To copy part of a sequence, we use =subseq=. The second argument (required) is the position of the first element to be included, and the third argument (optional) is the position of the first element not to be included. If the third argument is omitted, the subsequence goes all the way to the end of the original sequence.
#+begin_src lisp
CL-USER> (subseq '(a b c d) 1 2)
(B)
CL-USER> (subseq '(a b c d) 1)
(B C D)  
#+end_src

The function =reverse= returns a sequence with the same elements as its argument, but in the reverse order:
#+begin_src lisp
CL-USER> (reverse '(a b c d))
(D C B A)  
#+end_src

Common Lisp has a built-in sort function called =sort=. It takes a sequence and a comparision and returns a sequence with the same elements, sorted according to the function:
#+begin_src lisp
CL-USER> (sort '(1 3 5 2 4) #'>)
(5 4 3 2 1)  
#+end_src

You have to be careful when using =sort=, because it's *desctructive*. For efficiency reasons, =sort= is allowed to modify the sequence given to it as an argument. So if you don't want your original sequence modifed, pass a copy.

The function =every= and =some= take a predicate and one or more sequences. When given one sequence, they test whether the elements satisfy the predicate:
#+begin_src lisp
CL-USER> (every #'oddp '(1 3 5))
T
CL-USER> (some #'oddp '(1 2 3))
T  
#+end_src

If they are given more than one sequence, teh predicate must take as many arguments as there are sequences, and arguments are drawn one at a time from all the sequences:
#+begin_src lisp
CL-USER> (every #'> '(1 3 5) '(0 2 4))
T
#+end_src
If the sequences are of different lengths, the shortest one determines the number of tests performed.


** Stacks
The representation of lists as conses makes it natural to use them as pushdown *<<<stacks>>>*. This is down so often that Common Lisp provides two macros for the purpose: =(push x y)= pushes =x= onto the front of the list =y=, and =(pop x)= removes and returns the first element of the list =x=.

Both are defined in terms of =setf=. It's easy to translate calls if the arguments are constants or variables.
#+begin_src lisp
  (push obj lst)
  ;; is equivalent to
  (setf lst (cons obj lst))

  (pop lst)
  ;; is equivalent to
  (let ((x (car lst)))
    (setf lst (cdr lst))
    x)
#+end_src


#+begin_src lisp
CL-USER> (setf lst '(b))
(B)
CL-USER> (push 'a lst)
(A B)
CL-USER> lst
(A B)
CL-USER> (setf lst-copy lst)
(A B)
CL-USER> (pop lst)
A
CL-USER> lst
(B)
CL-USER> lst-copy
(A B)  
#+end_src


The =pushnew= macro is a variant of =push= that uses =adjoin= instead of =cons=:
#+begin_src lisp
CL-USER> (let ((x '(a b)))
	   (pushnew 'c x)
	   (pushnew 'a x)
	   x)
(C A B)  
#+end_src
Here, =c= gets pushed onto the list, but =a=, because it is already a member, does not.


** Dotted Lists
The kind of lists that can be built by calling =list= are more precisely known as *<<<proper list>>>*. A proper list is either =nil=, or a cons whose cdr is a proper list. All the lists we've built so for have been proper lists.

Conses are not just for building lists, however. Whenever you need a structure with two fields you can use a cons. You will be able to use =car= to refer to the first field and =cdr= refer to the second.
#+begin_src lisp
CL-USER> (cons 'a 'b)
(A . B)
#+end_src
Because this cons is not a proper list, it is displayed in *<<<dot notation>>>*. In dot notation, the car and cdr of each cons are shown separated by a period.


A cons that isn't a proper list is called a *<<<dotted list>>>*. This is not a very good name, because conses that aren't proper lists are usually not meant to represent lists at all: =(a . b)= is just a two-part data structure.


You could express proper lists in dot notation as well, but when Lisp displays a proper list, it will always use regular *<<<list notation>>>*:
#+begin_src lisp
CL-USER> '(a . (b . (c . nil)))
(A B C)  
#+end_src

** Assoc-lists
It is also natural to use conses to represent mappings. A list of conses is called an *<<<assoc-list>>>* or *<<<alist>>>*. Such a list could represent a set of translations, for example:


#+begin_src lisp
CL-USER> (setf trans '((+ . "add") (- . "subtract")))
((+ . "add") (- . "subtract"))  
#+end_src

#+begin_src lisp
((+ . "add") (- . "subtract"))
CL-USER> (assoc '+ trans)
(+ . "add")
CL-USER> (assoc '* trans)
NIL  
#+end_src
If =assoc= doesn't find what it's looking for, it returns =nil=.



Like =member=, the real =assoc= takes keyword arguments, including =:test= and =:key=. Common Lisp also defines an =assoc-if=, which is to =assoc= what
=member-if= is to =member=.



** Garbage
Lists can be slow for several reasons. They offer sequential instead of random access, so retriving a given element takes longer in list than an array. Intervally, conses tend to be represented as pointers, so travering a list means travering a series of pointers, instead of simply incrementing an index, as in an array. But these two costs can be small compared to the cost of allocating and recycling cons cells.


*Automatic memory management* is one of Lisp's most valuable features. The Lisp system maintains a segment of memory called the *<<<heap>>>*. The system keeps track of unused memory in the heap and doles it out as new objects are created. The function =cons=, for example, returns a newly allocated cons. Allocating memory from the heap is sometimes generically known as *<<<consing>>>*.


If such memory were never freed, Lisp would run out of space for new objects and have to shut down. So the system must periodically search through the heap, looking for memory that is no longer needed. Memory that is no longer needed is called *<<<garbage>>>*, and the scavenging operation is called *<<<garbage collection>>>*, or *GC*.



Where does garbage come from? Let's create some:
#+begin_src lisp
CL-USER> (setf lst (list 'a 'b 'c))
(A B C)
CL-USER> (setf lst nil)
NIL  
#+end_src


Initially we call =list= , which calls =cons=, which allocates new cons cells on the heap. In this case we made three. After we set =lst= to =nil=, we no longer have any way of reaching the old value of =lst=, the list =(a b c)=.


Since we have no way of reaching this list, it might as well not exist. Objects that we no longer have any way of reaching are garbage. The system can safely reuse these three cons cells.



This way of managing memory is a great convenience to the programmer. You never have to allocate or deallocate memory explicitly. And this means that you never have to deal with the bugs that come from doing so. Memory leaks and dangling pointers are simply impossible in Lisp.


But, like any technical advance, automatic memory management can work against you are not careful. The costs associated with using and recycling heap space are sometimes refered to simply as the costs of consing. This is reasonable, because unless a program never throws anything away, most of those conses are going to end up as garbage sooner or later.


The trouble with consing is, allocating storage and scavenging memory to reclaim it can be expensive compared to the routine operations of a program. Recent research has produced greatly improved garbage collection algorithms, but consing will always cost something.


Consing is ok in prototypes and experiments, at least. And if you take advantage of the flexibility that lists give you in the early stages of a program, you're more likely to produce something that survives to the later stages.



* DONE Specialized Data Structures
:LOGBOOK:
- State "DONE"       from              [2024-02-20 Tue 09:58]
:END:
The preceding chapter discussed the list, Lisp's most versatile data structure. This chapter shows how to use Lisp's other data structures: arrays (including vectors and strings), structures, and hash tables. They may not be as flexible as lists, but they can make access faster, and take up less space.


** DONE Arrays
:LOGBOOK:
- State "DONE"       from              [2024-02-20 Tue 08:17]
:END:
In Common Lisp, you can make an *<<<array>>>* with =make-array= with a list of dimensions as the first argument. To make a $2\times 3$ array:
#+begin_src lisp
CL-USER> (setf arr (make-array '(2 3) :initial-element nil))
#2A((NIL NIL NIL) (NIL NIL NIL))  
CL-USER> (setf arr (make-array '(2 3)))
#2A((0 0 0) (0 0 0))
#+end_src

The =:initial-element= argument is optional. If it is provided, the whole array will be initialized to that value. 


To retrieve an array element we call =aref= (array ref). As usual for Common Lisp access functions, =aref= is zero-indexed:
#+begin_src lisp
CL-USER> (aref arr 0 0)
0  
#+end_src

To replace some element of an array, we use =setf= with =aref=:
#+begin_src lisp
CL-USER> (setf (aref arr 0 0) 'hello)
HELLO
CL-USER> (aref arr 0 0)
HELLO  
#+end_src


To denote a literal array, we use the =#na= syntax, where $n$ is the number of dimention in the array.
#+begin_src lisp
CL-USER> #2a((hello nil nil) (nil nil nil))
#2A((HELLO NIL NIL) (NIL NIL NIL))  
#+end_src


If the global =*print-array*= is =t=, array will be displayed in this form:
#+begin_src lisp
CL-USER> (setf arr (make-array '(2 3) :initial-element nil))
#2A((NIL NIL NIL) (NIL NIL NIL))
CL-USER> (setf *print-array* t)
T
CL-USER> arr
#2A((NIL NIL NIL) (NIL NIL NIL))  
#+end_src
Otherwise:
#+begin_src lisp
CL-USER> (setf *print-array* nil)
NIL
CL-USER> arr
#<(SIMPLE-ARRAY T (2 3)) {1001A60E0F}>  
#+end_src


If you want just a one-dimensional array, you can give an integer instead of a list as the first argument to =make-array=:
#+begin_src lisp
CL-USER> (setf vec (make-array 4 :initial-element nil))
#(NIL NIL NIL NIL)  
#+end_src



A one-dimensional array is also called a *<<<vector>>>*. You can create and fill one in a single step by calling =vector=, which will return a vector of whatever arguments you give it:
#+begin_src lisp
CL-USER> (vector "a" 'b 3)
#("a" B 3)
CL-USER> #("a" 'b 3)
#("a" 'B 3)
#+end_src


You can use =aref= for vector access, but there is a faster function called =svref= for use with vectors.
#+begin_src lisp
CL-USER> vec
#("a" B 3)
CL-USER> (aref vec 0)
"a"
CL-USER> (svref vec 0)
"a"  
#+end_src

The "sv" stands for "simple vector", which is what all vectors are by default. A simpel array is one that is neither adjustable, nor displaced, nor has a fill-pointer. Arrays are simple by default. A simple vector is a simple array of one dimention.

** DONE Strings and Characters
:LOGBOOK:
- State "DONE"       from              [2024-02-20 Tue 08:17]
:END:

*<<<Strings>>>* are vectors of *<<<characters>>>*. We denote a constant string as a series of characters surrounded by double-quotes, and an individual character =c= as =#\c=.

Each character has a ssociated integer - usually, but not necessarily, the ASCII number. In most implementations, the function =char-code= returns the number associated with a character, and =code-char= returns the character associated with a number.
#+begin_src lisp
CL-USER> (char-code #\a)
97
CL-USER> (code-char 97)
#\a  
#+end_src

The function =char<= (less than), =char<== (less than or equal), =char== (equal), =char>== (greater than or equal), =char>= (greater than), and =char/== (different) compare characters.

#+begin_src lisp
CL-USER> (sort "elbow" #'char<)
"below"  
#+end_src

Because strings are vectors, both sequence functions and array functions work on them. You could use =aref= to retrieve elements, for example:
#+begin_src lisp
  CL-USER> (aref "abc" 1)
  #\b
  CL-USER> (elt "abc" 1)
  #\b
#+end_src
but with string you can use the faster =char=:
#+begin_src lisp
CL-USER> (char "abc" 1)
#\b  
#+end_src


You can use =setf= with =char= (or =aref=) to replace elements:
#+begin_src lisp
CL-USER> (let ((str (copy-seq "Acheson")))
	   (setf (char str 3) #\i)
	   str)
"Achison"  
#+end_src


If you want to compare two strings, you can use the general =equal=, but there is also a function =string-equal= that ignores case:
#+begin_src lisp
CL-USER> (equal "ming" "ming")
T
CL-USER> (equal "ming" "Ming")
NIL
CL-USER> (string-equal "ming" "Ming")
T  
#+end_src


There are several ways of building strings. The most general is to use =format=. Calling =format= with =nil= as the first argument makes it return as a string what it would have printed:
#+begin_src lisp
CL-USER> (format nil "~A or ~A" "true" "false")
"true or false"  
#+end_src

But if you just want to join several strings together, you can use =concatenate=, which takes a symbol indicating the type of the result, plus one or more sequences:
#+begin_src lisp
CL-USER> (concatenate 'string "do " "not " "worry")
"do not worry"  
#+end_src




** DONE Sequences
:LOGBOOK:
- State "DONE"       from              [2024-02-20 Tue 08:17]
:END:
In Common Lisp the type =sequence= includes both lists and vectors (and therefore strings). Some of the functions that we have been using on lists are actually sequence functions, including =remove, length, subseq, reverse, sort, every=, and =some=.



We've already seen four functions for retrieving elements of sequences: =nth= for lists, =aref= and =svref= for vectors, and =char= for strings. Common Lisp also provides a function =elt= that works for sequences of any kind:
#+begin_src lisp
CL-USER> (elt '(a b c) 1)
B  
#+end_src
For sequences of specific types, the access functions we've already seen should be faster, so there is no point in using =elt= except in code that is supposed to work for sequences generally.


Many sequence functions take one or more keyword arguments from the standard set listed in this table:
| PARAMETER | PURPOSE                             | DEFAULT  |
| :key      | a function to apply to each element | identity |
| :test     | the test function for comparison    | eql      |
| :from-end | if true, work backwards             | nil      |
| :start    | postion at which to start           | 0        |
| :end      | position, if any, at which to stop  | nil      |




One function that takes the full set is =position=, which returns the position of an element in a sequence, or =nil= if it is not found.
#+begin_src lisp
CL-USER> (position #\a "fantasia")
1
CL-USER> (position #\a "fantasia" :start 3 :end 5)
4
CL-USER> (position #\a "fantasia" :from-end t)
7
CL-USER> (position 'a '((c d) (a b)) :key #'car)
1
CL-USER> (position '(a b) '((a b) (c d)))
NIL
CL-USER> (position '(a b) '((a b) (c d)) :test #'equal)
0
CL-USER> (position 3 '(1 0 7 5) :test #'<)
2
CL-USER> (position 3 '(1 0 7 5) :test #'>)
0  
#+end_src

To find an element satisfying a predicate of one argument, we use =position-if=. It takes a function and a sequence, and returns the position of the first element satisfying the function:
#+begin_src lisp
CL-USER> (position-if #'oddp '(2 3 4 5))
1
#+end_src
It takes all the keyword arguments except =:test=.

There are functions similar to =member= and =member-if= for sequences. They are, respectively, =find= (which takes all the keyword arguments) and =find-if= (which takes all except =:test=):
#+begin_src lisp
CL-USER> (find #\a "cat")
#\a
CL-USER> (find-if #'characterp "ham")
#\h  
#+end_src
Unlike =member= and =member-if=, they return only the object they were looking for.


The function =remove-duplicates= preserves only the last of each occurrence of any element of a sequence:
#+begin_src lisp
CL-USER> (remove-duplicates "abcdeabcd")
"eabcd"  
#+end_src
This function takes all the keyword arguments listed in the preceding table.


The function =reduce= is for boiling down a sequence into a single value. It takes at least two arguments, a function and a sequence. The function must be a function of two arguments. In the simplest case, it will be called initially with the first two elements, and thereafter with successive elements as the second argument, and the value it returned last time as the first. The value returned by the last call is returned as the value of the =reduce=.
#+begin_src lisp
CL-USER> (reduce #'intersection '((a b c d e) (c d e) (c d x y z)))
(C D)  
#+end_src



** DONE Structures
:LOGBOOK:
- State "DONE"       from              [2024-02-20 Tue 09:58]
:END:
A *<<<structure>>>* can be considered as a deluxe kind of vector. Suppose you have to write a program that kept track of a number of rectangular solids. You might consider representing then as vectors of three elements: height, width, and depth. Your program would be easier to read if, instead of using raw =svref=, you defined functions like
#+begin_src lisp
  (defun block-height (b) (svref b 0))
#+end_src
and so on. You can think of a structure as a vector in which all these kinds of functions get defined for you. Using filed name to replace the position in a vector.



To define a structure, we use =defstruct=. In the simplest case we just give the name of the structure and the name of the fields:
#+begin_src lisp
  (defstruct point
    x
    y)
#+end_src


This defines a =point= to be a structure with two fields, =x= and =y=. It also implicitly defined the functions =make-point=, =point-p=, =copy-point=, =point-x=, and =point-y=.

Lisp programs could write Lisp programs. This is one of the most conspicuous examples. When you call =defstruct=, it automatically writes code defining several other functions. With macros you will be able to do the same thing yourself.


Each call to =make-point= will reuturn a new =point=. We can specify the values of individual fields by giving the corresponding keyword arguments:

#+begin_src lisp
CL-USER> (defstruct point x y)
POINT
CL-USER> (setf p (make-point :x 0 :y 0))
#S(POINT :X 0 :Y 0)  
#+end_src

The access functions for =point= fields are defined not only to retrieve values, but to work with =setf=.
#+begin_src lisp
CL-USER> (point-x p)
0
CL-USER> (setf (point-y p) 2)
2
CL-USER> p
#S(POINT :X 0 :Y 2)  
#+end_src

Defining a structure also defines a type of that name. Each point will be of type =point=, then =structure=, then =atom=, then =t=.
#+begin_src lisp
CL-USER> (point-p p)
T
CL-USER> (typep p 'point)
T  
#+end_src


We can specify default values for structure fields by enclosing the field name and a default expression in alist in the original definition:
#+begin_src lisp
  (defstruct polemic
    ;; field: type. with default value read from input.
    (type (progn
	    (format t "What kind of polemic was it? ")
	    (read)))
    ;; field: effect. with default value nil.
    (effect nil))
#+end_src


If a call to =make-polemic= specifies no initial values for these fields, they will be set to the values of the corresponding expressions:
#+begin_src lisp
CL-USER> (make-polemic)
What kind of polemic was it? scathing
#S(POLEMIC :TYPE SCATHING :EFFECT NIL)  
#+end_src


We can also control things like the way a structure is displayed, and the prefix used in the name of the access functions it creates. Here is a more elaborate definition for =point= that does both:
#+begin_src lisp
  (defstruct (point (:conc-name p)
		    (:print-function print-point))
    (x 0)
    (y 0))

  (defun print-point (p stream depth)
    (format stream "#<~A,~A>" (px p) (py p)))
#+end_src

The =:conc-name= argument specifies what should be concatenated to the front of the field name to make access functions for them. By default it was =point-=; now it will be simply =p=. Not using the default makes you code a little less readable, so you would only want to do this kind of thing if you are goint to be using the acess functions constantly.

The =:print-function= is the name of the function that should be used to print a point when it has to be displayed - e.g. by the toplevel. This function must take three arguments: the structure to be printed, the place where it is to be printed, and a third argument that can usually be ignored.


The function =print-point= will display points in an abbreviated form:
#+begin_src lisp
CL-USER> (make-point)
#<0,0>  
#+end_src


** DONE Hash Tables
:LOGBOOK:
- State "DONE"       from              [2024-02-20 Tue 09:58]
:END:
Lists could be used to represent both sets and mappings. When either grow to a substantial size (say 10 elements) it will be faster to use *<<<hash tables>>>*. You can create a hash table by calling =make-hash-table=, which has no required arguments:
#+begin_src lisp
CL-USER> (setf ht (make-hash-table))
#<HASH-TABLE :TEST EQL :COUNT 0 {1003A5F6F3}>  
#+end_src


A hash table, like an assoc-list, is a way of associating pairs of objects. To retrieve the value associated with a given key, we call =gethash= with a key and a hash table. By default, =gethash= return =nil= when there is no value associated with the key.
#+begin_src lisp
CL-USER> (gethash 'color  ht)
NIL
NIL  
#+end_src

Here we see for the first time one of the distinctive features of Common Lisp: an expression can return multiple values. The function =gethash= returns two. The first is the value associated with the key, and the second says whether the hash table has any value stored under that key. Because the second value is =nil=, we know that the first =nil= was returned by default, not because =nil= was explicitly associated with =color=.


Most implementations will display all the return values of a call made at the toplevel, but code that expects only one return value will get just the first.


To associate a value with a key, we use =setf= with =gethash=:
#+begin_src lisp
CL-USER> (setf (gethash 'color ht) 'red)
RED
CL-USER> (gethash 'color ht)
RED
T
#+end_src


The second return value proves that now we're getting a real stored object and not just a default.


The objects stored in a hash table or used as keys can be any type.


You can use hash table instead of lists to represent sets. When the sets become large, lookups and deletions should be much faster with hash tables. To add a member to a set represented as a hash table, =setf= the =gethash= of it to =t=:
#+begin_src lisp
CL-USER> (setf fruit (make-hash-table))
#<HASH-TABLE :TEST EQL :COUNT 0 {1003D34283}>
CL-USER> (setf (gethash 'apricot fruit) t)
T
CL-USER>   
#+end_src

Then to test for membership you just call =gethash=:
#+begin_src lisp
CL-USER> (gethash 'apricot fruit)
T
T  
#+end_src


To remove an object from a set, you would call =remhash=, which removes an entry from a hash table:
#+begin_src lisp
CL-USER> (remhash 'apricot fruit)
T
#+end_src
The return value shows whether there was an entry to remove; in this case there was.




There is an iteration function for hash tables: =maphash=, which takes a function of two arguments and a hash table. The function will be called on every key/value pair in the table, in no particular order:
#+begin_src lisp
CL-USER> (setf (gethash 'shape ht) 'spherical
	       (gethash 'size ht) 'giant)
GIANT
CL-USER> (maphash #'(lambda (k v)
		      (format t "~A = ~A~%" k v))
		  ht)
COLOR = RED
SHAPE = SPHERICAL
SIZE = GIANT
NIL  
#+end_src



Hash tables can accommodate any number of elements, because they are expanded when they run out of space. If you want to ensure that a hash table starts with room for a particular number of elements, you can give the optional =:size= argument to =make-hash-table=. There are two reasons to do this: because you know the hash table is going to be huge, and you want to avoid expanding it; or because you know the hash table is going to be small, and you don't want to waste memory. The =:size= argument specifies not the number of spaces in the hash table, but the number of elements, on the average, it will be able to accommodate before being expanded. So
#+begin_src lisp
CL-USER> (make-hash-table :size 5)
#<HASH-TABLE :TEST EQL :COUNT 0 {10040B0633}>  
#+end_src
would return a hash table intended to hold up to five elements.

Like any structure involved in lookups, hash tables must have some notion of equality for keys. By default they use =eql=, but you can specify that a hash table should use =eq=, =equal=, or =equalp= instead by providing the optional =:test= argument:
#+begin_src lisp
CL-USER> (make-hash-table :test #'equal)
#<HASH-TABLE :TEST EQUAL :COUNT 0 {10042B07D3}>  
#+end_src


* DONE Control
:LOGBOOK:
- State "DONE"       from              [2024-02-22 Thu 07:39]
:END:
What the operators in this chapter have in common is that they all violate the evaluation rule. They let you direct the course that evaluation will take through the text of a program.


** DONE Blocks
:LOGBOOK:
- State "DONE"       from              [2024-02-21 Wed 08:15]
:END:
Common Lisp has three basic operators for creating *<<<blocks>>>* of code: =progn=, =block=, and =tagbody=.


The expressions within =progn= are evaluated in order and the value of the last is returned:
#+begin_src lisp
CL-USER> (progn
	   (format t "a")
	   (format t "b")
	   (+ 11 12))
ab
23  
#+end_src
Since only the value of the last expression is returned, the use of =progn= (or any block) implies side-effects.



A =block= is like =progn= with a name and an emergency exit. The first argument should be a symbol. This becomes the name of the block. At any point within the body, you can halt evaluation and return a value immediately by using =return-from= with the block name:
#+begin_src lisp
CL-USER> (block head
	   (format t "Here we go.")
	   (return-from head 'idea)
	   (format t "We'll never see this."))
Here we go.
IDEA  
#+end_src
Calling =return-from= allows your code to make a sudden but graceful exit from anywhere in a body of code. The second argument to =return-from= is returned as the value of the block named by the first. Expressions after the =return-from= are not evaluated.


There is also a =return= macro, which returns its argument as the value of an enclosing block named =nil=:
#+begin_src lisp
CL-USER> (block nil
	   (return 27))
27  
#+end_src

Many Common Lisp operators that take a body of expressions implicitly enclose the body in a block named =nil=. All iteration constructs do, for example:
#+begin_src lisp
CL-USER> (dolist (x '(a b c d e))
	   (format t "~A " x)
	   (if (eql x 'c)
	       (return 'done)))
A B C 
DONE  
#+end_src


The body of a function defined with =defun= is implicitly enclosed in a block with the same name as the function:
#+begin_src lisp
  (defun foo ()
    (return-from foo 27))
#+end_src
Outside of an explicit or implicit =block=, neither =return-from= nor =return= will work.

The third basic block construct is =tagbody=, within which you can use gotos. Atoms appearing in the body are interpreted as labels, giving such a label to go sends control to the expression following it. Here is an exceedingly ugly piece of code printing out the numbers from 1 to 10:
#+begin_src lisp
  (tagbody
     (setf x 0)
     top
     (setf x (+ x 1))
     (format t "~A " x)
     (if (< x 10)
	 (go top)))
#+end_src
This operator is mainly something that other operators are built upon, not something you would use yourself. Most iteration operators have an implicit =tagbogy=, so it's possible (thought rarely desirable) to use labels and =go= within their bodies.



How do you decide which block construct to use? Nearly all the time you'll use =progn=. If you want to allow for sudden exits, use =block= instead. Most programmers will never use =tagbody= explicitly.


** DONE Context
:LOGBOOK:
- State "DONE"       from              [2024-02-21 Wed 08:15]
:END:
Another operator to group expression is =let=. It takes a body of code, but also allows us to establish new variables for use within the body:
#+begin_src lisp
CL-USER> (let ((x 7)
	       (y 2))
	   (format t "Number")
	   (+ x y))
Number
9
#+end_src
An operator like =let= creates a new *<<<lexical context>>>*.  Within this context there are two new variables and variables from outer contexts may thereby become invisible.


Conceptually, a =let= expression is like a function call. The preceding =let= expression is exactly equivalent to:
#+begin_src lisp
  ((lambda (x y)
     (format t "Number")
     (+ x y))
   7 2)
#+end_src
Any questions you have about =let= should be dealt with by passing the buck to =lambda=, because entering a =let= is conceptually equivalent to doing a function call.


One of the thing this model makes clear is that the value of one =let= created variable can't depend on other variables create by the say =let=. For example, if we tried to say:
#+begin_src lisp
  (let ((x 2)
	(y (+ x 1)))
    (+ x y))
#+end_src
then the =x= in =(+ x 1)= would not be the =x= established in the previous line, because the whole expression is equivalent to
#+begin_src lisp
  ((lambda (x y)
     (+ x y))
   2
   (+ x 1))
#+end_src
Here it's obvious that =(+ x 1)= passed as an argument to the function cannot refer to the parameter =x= within the function.


So what if you do want the value of one new variable to depend on the value of another variable established by the same expression? In that case you would use a variant called =let*=:
#+begin_src lisp
CL-USER> (let* ((x 1)
		(y (+ x 1)))
	   (+ x y))
3  
#+end_src


A =let*= is functionally equivalent to a series of nested =lets=. This particular example is equivalent to:
#+begin_src lisp
  (let ((x 1))
    (let ((y (+ x 1)))
      (+ x y)))
#+end_src



In both =let= and =let*=, initial values default to =nil=. Such variables need not be enclosed within lists:
#+begin_src lisp
CL-USER> (let (x y)
	   (list x y))
(NIL NIL)  
#+end_src


The =destructuring-bind= macro is a generalization of =let=. Instead of single variables, it takes a pattern - one or more variables arranged in the form of a tree - and binds them to the corresponding parts of some actual tree. For example:
#+begin_src lisp
CL-USER> (destructuring-bind (w (x y) . z) '(a (b c) d e)
	   (list w x y z))
(A B C (D E))  
#+end_src
It causes an error if the tree given as the second argument doesn't match the pattern given as the first.


** DONE Conditionals
:LOGBOOK:
- State "DONE"       from              [2024-02-22 Thu 07:20]
:END:
The simplest conditional is =if=; all the others are built upon it. The simplest after =if= is =when=, which takes an expression and a body of code. The body will be evaluated if the test expression returns true.
#+begin_src lisp
  (when (oddp that)
    (format t "Hmm, that's good.")
    (+ that 1))
  ;; is equivalent to
  (if (oddp that)
      (progn
	(format t "Hmm, that's good.")
	(+ that 1)))
#+end_src

The opposite of =when= is =unless=, it takes the same arguments, but the body will be evaluated only if the test expression returns false.


The mother of all conditionals (in both senses) is =cond=, which brings two new advantages: it allows multiple conditions, and the code associated with each has an implicit =progn=. It's intended for use in situations where we would otherwise have to make the third argument of an =if= another =if=. For example, this pseudo member:
#+begin_src lisp
  (defun our-member (obj lst)
    (if (atom lst)
	nil
	(if (eql (car lst) obj)
	    lst
	    (our-member obj (cdr lst)))))
  ;; could also be defined as
  (defun our-member (obj lst)
    (cond ((atom lst) nil)
	  ((eql (car lst) obj) lst)
	  (t (our-member obj (cdr lst)))))
#+end_src
In fact, a Common Lisp implementation will probably implement =cond= by translating the latter into the former.



In general, =cond= takes zero or more arguments. Each one must be a list consisting of a condition followed by zero or more expressions. When the =cond= expression is evaluated, the conditions are evaluated in order until one of them returns true. When it does, the expressions associated with it are evaluated in order, and the value of the last is returned as the value of the =cond=. If there are no expressions after the successful condition, the value of the condition itself is returned.
#+begin_src lisp
CL-USER> (cond (99))
99  
#+end_src

Since a =cond= clause with a conditon of =t= will always succeed, it is conventional to make the final clause have =t= as the condition. If no clause succeeds, the =cond= returns =nil=, but it is usually bad style to take advantage of this return value.



When you want to compare a value against a series of constants, there is =case=. For example:
#+begin_src lisp
  (defun month-length (mon)
    (case mon
      ((jar mar may jul aug oct dec) 31)
      ((apr jun sept nov) 30)
      (feb (if (leap-year) 29 28))
      (otherwise "unkown moth")))
#+end_src
A =case= expression begins with an argument whose value will be compared against the keys in each clause. Then come zero or more clauses, each one beginning with either a key, or a list of keys, followed by zero or more expressions. The keys are treated as constants; they will not be evaluated. The value of the first argument is compared (using =eql=) to the key/s at the head of each clause. If there is a match, the expressions in the rest of that clause are evaluated, and the value of the last is returned as the value of the case.
#+begin_src lisp
CL-USER> (month-length 'jar)
31
CL-USER> (month-length 'september)
"unkown moth"  
#+end_src


The default clause may have the key =t= or =otherwise=. If no clause succeeds, or the successful clause contains only keys, then the case returns =nil=.
#+begin_src lisp
CL-USER> (case 99 (99))
NIL
#+end_src

The =typecase= macro is similar to case, except that the keys in each clause should be type specifiers, and the value of the first argument is compared to the keys using =typep= instead of =eql=.
#+begin_src lisp
CL-USER> (typecase 1
           (number t))
T  
#+end_src

** DONE Iteration
:LOGBOOK:
- State "DONE"       from              [2024-02-22 Thu 07:20]
:END:

The basic iteration operator is =do=. Since =do= contains both an implicit =block= and an implicit =tagbody=, it's possible to use =return=, =return-from=, and =go= within the body of a =do=.

The first argument to =do= had to be a list of specifications for variables, each possibly of the form
#+begin_src lisp
  (variable initial update)
#+end_src
The =initial= and =update= forms are optional. If the =update= form is omitted, the variable won't update on successive iterations. If the =initial= form is also omitted, the variable will be initially =nil=.




When more than one variable is to be updated, the question arises, if an =update= form refers to a variable that has its own =update= form, does it get the updated value or the value from the previous iteration? With =do=, it gets the latter:
#+begin_src lisp
CL-USER> (let ((x 'a))
	   (do ((x 1 (+ x 1))
		(y x x))
	       ((> x 5))
	     (format t "(~A ~A)  " x y)))
(1 A)  (2 1)  (3 2)  (4 3)  (5 4)  
NIL  
#+end_src
On each iteration, =x= gets its previous value plus 1; =y= also get the *previous* value of =x=.


There is also a =do*=, which has the same relation to =do= as =let*= does to =let=. Any =initial= or =update= form can refer to a variable from a previous clause, and it will get the current value:
#+begin_src lisp
CL-USER> (do* ((x 1 (+ x 1))
	       (y x x))
	      ((> x 5))
	   (format t "(~A ~A)  " x y))
(1 1)  (2 2)  (3 3)  (4 4)  (5 5)  
NIL  
#+end_src

Besides =do= and =do*= there are several special-purpose iteration operators. To iterate over the elements of a list, we can use =dolist=:
#+begin_src lisp
CL-USER> (dolist (x '(a b c d) 'done)
	   (format t "~A " x))
A B C D 
DONE  
#+end_src
The third expression within the initial list will be evaluated and returned as the value of the =dolist= when iteration terminates. It defaults to =nil=.


Similar in spirit is =dotimes=, which for some =n= iterates over the integers from =O= to =n-1=:
#+begin_src lisp
CL-USER> (dotimes (x 5 x)
	   (format t "~A " x))
0 1 2 3 4 
5  
#+end_src
As with =dolist=, the third expression in the initial list is optional and defaults to =nil=. Notice that it can refer to the iteration variable.



The function =mapc= is like =mapcar= but does not cons up a new list a return value, so the only reason to use it is for side-effects. Like =mapcar=, It is also more flexible than =dolist=, because it can traverse multiple lists in parallel:
#+begin_src lisp
CL-USER> (mapc #' (lambda (x y)
		    (format t "~A ~A  " x y))
		  '(hip flip slip)
		  '(hop flop slop))
HIP HOP  FLIP FLOP  SLIP SLOP  
(HIP FLIP SLIP)  
#+end_src
It always returns its second argument.


** DONE Multiple Values
:LOGBOOK:
- State "DONE"       from              [2024-02-22 Thu 07:39]
:END:
In Common Lisp, an expression can return zero or more values. *<<<Multiple values>>>* allow a function that calculates several things to return them without having to build a structure to contain them all. For example, the built-in =get-decoded-time= returns the current time in nine values: seconds, minutes, hours, day, month, year, day of the week, daylight savings time flag and time zone.

#+begin_src lisp
CL-USER> (get-decoded-time)
44
50
16
5
2
2024
0
NIL
5  
#+end_src

Multiple values also make it possible to have lookup functions that can distinguish between finding =nil= and failing to find something. This is why =gethash= returns two values. Because it uses the second value to indicate success or failure, we can store =nil= in a hash table just like any other value.
#+begin_src lisp
CL-USER> (let ((ht (make-hash-table)))
	   (gethash 'color ht))
NIL
NIL
CL-USER> (let ((ht (make-hash-table)))
	   (setf (gethash 'color ht) nil)
	   (gethash 'color ht))
NIL
T  
#+end_src

The =values= function returns multiple values. It returns exactly the values you give it as arguments:
#+begin_src lisp
CL-USER> (values 'a nil (+ 1 2))
A
NIL
3  
#+end_src




If a =values= expression is the last thing to be evaluated in the body of a function, its return values become those of the function. Multiple values are passed on intact through any number of returns:
#+begin_src lisp
CL-USER> ((lambda ()
	    ((lambda ()
	       (values 1 2)))))
1
2
#+end_src


However, if something is expecting only one value, all but the first will be discarded:
#+begin_src lisp
CL-USER> (let ((x (values 1 2)))
	   x)
1  
#+end_src
By using =values= with no arguments, it's possible to return no values. In that case, something expecting one will get =nil=:
#+begin_src lisp
CL-USER> (values)
; No value
CL-USER> (let ((x (values)))
	   x)
NIL  
#+end_src



To receive multiple values, we use =multiple-value-bind=:
#+begin_src lisp
CL-USER> (multiple-value-bind (x y z) (values 1 2 3)
	   (list x y z))
(1 2 3)
CL-USER> (multiple-value-bind (x y z) (values 1 2)
	   (list x y z))
(1 2 NIL)
CL-USER> (multiple-value-bind (x y z) (values 1 2 3 4)
	   (list x y z))
(1 2 3)  
#+end_src
If there are more variables than values, the leftover ones will be =nil=. If there are more values than variables, the extra values will be discarded.



You can pass on multiple values as the arguments to a second function using =multiple-value-call=:
#+begin_src lisp
CL-USER> (multiple-value-call #'+ (values 1 2 3))
6  
#+end_src

There is also a function =multiple-value-list=:
#+begin_src lisp
CL-USER> (multiple-value-list (values 1 2 3))
(1 2 3)
#+end_src
which is like using =multiple-value-call= with =#'list= as the first argument.




** DONE Aborts
:LOGBOOK:
- State "DONE"       from              [2024-02-22 Thu 07:39]
:END:
You can use =return= to exit from a =block= at any point. Sometimes we want to do something even more drastic, and transfer control back through several function calls. To do this we use =catch= and =throw=. A =catch= expression takes a tag, which can be any kind of object, followed by a body of expressions.
#+begin_src lisp
  (defun super ()
    (catch 'abort
      (sub)
      (format t "We'll never see this.")))

  (defun sub ()
    (throw 'abort 99))
#+end_src
The expressions are evaluated in order, as if in a =progn=. At any point within this code or code called by it, a =throw= with the corresponding tag will cause the catch expression to return immediately:
#+begin_src lisp
CL-USER> (super)
99
#+end_src
A =throw= with a given tag will pass control through (and thereby kill) any catches with other tags in order to reach the one with the matching tag. If there is no pending =catch= with the right tag, the =throw= causes an error.


Calling =error= also interrupts execution, but instead of transferring control to another point higher up in the calling tree, it transfers control to the Lisp error handler.



Sometimes you want code to be proof against interruptions like =throws= and =errors=. By using an =unwind-protect=, you can ensure that such interruptions won't leave your program in an inconsistent state. An =unwind-protect= takes any number of arguments and returns the value of the first. However, the remaining expressions will be evaluated even if the evaluation of the first is interrupted.
#+begin_src lisp
CL-USER> (setf x 1)
1
CL-USER> (catch 'abort
	   (unwind-protect
		(throw 'abort 99)
	     (setf x 2)))
99
CL-USER> x
2  
#+end_src
Here, even though the =throw= sends control back to the waiting =catch=, =unwind-protect= ensures that the second expression gets evaluated on the way out. Whenever certain actions have to be followed by some kind of cleanup or reset, =unwind-protect= may be useful. 



* DONE Functions
:LOGBOOK:
- State "DONE"       from              [2024-02-26 Mon 07:52]
:END:

** DONE Global Functions
:LOGBOOK:
- State "DONE"       from              [2024-02-24 Sat 07:59]
:END:

The predicate =fboundp= tells whether there is a function with a given symbol as its name. If a symbol is the name of a function, =symbol-function= will return it:
#+begin_src lisp
CL-USER> (fboundp '+)
#<FUNCTION +>
CL-USER> (symbol-function '+)
#<FUNCTION +>  
#+end_src


By setting the =symbol-function= of some name to a function,
#+begin_src lisp
  (setf (symbol-function 'add2)
	#'(lambda (x) (+ x 2)))
#+end_src
we thereby define a new global function, which we can use as if we had defined it with =defun=.
#+begin_src lisp
CL-USER> (add2 1)
3  
#+end_src

In fact, =defun= does little more than translate something like
#+begin_src lisp
  (defun add2 (x) (+ x 2))
#+end_src
into the =setf= expression above. Using =defun= makes programs look nicer, and may help the compiler, but strictly speaking you don't need it to write programs.



By making the first argument to =defun= a list of the form =(setf f)=, you define what happens when the first argument to =setf= is a call to =f=.
#+begin_src lisp
;; define primo as a synonym for `car`
CL-USER> (defun primo (lst)
	   (car lst))
PRIMO
CL-USER> (primo '(a b c))
A
CL-USER> (defun (setf primo) (val lst)
	   (setf (car lst) val))
(SETF PRIMO)
CL-USER> (let ((x (list 'a 'b 'c)))
	   (setf (primo x) 480)
	   x)
(480 B C)

;; This show that you define what happens when the first
;; argument to `setf` is a call to `f`.
CL-USER> (defun mytest (lst) (car lst))
MYTEST
CL-USER> (defun (setf mytest) (val lst)
	   (setf (car lst) (list val val)))
(SETF MYTEST)
CL-USER> (mytest '(a b c))
A
CL-USER> (let ((x (list 'a 'b 'c)))
	   (setf (mytest x) 480)
	   x)
((480 480) B C)  
#+end_src
In the definition of a function whose name is of the form =(setf f)=, the first parameter represents the new value, and the remaining parameters represent arguments to =f=.


It's not necessary to define =primo= in order to define =(setf primo)=, but such definitions usually come in pairs.



Since strings are Lisp expressions, there is no reason they can't appear within bodies of code. A string by it self does not have side-effects, and so doesn't make any difference unless it's the last expression. If you make a string the first expression in the body of a function defined with =defun=,
#+begin_src lisp
  (defun foo (x)
    "I am document string."
    x)
#+end_src
then that string will become the function's <<<documentation string>>>. The documentation for a globally defined function can be retrieved by calling =documentation=:
#+begin_src lisp
;; (documentation obj doc-type)
CL-USER> (documentation 'foo 'function)
"I am document string."  
#+end_src

** DONE Local Functions
:LOGBOOK:
- State "DONE"       from              [2024-02-24 Sat 08:03]
:END:
Functions defined via =defun= or =setf= of =symbol-function= are *<<<global functions>>>*. Like global variables you have access to them anywhere. It is also possible to define local functions, which like local variables, are only accessible within a certain context.

*<<<Local functions>>>* can be defined with =labels=, which is a kind of =let= for functions. Its first argument is a list of definitions of new local functions. Each element of the list is of the form
#+begin_src lisp
  (name parameters . body)
#+end_src
Within the ramainder of the =labels= expression, calling /name/ is equivalent to calling =(lambda parameters . body)=.
#+begin_src lisp
CL-USER> (labels ((add10 (x) (+ x 10))
		  (consa (x) (cons 'a x)))
	   (consa (add10 3)))
(A . 13)  
#+end_src

The analogy to =let= breaks down in one respect. Local functions defined by a =labels= expression can refer to any other functions defined there, including themselves. So it's possible to define recursive local functions this way:
#+begin_src lisp
CL-USER> (labels ((len (lst)
		    (if (null lst)
			0
			(+ (len (cdr lst)) 1))))
	   (len '(a b c)))
3  
#+end_src


** DONE Parameter Lists
:LOGBOOK:
- State "DONE"       from              [2024-02-24 Sat 08:11]
:END:
With prefix notation, =+= could take any number of arguments. To write such functions, we need to use something called a *<<<rest parameter>>>*.


If we insert the token =&rest= before the last variable in the parameter list of function, then when the function is called, this variable will be set to a list of all the remaining arguments. Now we can see how =funcall= would be written in terms of =apply=. It might be defined as:
#+begin_src lisp
  (defun our-funcall (fn &rest args)
    (apply fn args))
#+end_src



Arguments could be omitted and would default to certain values. Such parameters are called *<<<optional parameters>>>*. By contract, ordinary parameters are sometime called *<<<required parameters>>>*. If the symbol =&optinal= occurs in the parameter list of a function, then all the arguments after it are optional and default to =nil=:
#+begin_src lisp
CL-USER> (defun say (hello &optional name)
	   (list hello name))
SAY
CL-USER> (say 'hello)
(HELLO NIL)
#+end_src


We give an explicit default by enclosing it in a list with the parameters.
#+begin_src lisp
CL-USER> (defun say (hello &optional (name 'world))
	   (list hello name))
SAY
CL-USER> (say 'hello)
(HELLO WORLD)  
#+end_src

The default for an optional parameter need not be a constant. It can be any Lisp expression. If this expression isn't a constant, it will be evaluated anew each time a default is needed.



A *<<<keyword parameter>>>* is a more flexible kind of optional parameter. If you put the symbol =&key= in a parameter list, then all the parameters after it are optional. Moreover, when the function is called, these parameters will be identified not by their position, but by symbolic tags that precede them:
#+begin_src lisp
CL-USER> (defun keylist (a &key x y (z 40))
	   (list a x y z))
KEYLIST
CL-USER> (keylist 1 :y 2)
(1 NIL 2 40)
CL-USER> (keylist 1 :y 3 :x 2)
(1 2 3 40)  
#+end_src


Keywords and their associated arguments can be collected in rest parameters and passed on to other functions that are expecting them. For example, we could define =adjoin= as:
#+begin_src lisp
  (defun our-adjoin (obj lst &rest args)
    (if (apply #'member obj lst args)
	lst
	(cons obj lst)))
#+end_src
Since =adjoin= takes the same keyword arguments as =member=, we just collect them in a rest argument and pass them on to =member=.


Section [[*Context]] introduced the =destructuring-bind= macro. In the general case, each subtree in the pattern given as the first argument may be as complex as the parameter list of a function:
#+begin_src lisp
CL-USER> (destructuring-bind ((&key w x) &rest y) '((:w 3) a)
	   (list w x y))
(3 NIL (A))
CL-USER> (destructuring-bind ((&key w x) &rest y) '((:w 3 :x 4) a b c d )
	   (list w x y))
(3 4 (A B C D))
#+end_src



** DONE Utilities
:LOGBOOK:
- State "DONE"       from              [2024-02-25 Sun 07:43]
:END:

Lisp consists mostly of Lisp functions, just like the ones you can define yourself. This is a useful feature to have in a programming language: you don't have to modify your ideas to suit the language, because you can modify the language to suit your ideas. If you find yourself wishing that Common Lisp included a certain function, you can write it yourself, and it will be just as much a part of the language as =+= or =eql=.


Experienced Lisp programmers work bottom-up as well as top-down. While they're writing their program down toward the language, they also build the language up toward their program. This way, language and program meet sooner, and more neatly.


Operators written to augment Lisp are called *<<<utilities>>>*. As you write more Lisp programs, you will find that you develop a collection of them, and that many of the utilities you write during one project will turn out to be useful in the next one.



Professional programmers often find that the program they're working on now has a great deal in common with some program they wrote in the past. It is this feeling that makes the idea of software reuse so attractive. Somehow reuse has become associated with object-oriented programming. But software does not have to be object-oriented to be reusable — this is obvious when we look at programming languages (that is, compilers), which are the most reusable software of all.


The way to get reusable software is to write programs bottom-up, and programs don't have to be object-oriented to be written bottom-up. In fact, the functional style seems even better adapted for writing reusable software. Consider =sort=. You are unlikely ever to have to write your own sort routines in Common Lisp; =sort= is so fast and so general that it would not be worth the trouble. That's reusable software.


You can do the same thing in your own programs by writing utilities.

#+begin_src lisp
(defun single? (lst)
  "Returns true when its argument is
is a list of one element."
  (and (consp lst) (null (cdr lst))))

(defun append1 (lst obj)
  "Adds an element to the end of the
list."
  (append lst (list obj)))

(defun map-int (fn n)
  "Takes a function and an integer n,
and returns a list of the results of
calling the function on the integers
from 0 to n-1."
  (let ((acc nil))
    (dotimes (i n)
      (push (funcall fn i) acc))
    ;; nreverse do the same thing as
    ;; reverse, but is more efficient.
    (nreverse acc)))

(defun filter (fn lst)
  "Takes a function and a list, and
return all the non-nil values returned
by the function as it is applied to the
elements of the list."
  (let ((acc nil))
    (dolist (x lst)
      (let ((val (funcall fn x)))
	(if val
	    (push val acc))))
    (nreverse acc)))


(defun most (fn lst)
  "Returns the element of a list with
the highest score according to some
scoring function. It returns two values,
the winning element and its score."
  (if (null lst)
      (values nil nil)
      (let* ((wins (car lst))
	     (max (funcall fn wins)))
	(dolist (obj (cdr lst))
	  (let ((score (funcall fn obj)))
	    (when (> score max)
	      (setf wins obj
		    max score))))
	(values wins max))))


  
#+end_src

The usage of the above utilities is as follows:
#+begin_src lisp
CL-USER> (single? '(a))
T
CL-USER> (single? '())
NIL
CL-USER> (single? '(a b))
NIL
CL-USER> (append1 '(a b c) 'd)
(A B C D)
CL-USER> (map-int #'identity 10)
(0 1 2 3 4 5 6 7 8 9)
CL-USER> (map-int #'(lambda (x) (* x x)) 10)
(0 1 4 9 16 25 36 49 64 81)
CL-USER> (map-int #'(lambda (x) (random 100)) 10)
(92 44 95 5 97 58 43 99 37 68)
CL-USER> (filter #'(lambda (x)
		     (and (evenp x) (+ x 10)))
		 '(1 2 3 4 5 6 7))
(12 14 16)
CL-USER> (most #'length '((a b) (a b c) (a)))
(A B C)
3  
#+end_src


The last three functions all take functions as arguments. Lisp makes it convenient to pass functions as arguments, and that's one of the reasons it is so well suited to bottom-up programming. A successful utility must be general, and it's easier to abstract out the general when you can pass the specific as a functional argument.



** DONE Closures                                                  :important:
:LOGBOOK:
- State "DONE"       from              [2024-02-25 Sun 07:53]
:END:
A function can be returned as the value of an expression just like any other kind of object. Here is a function that takes one argument and return a function to combine arguments of that type:
#+begin_src lisp
  (defun combiner (x)
    (typecase x
      (number #'+)
      (list #'append)
      (t #'list)))
#+end_src

On top of this we can build a general combination function
#+begin_src lisp
  (defun combine (&rest args)
    (apply (combiner (car args))
	   args))
#+end_src
which takes arguments of any type and combines them in a way appropriate to their type. To simplify the example, we assume that the arguments will all be of the same type.
#+begin_src lisp
CL-USER> (combine 2 3)
5
CL-USER> (combine '(a b) '(c d))
(A B C D)
CL-USER> (combine "hello" "world")
("hello" "world")  
#+end_src


<<<Lexical variable>>> are only valid within the context where they are defined. Along with this restriction comes the promise that they will continue to be valid for as long as something is using the context.


If a function is defined within the scope of a lexical variable, it can continue to refer to that variable, even if it is returned as a value outside the context where the variable was created. Here we create a function that adds 3 to its argument:
#+begin_src lisp
CL-USER> (setf fn (let ((i 3))
		    #'(lambda (x) (+ x i))))
#<FUNCTION (LAMBDA (X)) {54A3E49B}>
CL-USER> (funcall fn 2)
5  
#+end_src
When a function refers to a variable defined outside it, it's called a *<<<free variable>>>*. A function that refers to a free lexical variable is called a *<<<closure>>>*. The variable must persist as long as the function does.

A closure is a combination of a function and an environment. Closures are created implicitly whenever a function refers to something from the surrounding lexical environment.  This happens quietly in a function like the following one, but it is the same idea:
#+begin_src lisp
  (defun add-to-list (num lst)
    (mapcar #'(lambda (x)
		(+ x num))
	    lst))
#+end_src
This function takes a number and a list, and returns a list of the sum of each element and the number. The variable =num= within the lambda expression is free, so in cases like this we're passing a closure to =mapcar=.



A more conspicuous example would be a function that returned a different closure each time it was called. The following function returns an adder:
#+begin_src lisp
  (defun make-adder (n)
    #'(lambda (x)
	     (+ x n)))
#+end_src
It takes a number, and returns a function that adds that number to its argument:
#+begin_src lisp
CL-USER> (setf add3 (make-adder 3))
#<FUNCTION (LAMBDA (X) :IN MAKE-ADDER) {10026F8FEB}>
CL-USER> (funcall add3 2)
5
CL-USER> (setf add27 (make-adder 27))
#<FUNCTION (LAMBDA (X) :IN MAKE-ADDER) {100274B84B}>
CL-USER> (funcall add27 2)
29  
#+end_src



We can even make several closures share variables. Here we define two functions that share a counter.
#+begin_src lisp
  (let ((counter 0))
    (defun our-reset ()
      (setf counter 0))
    (defun our-stamp ()
      (setf counter (+ counter 1))))
#+end_src

Such a pair of functions might be used to create time-stamps. Each time we call =our-stamp= we get a number one higher than the previous, and by calling =our-reset= we can set the counter back to zero:
#+begin_src lisp
CL-USER> (list (our-stamp) (our-stamp) (our-reset) (our-stamp))
(1 2 0 1)  
#+end_src
You could do the same thing with a global counter, but this way the counter is protected from unintended references.



Common Lisp has a built-in function =complement= that takes a predicate and returns the opposite predicate. For example:
#+begin_src lisp
CL-USER> (mapcar (complement #'oddp)
		 '(1 2 3 4 5 6))
(NIL T NIL T NIL T)  
#+end_src
With closures such a function is easy to write:
#+begin_src lisp
  (defun our-complement (f)
    #'(lambda (&rest args)
	(not (apply f args))))
#+end_src


Closures are one of the uniquely wonderful things about Lisp. They open the door to programming techniques that would be inconceivable in other languages.





** DONE Dynamic Scope
:LOGBOOK:
- State "DONE"       from              [2024-02-25 Sun 08:02]
:END:

Section [[*Variables]] distinguished between local and global variables. The real distinction here is between lexical variables, which have <<<lexical scope>>>, and special variables, which have <<<dynamic scope>>>. But it's almost the same distinction, because local variables are nearly always lexical variables, and global variables are always special variables.

Under lexical scope, a symbol refers to the variable that has the name in the context where the symbol appears. Local variables have lexical scope by default. So if we define a function in an environment where there is a variable called =x=:
#+begin_src lisp
  (let ((x 10))
    (defun foo ()
      x))
#+end_src
then the =x= in the body will refer to that variable, regardless of any =x= that might exist where =foo= is called:
#+begin_src lisp
CL-USER> (let ((x 20))
	   (foo))
10
#+end_src






With dynamic scope, we look for a variable in the environment where the function is called, not in the environment where it was defined. To cause a variable to have dynamic scope, we must declare it to be =special= in any context where it occurs. If we defined =foo= instead as
#+begin_src lisp
  (let ((x 10))
    (defun foo ()
      (declare (special x))
      x))
#+end_src
then the =x= within the function will no longer refer to the lexical variable existing where the function was defined, but will refer to whatever speical =x= exists at the time the function is called:
#+begin_src lisp
CL-USER> (let ((x 20))
	   (declare (special x))
	   (foo))
20  
#+end_src
A =declare= can begin any body of code where new variables are created. The =special= declaration is unique, in that it can change the way a program behaves.


Global variables established by calling =setf= at the toplevel are implicitly special:
#+begin_src lisp
CL-USER> (setf x 30)
30
CL-USER> (foo)
30  
#+end_src
Within a file of code, it makes a program clearer if you don't rely on the implicit special declaration, and instead use =defparameter=.




Where is dynamic scope useful? Usually it is used to give some global variable a new value temporarily. For example, there are 11 global variables that control the way objects are printed, including *print-base*. If you want to display numbers in hexadecimal (base 16), you can do it by rebinding *print-base*:
#+begin_src lisp
CL-USER> (let ((*print-base* 16))
	   (princ 32))
20
32  
#+end_src
Two things are displayed here: the output generated by =princ=, and the value it returns. They represent the same number, displayed first in hexadecimal because =*print-base*= was 16 when it was printed, and the second time in decimal because, outside the let expression, =*print-base*= reverts to its previous value, 10.


#+begin_src lisp
CL-USER> (defparameter *ourglobal* 10)
*OURGLOBAL*
CL-USER> *ourglobal*
10
CL-USER> (let ((*ourglobal* 20))
	   *ourglobal*)
20
#+end_src



** DONE Compilation
:LOGBOOK:
- State "DONE"       from              [2024-02-25 Sun 08:26]
:END:
Compilations make the evaluation of expressions faster.

Common Lisp functions can be compiled either individually or by file. You can check whether a function is compiled by passing it to =compiled-function-p=:
#+begin_src lisp
CL-USER> (defun foo (x)
	   (+ x 1))
FOO
CL-USER> (compiled-function-p #'foo)
T  
#+end_src

You can also give the name of =foo= to =compile= to compile a function.
#+begin_src lisp
  (compile 'foo)
#+end_src



The usual way to compile Lisp code is not to compile functions individually, but to compile whole files with =compile-file=. This function takes a filename and creates a compiled version of the source file — typically with the same base name but a different extension. When the compiled file is loaded, =compiled-function-p= should return true for all the functions defined in the file.




When one function occurs within another, and the containing function is compiled, the inner function should also be compiled. So when =make-adder= is compiled, it will return compiled functions:
#+begin_src lisp
  (defun make-adder (n)
    #'(lambda (x)
	(+ x n)))  
#+end_src

#+begin_src lisp
CL-USER> (compile 'make-adder)
MAKE-ADDER
NIL
NIL
CL-USER> (compiled-function-p (make-adder 2))
T  
#+end_src




** DONE Using Recursion
:LOGBOOK:
- State "DONE"       from              [2024-02-26 Mon 07:52]
:END:
Recursion plays a greater role in Lisp than in most other languages. There seem to be three main reasons why:
1. Functional programming. Recursive algorithms are less likely to involve side-effects.
2. Recursive data structure. Lisp's implicit use of pointers makes it easy to have recursively defined data structures. The most common is the list: a list is either =nil=, or a cons whose cdr is a list.
3. Elegance. Lisp programmers care a great deal about the beauty of their programs, and recursive algorithms are often more elegant than their iterative counterparts.


[[*Understanding Recursion]] pointed out, you don't have to think about all the invocations of a recursive function if you want to judge whether or not is correct. The same is true if you want to write a recursive function. If you can describe a recursive solution to a problem, it's usually straightforward to translate your solution into code. To solve a problem using recursion, you have to do two things:
1. You have to show how to solve the problem in the general case by breaking it down into a finite number of similar, but smaller, problems.
2. You have to show how to solve the smallest version of the problem — the base case — by some finite number of operations.

If you can do this, you're done. You know that a finite problem will get solved eventually, because each recursion makes it smaller, and the smallest problem takes a finite number of steps.

Some algorithms are most naturally expressed in recursion and some are not (which means most natually in iteration). Sometimes it may not be obvious which form will be more natural until you try to write the code.


If you're concerned with efficiency, there are two more issues to consider.
1. Tail-recursion.
2. The obvious recursive algorithm is not always the most efficient.


The classic example is the Fibonacci function. It is defined recursively,
1. $\text{Fib}(0) = \text{Fib(1) = 1}$
2. $\text{Fib}(n) = \text{Fib}(n-1) + \text{Fib}(n-2)$


but the literal translation of this definition,
#+begin_src lisp
  (defun fib (n)
    (if (<= n 1)
	1
	(+ (fib (- n 1))
	   (fib (- n 2)))))
#+end_src
is appalliying inefficient. The same computations are done over and over. If you ask for =(fib 10)=, the function computes =(fib 9)= and =(fib 8)=. But to compute =(fib 9)=, it has to compute =(fib 8)= again, and so on.


How often does this kind of thing happen in practice? Very rarely — that's why all textbooks use the same example — but it is something one should be aware of.


* DONE Input and Output
:LOGBOOK:
- State "DONE"       from              [2024-02-29 Thu 11:38]
:END:


Common Lisp has powerful I/O facilities. For input, along with the usual functions for reading characters, we get =read=, which includes a complete parser. For output, along with the usual functions for writing characters, we get =format=, which is almost a language in its own right. This chapter introduces all the basic concepts.

There are two kinds of streams, character streams and binary streams. 


** DONE Character Streams
:LOGBOOK:
- State "DONE"       from              [2024-02-26 Mon 09:01]
:END:

*<<<Character streams>>>* are Lisp objects representing sources and/or destinations of characters. To read from or write to a file, you open it as a stream. But streams are not identical with files. When you read or print at the toplevel, you also use a stream. You can even create streams that read from or write to strings.

By default, input is read from the stream =*standard-input*=. The default place for output is =*standard-output*=. Initially they will probably be the same place: a stream representing the toplevel.



Already we have seen =read= and =format= used to read from and print to the toplevel. The former takes an optional argument, which should be a stream, and defaults to =*standard-input*=. The first argument to =format= can also be a stream, but when it is =t=, the output is sent to =*standard-output*=. So what we have been doing so far is using the defaults. We could do the same I/O operations on any stream.


A <<<pathname>>> is a portable way of specifying a file. A pathname has six components: host, device, directory, name, type, and version. You can make one by calling =make-pathname= with one or more of the corresponding keyword arguments. In the simplest case, you could just specify the name and let the rest of the pathname default:
#+begin_src lisp
CL-USER> (setf path (make-pathname :name "myfile"))
#P"myfile"  
#+end_src



The basic function for opening a file is =open=. It takes a pathname (You can give a string instead of a pathname, but this is not portable.) and a large number of optional keyword arguments, and if successful, returns a stream that points to the file.

You specify how you intend to use a stream when you create it. The =:direction= argument signals whether you are going to write to the stream, read from it, or both. The three corresponding values are =:input=, =:output=, and =:io=. If thestream is used for output,the =:if-exists= argument says what to do if the destination file already exists; usually it should be =:supersede=. So to create a stream on which you can write to the file "myfile", you might say:
#+begin_src lisp
CL-USER> (setf str (open path :direction :output
			      :if-exists :supersede))
#<SB-SYS:FD-STREAM for "file /Users/mingmingli/info/information-technology/programming-languages/common-lisp/myfile" {1004512DC3}>  
#+end_src
The printed representation of streams is implementation-dependent.



Now if we give this stream as the first argument to =format=, it will print to the stream instead of the toplevel:
#+begin_src lisp
CL-USER> (format str "Something~%")
NIL
#+end_src
If we look at the file at this point, the output may or may not be there. Some implementations save up output to write in chunks (SBCL). It may not all appear until we close the stream:
#+begin_src lisp
CL-USER> (close str)
T  
#+end_src
Always close a file when you finished using it; nothing is guaranteed about its contents until you do.




If we just want to read from a file, we open a stream with =:direction :input=:
#+begin_src lisp
CL-USER> (setf str (open path :direction :input))
#<SB-SYS:FD-STREAM for "file /Users/mingmingli/info/information-technology/programming-languages/common-lisp/myfile" {100188CCC3}>
CL-USER> (read-line str)
"Something"
NIL
CL-USER> (close str)
T
CL-USER>   
#+end_src


Much of the time one does not use =open= and =close= directly to do file I/O. The =with-open-file= macro is often more convenient. Its first argument should be a list containing a variable name followed by arguments you might give to =open=. After this it takes a body of code, which is evaluated with the variable bound to a stream created by passing the remaining arguments to =open=. Afterward the stream is automatically closed. So our entire file-writing operation could be expressed:
#+begin_src lisp
CL-USER> (with-open-file (str path :direction :output 
				   :if-exists :supersede)
	   (format str "Something~%"))
NIL  
#+end_src


The =with-open-file= macro puts the close within an =unwind-protect=, so the file is guaranteed to get closed, even if an error interrupts the evaluation of the body.




** DONE Input
:LOGBOOK:
- State "DONE"       from              [2024-02-29 Thu 08:44]
:END:
The two most popular input functions are =read-line= and =read=.


=read-line= reads all the characters up to a newline, returning them in a string. It takes an optional stream argument; if the stream is omitted, it will default to =*standard-input*=:
#+begin_src lisp
CL-USER> (progn
	   (format t "Plase enter your name: ")
	   (read-line))
Plase enter your name: Mingming Li
"Mingming Li"
NIL  
#+end_src
This is the function to use if you want verbatim input. The second return value is true only if =read-line= ran out of input before encountering a newline.



In the general case, =read-line= takes four optional arguments:
1. a stream;
2. an argument to tell whether or not to cause an error on encountering end-of-file;
3. what to return instead if the previous argument is =nil=;
4. a fourth argument that can usually be ignored.


So to display the contents of a file at the toplevel, we might use the following function:
#+begin_src lisp
  (defun pseudo (file)
    (with-open-file (str file :direction :input)
      (do ((line (read-line str nil 'eof) (read-line str nil 'eof)))
	  ((eql line 'eof))
	(format t "~A~%" line))))  
#+end_src

#+begin_src lisp
CL-USER> (pseudo "myfile")
Something
NIL  
#+end_src





If you want input parsed into Lisp objects, use =read=. This function reads exactly one expression, and stops at the end of it. So it could read less than a line or more than a line. And of course what it reads has to be valid Lisp syntax.


If we use =read= at the toplevel, it will let us use as many newlines as we want within an expression:
#+begin_src lisp
CL-USER> (read)
(a
 b
 c)
(A B C)
#+end_src

On the other hand, if we type several expressions on a single line, =read= will stop processing characters after the first, leaving the remaining characters to be picked up by whatever reads next from this stream. So if in response to the prompt printed by =ask-number= we type several expressions on a line, the following will happen:
#+begin_src lisp
  (defun ask-number ()
    (format t "Please enter a number. ")
    (let ((val (read)))
      (if (numberp val)
	  val
	  (ask-number))))  
#+end_src

#+begin_src lisp
CL-USER> (ask-number)
Please enter a number. a b
Please enter a number. Please enter a number. 1
1  
#+end_src
Two successive prompts are printed on the second line. The first call to read returns =a=, which is not a number, so the function asks again for a number. But the first read only read up to the end of =a=. So the next call to read returns =b=, causing another prompt.



You may want to avoid using =read= directly to process user input. The preceding function would be better off if it used =read-line= to get what the user typed, then called =read-from-string= on the resulting string. This function takes a string and returns the first expression read from it:
#+begin_src lisp
CL-USER> (read-from-string "a b c")
A
2  
#+end_src
It also returns a second value, a number indicating the position in the string at which it stopped reading.

#+begin_src lisp
(read-from-string string &optional eof-error-p eof-value &key start end preserve-whitespace)  
#+end_src
- string :: the string to read from
- eof-error-p :: whether an end-to-end should cause an error
- oef-value :: if not, what to return instead
- start :: the start position to read from
- end :: the end position in reading





All these input functions are defined in terms of the primitive =read-char=, which reads a single character. It takes the same four optional arguments as =read= and =read-line=. Common Lisp also defines a function called =peek-char=, which is like =read-char= but does not remove the character from the stream.



** DONE Output
:LOGBOOK:
- State "DONE"       from              [2024-02-29 Thu 08:55]
:END:

The three *simplest* output functions are =prin1=, =princ=, and =terpri=. For all three the last argument is an optional stream argument, which defaults to =*standard-output*=.



The difference between =prin1= and =princ= is roughly that =prin1= generates output for programs, and =princ= generates output for people. So, for example, =prin1= prints the double-quotes around a string, and =princ= doesn't:
#+begin_src lisp
CL-USER> (prin1 "hello")
"hello"
"hello"
CL-USER> (princ "hello")
hello
"hello"  
#+end_src

The function =terpri= just prints a newline:
#+begin_src lisp
CL-USER> (terpri)

NIL  
#+end_src


The most general output function is =format=. This function can be used for almost all output. It takes a stream, a format string, and zero or more additional arguments. The format string may contain <<<format directives>>>, which are preceded by a ~ (tilde). Some format directives act as placeholders in the string. Their places will be taken by the representations of the arguments given after the format string.

If we give =t= as the first argument, output is sent to =*standard-output*=. If we give =nil=, format returns as a string what it would have printed.


Depending on one's point of view, format is either amazingly powerful or horribly complex. There are a large number of format directives, only a few of which most programmers will ever use. Two of the most commonly used format directives are =~A= and =~%=. (It doesn't matter whether you say =~a= or =~A=, but the latter form is more common because it makes the format directive stand out.) A =~A= is a placeholder for a value, which will be printed as if by =princ=. A =~%=, represents a newline.
#+begin_src lisp
CL-USER> (format nil "hello, ~A,~% how are you doing?" "Mingming Li")
"hello, Mingming Li,
 how are you doing?"  
#+end_src


The =~S= format directive is just like =~A=, but prints objects as if by =prin1= , rather than =princ=:
#+begin_src lisp
CL-USER> (format nil "~S  ~A" "M" "M")
"\"M\"  M"
CL-USER> (format t "~S  ~A" "M" "M")
"M"  M
NIL  
#+end_src



Format directives can take arguments. =~F=, which is used for printing right-justified floating-point numbers, can take up to five:
1. The total number of characters to be printed. Defaults to the exact length of the number.
2. The number of digits to print after the decimal. Defaults to all of them.
3. The number of digits to shift the decimal point to the left (thereby effectively multiplying the number by 10). Defaults to none.
4. The character to print instead of the number if it is too long to fit in the space allowed by the first argument. If no character is specified, an over-long number will be printed using as much space as it needs.
5. The character to print to the left before the digits start. Defaults to a blank.
#+begin_src lisp
CL-USER> (format nil "~10,2,0,'*,' F" 3.1415926)
"      3.14"  
#+end_src
This is the original number rounded to 2 decimal places, with the decimal point shifted left 0 places, right-justified in a field of 10 characters, padded on the left by blanks. Notice that a character given as an argument is written as ='*=, not the usual =#\*= . Since the number fit in 10 characters, the fourth argument didn't have to be used.


All these arguments are optional. To use the default you can simply omit the corresponding argument. If all we want to do is print a number rounded to two decimal places, we can say:
#+begin_src lisp
CL-USER> (format nil "~,2,,,F" 3.1415926)
"3.14"  
#+end_src


You can also omit a series of trailing commas, so the more usual way to write the preceding directive would be:
#+begin_src lisp
CL-USER> (format nil "~,2F" 3.1415926)
"3.14"  
#+end_src


** DONE Macro Characters
:LOGBOOK:
- State "DONE"       from              [2024-02-29 Thu 11:38]
:END:

A <<<macro character>>> is a character that gets special treatemet from =read=. For example, a lowercase =a= is ordinarily handled just like a lowercase =a=, but a left parenthesis is something different: it tells Lisp to begin reading a list.


A macro character or combination of macro characters is also known as a <<<read-macro>>> (<<<read-macros>>>). Many of Common Lisp's predefined read-macros are abbreviations. Quote, for example: as an expression like ='a= is read, it is expanded by the reader into a list, =(quote a)=. When you type quoted expressions into the toplevel, they are evaluated as soon as they are read, so ordinarily you never see this transformation. You can make it visible by invoking =read= explicitly:
#+begin_src lisp
CL-USER> 'a
A
CL-USER> (car (read-from-string "'a"))
QUOTE  
#+end_src


Quote is unusual for a read-macro in that it's expressed in a single-character. With a limited character set, you can only have so a few one-character read-macros; most of the read-macros in Common Lisp are expressed using two or more characters.

Such read-macros are called <<<dispatching>>> read-macros, and the first character is called the <<<dispatching character>>>. *All* the predefined dispatching read-macros use the sharp sign, =#=, as the dispatching character. For example, =#'= is an abbreviation for =(function ...)=.



Other dispatching read-macros we've seen include =#(...)=, which yields a vector; =#nA(...)= which yields an array; =#\=, which yields a character; and =#S(n ... )= , which yields a structure. When objects of each of these types are displayed by =prin1= or (=format= with =~S=), they are displayed using the corresponding read-macros. This means that you can write such objects out and read them back in:
#+begin_src lisp
CL-USER> (vectorp (read-from-string (format nil "~S" #(1 2))))
T
CL-USER> (arrayp (read-from-string (format nil "~S" #2((1 2) (3 4)))))
T
CL-USER> (characterp (read-from-string (format nil "~S" #\a)))
T
CL-USER> (defstruct point x y)
POINT
CL-USER> (make-point)
#S(POINT :X NIL :Y NIL)
CL-USER> (point-p (read-from-string (format nil "~S" #S(point :X nil :Y nil))))
T  
#+end_src
Of course, what we get back is not the same objct, but a new one with the same elements.



Not all objects are displayed in a distinct, readable form. Both functions and hash tables, for example, tend to be displayed as =#<...>=. In fact, =#<= is also a read-macro, but one that exists specifically to cause an error if it is encountered by =read=. Functions and hash tables can't be written out and read back in, and this read-macro ensures that users will have no illusions on this  point. (Lisp couldn't just use sharp-quote to represent functions, because sharp-quote by itself offers no way to represent a closure.)




When you're defining your own representations for things (the print-functions of structures, for example), you should keep this principle in mind. Either use a representation that can be read back in, or use =#<...>=.




* DONE Symbols
:LOGBOOK:
- State "DONE"       from              [2024-03-03 Sun 00:06]
:END:

** DONE Symbol Names
:LOGBOOK:
- State "DONE"       from              [2024-03-01 Fri 07:50]
:END:
Chapter [[*Welcome to Lisp]] described symbols as variable names existing as objects in their own right. But the range of possible Lisp symbols is broader than the range of variable names allowed in most languages. In fact, a symbol can have any string as its name. You can get the name of a symbol by calling =symbol-name=:
#+begin_src lisp
CL-USER> (symbol-name 'abc)
"ABC"  
#+end_src

Notice that the name of this symbol is all uppercase letters. By default Common Lisp converts all alphabetic characters in a symbol's name into uppercase as they are read. This means that, by default, Common Lisp is not case-sensitive:
#+begin_src lisp
CL-USER> (eql 'aBc 'Abc)
T
CL-USER> (CaR '(a b c))
A  
#+end_src




There is a special syntax for referring to symbols whose names contain whitespace or other things that might otherwise be significant to the reader. Any sequence of characters between vertical bars is treated as a symbol. You can put anything in the name of a symbol this way:
#+begin_src lisp
CL-USER> (list '|Lisp 2.29| '|| '|abc| '|ABC|)
(|Lisp 2.29| || |abc| ABC)
#+end_src
When the name of such a symbol is read, there is no case conversion, and macro characters are treated just like other characters.


So which symbols can you refer to without using vertical bars? Essentially, any symbol whose name is neither a number nor contains characters significant to the reader. A quick way to find out if you could refer to a symbol without using vertical bars is to see how Lisp prints it. If Lisp represents a symbol without vertical bars, as it did the last symbol in the list above, then you can too.


Remember that the vertical bars are a special syntax for denoting symbols. They are not part of the symbol's name:
#+begin_src lisp
CL-USER> (symbol-name '|a b c|)
"a b c"  
#+end_src
If you want to use a vertical bar in the name of a symbol, you can do it by putting a backslash before the bar.

** DONE Property Lists
:LOGBOOK:
- State "DONE"       from              [2024-03-01 Fri 07:50]
:END:

In Common Lisp every symbol has a <<<property-list>>>, or <<<plist>>>. The function =get= takes a symbol and a key of any type, and returns the value associated with that key in the symbol's property list (It uses =eql= to compare keys):
#+begin_src lisp
CL-USER> (get 'rabbit 'color)
NIL
CL-USER> (setf (get 'rabbit 'color) 'red)
RED
CL-USER> (get 'rabbit 'color)
RED  
#+end_src


The function symbol-plist returns the property list of a symbol:
#+begin_src lisp
CL-USER> (setf (get 'rabbit 'weight) '20kg)
20KG
CL-USER> (symbol-plist 'rabbit)
(WEIGHT 20KG COLOR RED)  
#+end_src



** DONE Symbols Are Big
:LOGBOOK:
- State "DONE"       from              [2024-03-01 Fri 08:38]
:END:
Symbols are created implicitly when we type their names, and when they are displayed the name is all we see. But there is more to symbols.

In fact a symbol is a substantial object, more like the kind of structure that might be defined by =defstruct=. A symbol can have a name, a home package, a value as a variable, a value as a function, and a property list. Figure [[fig:symbols]] shows how symbols are represented internally.
#+caption: Structure of a symbol
#+label: fig:symbols
[[file:images/symbols.png]]




Few programs use so many symbols that it would be worth using something else to save space. But it is worth bearing in mind that symbols are real objects, and not just names. 

** DONE Creating Symbols
:LOGBOOK:
- State "DONE"       from              [2024-03-01 Fri 08:38]
:END:
Section [[* Symbol Names]] showed how to get from symbols to their names. It's also possible to go in the other direction, from strings to symbols. This gets a little more complicated, because we have to introduce the topic of packages.


Conceptually, <<<packages>>> are symbols-tabels, mapping names to symbols. Every ordinary symbol belongs to a paticular <<<package>>>. A symbol that belongs to a package is said to be *interned* in that package. Functions and variables have symbols as their names. Packages enforce modularity by restricting which symbols are accessible, and thus, which functions and variables one can refer to.


Most symbols are interned when they are read. The first time you type the name of a new symbol, Lisp will create a new symbol object and intern it in the current package (which by default will be =common-lisp-user=). But you can also intern a symbol by giving a string and an optional package argument to =intern=:
#+begin_src lisp
CL-USER> (intern "RANDOM-SYMBOL")
RANDOM-SYMBOL
NIL  
#+end_src
#+begin_src lisp
CL-USER> *package*
#<PACKAGE "COMMON-LISP-USER">  
#+end_src

The package argument defaults to the current package, so the preceding expression returns the symbol in the current package whose name is the string "RANDOM-SYMBOL", creating such a symbol if it doesn't already exist. The second return value shows whether the symbol already existed; in this case, it didn't.


Not all symbols are interned. It can sometimes be useful to have an uninterned symbol, for the same reason that it can be useful to have an unlisted phone number. Uninterned symbols are called <<<gensyms>>>.


** DONE Multiple Packages
:LOGBOOK:
- State "DONE"       from              [2024-03-02 Sat 08:38]
:END:

Larger programs are often divided up into multiple packages. If each part of a program is in its own package, then someone working on one part of the program will be able to use a symbol as the name of a function or variable without worrying that the name is already used elsewhere.


In languages that don't provide a way to define multiple namespaces, the programmers working on a big project usually work out some convention to ensure that they don't use the same names. For example, the programmer writing the display code might only use names beginning with =disp_=, while the programmer writing the math code only used names beginning with =math_=. So if the math code included a function to do fast Fourier transforms, it might be called =math_fft=.


Packages just provide a way to do this automatically. If you define your functions in a separate package, you can use whatever names you like. Only symbols that you explicitly export will be visible in other packages, and there they will usually have to be preceded (or qualified) by the name of the package that owns them.


For example, suppose a program is divided into two packages, =math= and =disp=. If the symbol =fft= is exported by the math package, then code in the =disp= package will be able to refer to it as =math:fft=. Within the math package, it will be possible to refer to it as simply =fft=.


Here is what you might put at the top of afilecontaining a distinct package of code:
#+caption: my-aplication.lisp
#+begin_src lisp
  (defpackage "MY-APPLICATION"
    (:use "COMMON-LISP" "MY-UTILITIES")
    (:nicknames "APP")
    (:export "WIN" "LOSE" "DRAW"))

  (in-package my-application)
#+end_src

The =defpackage= defines a new package called =my-application=. It uses two other packages, =common-lisp= and =my-utilities=, which means that symbols exported by these packages will be accessible without package qualifiers. Most packages will use =common-lisp= - you don't want to have to qualify the names of the built-in Lisp operators and variables.


The =my-application= package itself exports just three symbols: =win=, =lose=, and =draw=. Since the call to =defpackage= gave =my-application= the nickname =app=, code in other packages will be able to refer to them as e.g. =app:win=.


The =defpackage= if followed by an =in-package= that makes the current package be =my-application=. All the unqualified symbols in the rest of the file will be interned in =my-application= - unless there is another =in-package= later on. When a file has been loaded, the current package is always reset to the value it had before the load began.

#+begin_src lisp
CL-USER> *package*
#<PACKAGE "COMMON-LISP-USER">
CL-USER> (load "/Users/mingmingli/info/information-technology/programming-languages/common-lisp/practice/my-application.lisp")
T
CL-USER> *package*
#<PACKAGE "COMMON-LISP-USER">  
#+end_src


** DONE Keywords
:LOGBOOK:
- State "DONE"       from              [2024-03-03 Sun 00:05]
:END:
Symbols in the =keyword= package (known as *<<<keywords>>>*) have two unique properties: they always evaluate to themselves, and you can refer to them anywhere simply as =:x=, instead of =keyword:x=. When keyword parameters were first introduced in [[*Parameter Lists]], it might have seemed more natural for the call to read =(member '(a) '((a) (z)) test: #' equal)= rather than =(member '(a) '((a) (z)) :test #'equal)=. Now we see why the unnatural-looking second form is actually the correct one. The colon prefixed to =test= is just to identify it as a keyword.




Why use keywords instead of ordinary symbols? Because they are accessible anywhere. A function that takes symbols as arguments should usually be written to expect keywords. For example
#+begin_src lisp
(defun noise (animal)
  (case animal
    (:dog :woof)
    (:cat :meow)
    (:pig :oink)))
#+end_src
If it had been written to use ordinary symbols, it would only work when called from the package in which it was defined, unless the keys were exported as well.

#+begin_src lisp
(defpackage "MY-APPLICATION"
  (:use "COMMON-LISP")
  (:nicknames "APP")
  (:export "NOISE" "NOISE2"))

(in-package my-application)



(defun noise (animal)
  (case animal
    (:dog :woof)
    (:cat :meow)
    (:pig :oink)))

(defun noise2 (animal)
  (case animal
    ('dog 'woof)
    ('cat 'meow)
    ('pig 'oink)))
  
#+end_src

#+begin_src lisp
CL-USER> (my-application:noise :cat)
:MEOW
CL-USER> (my-application:noise2 'cat)
NIL  
#+end_src



** DONE Symbols and Variables
:LOGBOOK:
- State "DONE"       from              [2024-03-03 Sun 00:06]
:END:


One potentially confusing thing about Lisp is that symbols are related to variables in two very different ways.


When a symbol is the name of a special variable, the value of the variable is stored in a field within the symbol ([[fig:symbols]]). The =symbol-value= function refers to that field, so we have a direct connection between a symbol and the value of the special variable it represents.


With lexical variables, things are completely different. A symbol used as a lexical variable is just a placeholder. The compiler will translate it into a reference to a register or a location in memory. In the eventual compiled code, there will be no trace of the symbol (unless it is retained somewhere for use by the debugger). So of course there is no connection between symbols and the values of the lexical variables they represent; by the time there is a value, the symbol is gone.



* DONE Numbers
:LOGBOOK:
- State "DONE"       from              [2024-03-05 Tue 08:46]
:END:
Common Lisp has a rich set of numeric types and its features for manipulating numbers compare favorably with any language.


** DONE Types
:LOGBOOK:
- State "DONE"       from              [2024-03-03 Sun 00:11]
:END:
Common Lisp provides four distinct types of numbers: integer,floating-point numbers, ratios, and complex numbers. Most of the functions described in this chapter work on numbers of any type. A few, explicitly noted, accept all but complex numbers.


An integer is written as a string of digits: =2001=. A floating-point number can be written as a string of digits containing a decimal point, =253.72=, or in scientific notation, =2.5372e2=. A ratio is written as a fraction of integers: =2/3=. And the complex number =a+bi= is written as =#c(a b)=, where =a= and =b= are any two real numbers of the same type.


The predicates =integerp=, =floatp=, and =complexp= return true for numbers of the corresponding types.

Figure [[fig:numeric-types]] shows the hierarchy of numeric types.
#+caption: Numeric types
#+label: fig:numeric-types
#+attr_html: :width 50%
[[file:images/numeric-types.png]]



Here are some general rules of thumb for determining what kind of number a computation will return:
1. If a numeric function receives one or more floating-point numbers as arguments, the return value will be a floating-point number (or a complex number with floating-point components). So =(+ 1.0 2)= evaluates to =3.0=, and =(+ #c(0 1.0) 2)= evaluates to =#c(2.0 1.0)=.
2. Ratios that divide evenly will be converted into integers. So =(/ 10 2)= will return =5=.
3. Complex numbers whose imaginary part would be zero will be converted into reals. So =(+ #c(1 -1) #c(2 1))= evaluates to =3=.


Rules 2 and 3 apply to arguments as soon as they are read, so:
#+begin_src lisp
CL-USER> (list (ratiop 2/2) (complexp #c(1 0)))
(NIL NIL)  
#+end_src

#+begin_src lisp
  (defun ratiop (x)
    (and (typep x 'rational)
	 (> (denominator x) 1)))
#+end_src


** DONE Conversion and Extraction
:LOGBOOK:
- State "DONE"       from              [2024-03-03 Sun 00:30]
:END:
Common Lisp provides functions for converting and extracting components of the four kinds of numbers.

The function =float= converts any real number to a floating-point numbers:
#+begin_src lisp
CL-USER> (mapcar #'float '(1 2/3 .5))
(1.0 0.6666667 0.5)
#+end_src

Reducing numbers to integers is not necessarily conversion, because it can involve some loss of information. The function =truncate= returns the integer component of any real number:
#+begin_src lisp
CL-USER> (truncate 1.3)
1
0.29999995
#+end_src
The second return value is the original argument minus thefirstreturn value. The difference of =.00000005= is due to the inherent inexactitude of floating-point computation.


The functions =floor=, =ceiling= and =round= also derive integers from there arguments. The function =round= returns the nearest integer to its argument. When the argument is equidistant from two integers, Common Lisp, like many programming languages, does not round up. Instead it rounds to the nearest even digit.
#+begin_src lisp
CL-USER> (floor 1.5)
1
0.5
CL-USER> (ceiling 1.5)
2
-0.5
CL-USER> (mapcar #'round '(-2.5 -1.5 1.5 2.5))
(-2 -2 2 2)
CL-USER> (round 1.5)
2
-0.5
#+end_src


The function =mod= returns the modulus and =rem= returns the remainder.
#+begin_src lisp
CL-USER> (mod 13 4)
1
CL-USER> (rem 13 4)
1
CL-USER> (mod -13 4)
3
CL-USER> (rem -13 4)
-1  
#+end_src


The function =signum= returns either 1, 0, or -1, depending on whether its argument is positive, zero, or negative.
#+begin_src lisp
CL-USER> (mapcar #'signum '(-2 -0.0 0.0 0 .5 3))
(-1 -0.0 0.0 0 1.0 1)  
#+end_src
In some implementations =-0.0= may exist in its own right, as above. Functionally it makes little difference whether it does or not, because in numeric code =-0.0= behaves exactly like =0.0=.


The function =abs= returns the absolute value of its argument.
#+begin_src lisp
CL-USER> (abs 1)
1
CL-USER> (abs -1)
1  
#+end_src



Ratios and complex numbers are conceptually two-part structures. The functions =numerator= and =denominator= return the corresponding components of a ratio or integer. (If the number is an integer, the former returns the number itself and the latter returns 1.) The functions =realpart= and =imagpart= return the real and imaginary components of any number. (If the number isn't complex, the former returns the number itself and the latter returns zero.)
#+begin_src lisp
CL-USER> (numerator 1/3)
1
CL-USER> (denominator 1/3)
3
CL-USER> (numerator 10)
10
CL-USER> (denominator 10)
1
CL-USER> (realpart #c(2 3))
2
CL-USER> (imagpart #c(2 3))
3
CL-USER> (realpart 5)
5
CL-USER> (imagpart 5)
0  
#+end_src


The function =random= takes an integer or floating-point number. An expression of the form =(random n)= returns a number greater than or equal to zero and less than =n=, and of the same type as =n=.
#+begin_src lisp
CL-USER> (random 10)
6
CL-USER> (random 10)
9
CL-USER> (random 10)
5
CL-USER> (random 10.0)
2.6471841
CL-USER> (random 10.0)
6.1633406
CL-USER> (random 10.0)
1.9508076  
#+end_src

** DONE Comparison
:LOGBOOK:
- State "DONE"       from              [2024-03-05 Tue 07:58]
:END:
The predicate = returns true when its arguments are numerically equal — when the difference between them is zero. It is less strict than =eql=, which also requires its arguments to be of the same type.
#+begin_src lisp
CL-USER> (= 1 1.0)
T
CL-USER> (eql 1 1.0)
NIL
#+end_src



The predicates for comparing numbers are < (less than) , <= (less than or equal), = (equal), >= (greater than or equal), > (greater than), and /= (different). All of them take one or more arguments. With one argument they all return =t=. For all except /=, a call with three or more arguments,
#+begin_src lisp
  (<= w x y z)
#+end_src
is equivalent to the conjunction of a binary opeator applied to successive pairs of arguments:
#+begin_src lisp
  (and (<= w x) (<= x y) (<= y z))
#+end_src


Since /= returns true if no two of its arguments are =, the expresssion
#+begin_src lisp
  (/= w x y z)
#+end_src
is equivalent to
#+begin_src lisp
  (and (/= w x)
       (/= w y)
       (/= w z)
       (/= x y)
       (/= x z)
       (/= y z))
#+end_src

The specialized predicates =zerop=, =plusp= and =minusp= take one argument and return true if it is =, > and < zero, respectively. These functions do not overlap. Although is preceded by a negative sign, it is = to 0,
#+begin_src lisp
CL-USER> (list (minusp -0.0) (zerop -0.0))
(NIL T)  
#+end_src



The predicates =oddp= and =evenp= apply only to integers. The former is true only of odd integers, and the latter only of even ones.
#+begin_src lisp
CL-USER> (list (oddp 1) (oddp 2) (evenp 1) (evenp 2))
(T NIL NIL T)  
#+end_src


Of the predicates described in this section, only ===, =/==, and =zerop= apply to complex numbers.


The functions max and min return, respectively, the maximum and minimum of their arguments. Both require at least one:
#+begin_src lisp
CL-USER> (max 1 2 3 4 5)
5
CL-USER> (min 1 2 3 4 5)
1  
#+end_src

** DONE Arithmetic
:LOGBOOK:
- State "DONE"       from              [2024-03-05 Tue 08:31]
:END:

The functions for addition and subtraction are + and -. Both can take any number of arguments, including none, in which case they return 0. An expression of the form =(- n)= returns =—n=. An expression of the form
#+begin_src lisp
  (- x y z)
#+end_src
is equivalent to
#+begin_src lisp
  (- (- x y) z)
#+end_src

There are also two functions =1+= and =1-=, which return their argument plus 1 and minus 1 respectively. The name =1-= is a bit misleading, because =(1- x)= returns =x - 1=, not =1 - x=. 


The macros =incf= and =decf= increment and decrement their argument, respectively. An expression of the form =(incf x n)= is similar in effect to =(setf x (+ x n))=, and =(decf x n)= to =(setf x (- x n))=. In both cases the second argument is optional and defaults to 1.


The function for multiplication is =*=. It takes any number of arguments. When given no arguments it returns 1. Otherwise it returns the product of its arguments.


The division function, / , expects at least one argument. A call of the form =(/ n)= is equivalent to =(/ 1 n)=:
#+begin_src lisp
CL-USER> (/ 3)
1/3
#+end_src
while a call of form
#+begin_src lisp
  (/ x y z)
#+end_src
is equivalent to
#+begin_src lisp
  (/ (/ x y) z)
#+end_src


When given two integers, / will return a ratio if the first is not a multiple of the second:
#+begin_src lisp
CL-USER> (/ 22 21)
22/21
CL-USER> (float 22/21)
1.0476191
#+end_src


** DONE Exponentiation
:LOGBOOK:
- State "DONE"       from              [2024-03-05 Tue 08:36]
:END:
To find $x^n$ we call =(expt x n)= and to find $log_n x$ we call =(log x n)=:
#+begin_src lisp
CL-USER> (expt 2 10)
1024
CL-USER> (log 1024 2)
10.0
#+end_src


To find =e^x= there is a distinct function =exp=:
#+begin_src lisp
CL-USER> (exp 2)
7.389056
#+end_src



To find a natural logarithm you can just you =log=, because the second argument defaults to =e=:
#+begin_src lisp
CL-USER> (log 7.389056)
2.0  
#+end_src


To find roots you can tell =expt= with a ratio as the second argument:
#+begin_src lisp
CL-USER> (expt 27 1/3)
3.0  
#+end_src
but for finding square roots the function =sqrt= should be faster:
#+begin_src lisp
CL-USER> (sqrt 9)
3.0  
#+end_src



** DONE Trigonometric Functions
:LOGBOOK:
- State "DONE"       from              [2024-03-05 Tue 08:38]
:END:
The constant =pi= is a floating-point representation of \pi. Its precision is implementation-dependent. The functions =sin=, =cos=, and =tan= find the sine, cosine, and tangent, respectively, of angles expressed in radians:
#+begin_src lisp
CL-USER> (let ((x (/ pi 4)))
	   (list (sin x) (cos x) (tan x)))
(0.7071067811865475d0 0.7071067811865476d0 0.9999999999999999d0)  
#+end_src
These functions all take negative and complex arguments.


The functions =asin=, =acos= and =atan= implement the inverse of sine, cosine, and tangent. 


Hyperbolic sine, cosine, and tangent are implemented by =sinh=, =cosh=, and =tanh=, respectively. Their inverses are likewise =asinh=, =acosh=, and =atanh=.


** DONE Representation
:LOGBOOK:
- State "DONE"       from              [2024-03-05 Tue 08:46]
:END:

Common Lisp imposes no limit on the size of integers. Small integers fit in one word of memory and are called =fixnum=. When a computation produces an integer too large to fit in one memory word, Lisp switches to a representation (a =bignum=) that uses multiple words of memory. So the effective limit on the size of an integer is imposed by physical memory, not by the language.



The constants =most-positive-fixnum= and =most-negative-fixnum= indicate the largest magnitudes an implementation can represent without having to use bignums.
#+begin_src lisp
CL-USER> most-positive-fixnum
4611686018427387903
CL-USER> most-negative-fixnum
-4611686018427387904  
#+end_src



The predicate =typep= takes an argument and a type name and returns true if the argument is of the specified type. So,
#+begin_src lisp
CL-USER> (typep 1 'fixnum)
T
CL-USER> (typep (1+ most-positive-fixnum) 'bignum)
T  
#+end_src


The limits on the values of floating-point numbers are implementation-dependent. Common Lisp provides up to four types of floating-point numbers: =short-float=, =single-float=, =double-float=, and =long-float=. Implementations are not required to use distinct formats for all four types.
#+begin_src lisp
CL-USER> most-positive-short-float
3.4028235e38
CL-USER> most-positive-single-float
3.4028235e38
CL-USER> most-positive-double-float
1.7976931348623157d308
CL-USER> most-positive-long-float
1.7976931348623157d308  
#+end_src

The general idea is that a short float is supposed to fit in a single word, that single and double floats are supposed to provide the usual idea of single- and double-precision floating-point numbers, and that long floats can be something really big, if desired. But an implementation could perfectly well implement all four the same way.


You can specify what format you want a floating-point number to be by substituting the letters =s, f, d, or l= for the =e= when a number is represented in scientific notation. (You can use uppercase too, and this is a good idea for long floats, because l looks so much like 1.) So to make the largest representation of 1.0 you would write 1L0.
#+begin_src lisp
CL-USER> 1S0
1.0
CL-USER> 1F0
1.0
CL-USER> 1D0
1.0d0
CL-USER> 1L0
1.0d0  
#+end_src


Sixteen global constant mark the limits of each format in a given implementation. Their names are of the format =m-s-f= where =m= is =most= or =least=, =s= is =positive= or =negative=, and =f= is one of the four type of float.
#+begin_src lisp
CL-USER> most-positive-long-float
1.7976931348623157d308  
#+end_src


* DONE Macros
:LOGBOOK:
- State "DONE"       from              [2024-03-07 Thu 19:58]
:END:
Lisp code is expressed as lists, which are Lisp objects. This made it possible to write programs that would write programs. This chapter shows how to cross the line from expressions to code.


** DONE Eval
:LOGBOOK:
- State "DONE"       from              [2024-03-07 Thu 08:49]
:END:
The function =eval= takes an expression, evaluates it, and returns its value:
#+begin_src lisp
CL-USER> (eval '(+ 1 2 3))
6
CL-USER> (eval '(format t "Hello"))
Hello
NIL
#+end_src


The following function implements something very like the toplevel:
#+begin_src lisp
  (defun our-toplevel ()
    (do ()
	(nil)
      (format t "~%> ")
      (print (eval (read)))))
#+end_src
For this reason the toplevel is also known as a read-eval-print loop (REPL).


Calling =eval= is one way to cross the line between lists and code. However it is not a very good way:
1. It's inefficient. =eval= is handed a raw list, and either has to compile it on the spot, or evaluate it in an interpreter. Either way is much slower than running compiled code.
2. The expression is evaluated with no lexical context. If you call =eval= within a =let=, for example, the expressions passed to =eval= cannot refer to variables established by the =let=.



There are much better ways to take advantage of the possibility of generating code. Indeed, one of the only places where it is legitimate to use =eval= is in something like a toplevel loop.



For programmers the main value of =eval= is probably as a conceptual model for Lisp. We can imagine it defined as a big =cond= expression:
#+begin_src lisp
  (def our-eval (expr env)
    (cond ...
	  ((eql (car expr) 'quote) (cadr expr))
	  ...
	  (t (apply (symbol-function (car expr))
		    (mapcar #'(lambda (x)
				(our-eval x env))
			    (cdr exprt))))))
#+end_src
Most expressions are handled by the default clause, which says to get the function referred to in the =car=, evaluate all the arguments in the =cdr=, and return the result of applying the former to the latter.


However, we can't do this for an expression like =(quote x)=, since the whole point of =quote= is to preserve its argument from evaluation. So we have to have a distinct clause just for =quote=. That's what a special operator is, essentially: an operator that has to be implemented as a special case in =eval=.



The function =coerce= and =compile= provide a similar bridge from lists to code. You can =coerce= a lambda expression into a function:
#+begin_src lisp
CL-USER> (coerce '(lambda (x) x) 'function)   ; type conversion
#<FUNCTION (LAMBDA (X)) {54B4288B}>  
#+end_src
and if you give =nil= as the first argument to =compile=, it will compile a lambda expression given as the second argument:
#+begin_src lisp
CL-USER> (compile nil '(lambda (x) (+ x 2)))
#<FUNCTION (LAMBDA (X)) {54B2743B}>
NIL
NIL
CL-USER> (compile '2+ '(lambda (x) (+ x 2)))
2+
NIL
NIL
CL-USER> (2+ 3)
5
#+end_src
Since =coerce= and =compile= can take lists as arguments, a program could build new functions on the fly. However, this is a drastic measure, comparable to calling =eval=, and should be viewed with the same suspicion.


The trouble with =eval=, =coerce=, and =compile= is not that they cross the line between lists and code, but that they do it at run-time. Crossing the line is expensive. Doing it at compile-time is good enough in most cases, and costs nothing when your program runs. The next section shows how to do this.



** DONE Macros                                                    :important:
:LOGBOOK:
- State "DONE"       from              [2024-03-07 Thu 09:02]
:END:
The most common way to write programs that write programs is by defining macros. <<<Macros>>> are operators that are implemented by transformation. You define a macro by saying how a call to it should be translated. This translation, called <<<macro-expansion>>>, is done automatically by the compiler. So the code generated by your macros becomes an integral part of your program, just as if you had typed it in yourself.

Macros are usually defined by calling =defmacro=. A =defmacro= looks a lot like a =defun=, but instead of defining the value a call should produce, it defines how a call should be translated. For example, a macro to set its argument to =nil= might be defined as follows:
#+begin_src lisp
  (defmacro nil! (x)
    (list 'setf x nil))
#+end_src
This defines a new operator call =nil!=, which will take one argument. A call of the form =(nil! a)= will be translated into =(setf a nil)= before being compiled or evaluated. So if we type =(nil! x)= into the toplevel,
#+begin_src lisp
CL-USER> (nil! x)
NIL
CL-USER> x
NIL
#+end_src
it is exactly equivalent to typing the expansion, =(setf x nil)=.



To test a function, we call it, but to test a macro, we look at its expansion. The function =macroexpand-1= takes a macro call and generates its expansion:
#+begin_src lisp
CL-USER> (macroexpand-1 '(nil! x))
(SETF X NIL)
T  
#+end_src
A macro call can expand into another macro call. When the compiler (or the toplevel) encounters a macro call, it simply keeps expanding it until it is no longer one.


The secret to understanding macros is to understand how they are implemented. Underneath, they're just functions that transform expressions. For example, if you pass an expression of the form =(nil! a)= to this function
#+begin_src lisp
  (lambda (expr)
    (apply #'(lambda (x)
	       (list 'setf x nil))
	   (cdr expr)))  
#+end_src
it will return =(setf a nil)= . When you use =defmacro=, you're defining a function much like this one. All =macroexpand-1= does, when it sees an expression whose car is known to be the name of a macro, is pass the expression to the corresponding function.




** DONE Backquote
:LOGBOOK:
- State "DONE"       from              [2024-03-07 Thu 10:44]
:END:
The backquote read-macro makes it possible to build lists from templates. Backquote is used extensively in macro definitions. While a regular quote is a close-quote (apostrophe) on the keyboard, a backquote is an open-quote. It's called "backquote" because it looks like a normal quote tilted backwards.


Used by itself, a backquote is equivalent to a regular quote:
#+begin_src lisp
CL-USER> `(a b c)
(A B C)  
#+end_src
Like a regular quote, a backquote alone protects its argument from evaluation.

The advantage of backquote is that, within a backquoted expression, you can use , (comma) and ,@ (comma-at) to turn evaluation back on. If you prefix a comma to something within a backquoted expression, it will be evaluated. Thus we can use backquote and comma together to build list templates:
#+begin_src lisp
CL-USER> (setf a 1 b 2)
2
CL-USER> `(a is ,a and b is ,b)
(A IS 1 AND B IS 2)  
#+end_src

By using backquote instead of a call to =list=, we can write macro definitions that look like the expansions they will produce. For example, =nil!= could be defined as:
#+begin_src lisp
  (defmacro nil! (x)
    `(setf ,x nil))
#+end_src


Comma-at is like comma, but splices its argument (which should be a list). Instead of the list itself, its elements are inserted in the template:
#+begin_src lisp
CL-USER> (setf lst '(a b c))
(A B C)
CL-USER> `(lst is ,lst)
(LST IS (A B C))
CL-USER> `(its elements are ,@lst)
(ITS ELEMENTS ARE A B C)  
#+end_src

Comma-at is useful in macros that have rest parameters representing, for example, a body of code. Suppose we want a =while= macro that will evaluate its body so long as an initial test expression remains true:
#+begin_src lisp
CL-USER> (let ((x 0))
	   (while (< x 10)
		  (princ x)
		  (incf x)))
0123456789
NIL  
#+end_src


We can define such a macro by using a rest parameter to collect a list of the expressions in the body, then using comma-at to splice this list into the expansion:
#+begin_src lisp
  (defmacro while (test &rest body)
    `(do ()
	 ((not ,test))
       ,@body))
#+end_src



** DONE Macro Design
:LOGBOOK:
- State "DONE"       from              [2024-03-07 Thu 19:32]
:END:

Writing macros is a distinct kind of programming, with its own unique aims and problems. Being able to change what the compiler sees is almost like being able to rewrite it. So when you start writing macros, you have to start thinking like a language designer.


This section gives a quick overview of the problems involved, and the techniques used to solve them. As an example, we will define a macro called
=ntimes=, which takes a number =n= and evaluates its body =n= times:
#+begin_src lisp
  >  (ntimes 10
	     (princ "."))
  ..........
  NIL
#+end_src

Here is an incorrect definition of =ntimes= that illustrates dome issues in macro design:
#+begin_src lisp
  (defmacro ntimes (n &rest body)		; wrong
    `(do ((x 0 (+ x 1)))
	 ((>= x ,n))
       ,@body))
#+end_src
This definition may look ok at first sight. In the case above it would work as intended. But in fact it is broken in two ways.

One of the problems that macro designer have to think about is inadvertent variable captures. This happens when a variable used in macro expansion happens to have the same name as a variable existing in the context where the expansion is inserted. The incorrect definition of =ntimes= creates a variable =x=. So if the macro is called in a place where there is already a variable with that name, it may not do what we expected:
#+begin_src lisp
CL-USER> (let ((x 10))
	   (ntimes 5
		   (setf x (+ x 1)))
	   x)
10  
#+end_src
If =ntimes= did what it was supposed to, this expression should increment =x= five times, and finally return 15. But because the macro expansion happens to use =x= as its iteration variable, the =setf= expression increments the value of that =x=, not the one that we meant to increment. Once the macro call is expanded, the preceding expression becomes:
#+begin_src lisp
CL-USER> (let ((x 10))
	   (do ((x 0 (+ x 1)))
	       ((>= x 5))
	     (setf x (+ x 1)))
	   x)
10
#+end_src
The most general solution is not to use ordinary symbols anywhere they might be captured. Instead we can use gensyms. Because =read= interns every symbol it sees, there is no way a gensym could =eql= to any symbol occurring in a program text. If we rewrite the definition of =ntimes= to use a gensym instead of =x=, it will at least be safe from variable capture:
#+begin_src lisp
  (defmacro ntimes (n &rest body)		; wrong
    (let ((g (gensym)))
      `(do ((,g 0 (+ ,g 1)))
	   ((>= ,g ,n))
	 ,@body)))	
#+end_src

However, this macro is still susceptible to another problem: multiple evaluation. Because the first argument is inserted directly into the =do=, it will be evaluated on each iteration. This mistake shows most clearly when the first argument is an expression with side-effects:
#+begin_src lisp
CL-USER> (let ((v 10))
	   (ntimes (setf v (- v 1))
		   (princ ".")))
.....
NIL  
#+end_src
Since =v= is initially 10 and =setf= returns the value of its second argument, this should print nine periods. In fact it prints only five.


We see why if we look at the expression with the macro call expanded:
#+begin_src lisp
  (let ((v 10))
    (do ((#:g1 0 (+ #:g1 1)))
	((>= #:g1 (setf v (- v 1))))
      (princ ".")))
#+end_src
On each iteration we compare the iteration variable (gensyms usually print as symbols preceded by #:) not against 9, but against an expression that decreases each time it is evaluated. It is as if the horizon gets closer each time we look at it.


The way to avoid unintended multiple evaluations is to set a variable to the value of the expression in question before any iteration. This usually involves another gensym:
#+begin_src lisp
  (defmacro ntimes (n &rest body)
    (let ((g (gensym))
	  (h (gensym)))
      `(let ((,h ,n))
	 (do ((,g 0 (+ ,g 1)))
	     ((>= ,g ,h))
	   ,@body))))
#+end_src
Here, finally, is a correct definition of ntimes.




*Unintended variable capture* and *multiple evaluation* are the major problems that can afflict macros, but they are not the only ones. With experience it is no more difficult to avoid such errors than it is to avoid more familiar errors, like dividing by zero. But because macros give us a new kind of power, the kind of problems we have to worry about are also new.





Your Common Lisp implementation is a good place to learn more about macro design. By expanding calls to the built-in macros, you can usually understand how they were written.
#+begin_src lisp
CL-USER> (pprint (macroexpand-1 '(cond 
				  (a b)
				  (c d e)
				  (t f))))

(IF A
    B
    (IF C
        (PROGN D E)
        (THE T F)))
; No value
#+end_src

The function =pprint= (pretty print), which prints expressions indented like code, is especially useful when looking at macro expansions.



** DONE Generalized Reference
:LOGBOOK:
- State "DONE"       from              [2024-03-07 Thu 19:52]
:END:

Since a macro call is expanded right into the code where it appears, any macro call whose expansion could be the first argument to =setf= can itself be the first argument to =setf=. For example, if we defined a synonym for =car=,
#+begin_src lisp
  (defmacro cah (lst)
    `(car ,lst))
#+end_src
then because a call to =car= can be the first argument to =setf=, so could a call to =cah=:
#+begin_src lisp
CL-USER> (let ((x (list 'a 'b 'c)))
	   (setf (cah x) 44)
	   x)
(44 B C)  
#+end_src

Writing a macro that expands into a =setf= is another question, and a more difficult one than it might seem at first. It might seem that you could implement =incf= simply as:
#+begin_src lisp
  (defmacro my-incf (x &optional (y 1))	; wrong
    `(setf ,x (+ ,x ,y)))
#+end_src
But this would not work. These two expressions are not equivalent.
#+begin_src lisp
(setf (car (push 1 lst)) (+ (car (push 1 lst)) 1))
(incf (car (push 1 lst)))
#+end_src
If =lst= is initially =nil=, the second expression will set it to =(2)=, but the first expression would set it to =(1 2)=:
#+begin_src lisp
CL-USER> (setf lst nil)
NIL
CL-USER> (my-incf (car (push 1 lst)))
2
CL-USER> lst
(1 2)
CL-USER> (setf lst nil)
NIL
CL-USER> (incf (car (push 1 lst)))
2
CL-USER> lst
(2)
#+end_src



Common Lisp provides =define-modify-macro= as a way of writing a restricted class of macros on =setf=. It takes three arguments: the name of the macro, its additional parameters (the place is implicitly the first), and the name of a function that yields the new value of the place. So we could define =incf= as
#+begin_src lisp
  (define-modify-macro our-incf (&optional (y 1)) +)
#+end_src
#+begin_src lisp
CL-USER> (pprint (macroexpand-1 '(our-incf (car (push 1 lst)) 2)))

(LET* ((#:G264 (PUSH 1 LST)))
  (SB-KERNEL:%RPLACA #:G264 (+ (CAR #:G264) 2)))
; No value  
#+end_src

#+begin_src lisp
  (define-modify-macro append1f (val) (lambda (lst val)
					(append lst (list val))))
#+end_src
#+begin_src lisp
CL-USER> (let ((lst '(a b c)))
	   (append1f lst 'd)
	   lst)
(A B C D)
CL-USER> (pprint (macroexpand-1 '(append1f lst val)))

(LET* ((#:VAL VAL))
  (SETQ LST ((LAMBDA (LST VAL) (APPEND LST (LIST VAL))) LST #:VAL)))
; No value
#+end_src

Incidently, neither =push= nor =pop= can be defined as modify-macros, the former because the place is not its first argument, and the latter because its return value is not the modified object.




** DONE On Lisp
:LOGBOOK:
- State "DONE"       from              [2024-03-07 Thu 19:58]
:END:
Is it worth writing a macro just to save typing? Very much so. Saving typing is what programming languages are all about; the purpose of a compiler is to save you from typing your program in machine language. And macros allow you to bring to your specific applications the same kinds of advantages that high-level languages bring to programming in general. By the careful use of macros, you may be able to make your programs significantly shorter than they would be otherwise, and proportionately easier to read, write, and maintain.


If you doubt this, consider what your programs would look like if you didn't use any of the built-in macros. All the expansions those macros generate, you would have to generate by hand. You can use this question in the other direction as well. As you're writing a program, ask yourself, am I writing macroexpansions? If so, the macros that generate those expansions are the ones you need to write.



Most of the Common Lisp operators that aren't functions are macros, and they are all written in Lisp. Only 25 of Common Lisp's built-in operators are special operators.


John Foderaro has called Lisp "a programmable programming language." By writing your own functions and macros, you can turn Lisp into just about any language you want. Whatever turns out to be the right form for your program, you can be assured that you will be able to shape Lisp to suit it.


Macros are one of the key ingredients in this flexibility. They allow you to transform Lisp almost beyond recognition, and yet to do so in a principled, efficient way. It's clear already that one can do amazing things with them, but more certainly remain to be discovered. By you, if you want. Lisp has always put its evolution in the hands of the programmer. That's why it survives.



* DONE CLOS
:LOGBOOK:
- State "DONE"       from              [2024-03-09 Sat 12:21]
:END:
The Common Lisp Ojbect System, or <<<CLOS>>>, is a set of operators for doing object-oriented programming. Technically, they are in no way distinguished from the rest of Common Lisp: =defmethod= is just as much (and just as little) as integral part of the language as =defun=. 


** DONE Object-Oriented Programming
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 06:29]
:END:
Object-oriented programming means a change in the way programs are organized. Instead of having a single program that operates on an inert mass of data, the data itself it told how to behave, and the program is implicit in the interactions of these new data "objects".


For example, suppose we want to write a program to find the areas of two-dimensional shapes. One way to do this would be to write a single function that looked at the type of its argument and behaved accordingly,
#+caption: Area with structures and a function.
#+label: prog:non-clos
#+begin_src lisp
  (defstruct rectangle
    height width)

  (defstruct circle
    radius)

  (defun area (x)
    (cond ((rectangle-p x)
	   (* (rectangle-height x) (rectangle-width x)))
	  ((circle-p x)
	   (* pi (expt (circle-radius x) 2)))))
#+end_src

#+begin_src lisp
CL-USER> (let ((r (make-rectangle)))
	   (setf (rectangle-height r) 2)
	   (setf (rectangle-width r) 3)
	   (area r))
6  
#+end_src


Using CLOS we might write an equivalent program:
#+caption: Area with classes and methods.
#+label: prog:clos
#+begin_src lisp
  (defclass rectangle ()
    (height width))

  (defclass circle ()
    (radius))

  (defmethod area ((x rectangle))
    (* (slot-value x 'height) (slot-value x 'width)))

  (defmethod area ((x circle))
    (* pi (expt (slot-value x 'radius) 2)))
#+end_src

#+begin_src lisp
CL-USER> (let ((r (make-instance 'rectangle)))
           (setf (slot-value r 'height) 2
                 (slot-value r 'width) 3)
           (area r))
6  
#+end_src

In the object-oriented model, the program gets broken up into several distinct *methods*, each one intended for certain kinds of arguments. The two methods in Program [[prog:non-clos]] implicitly define an =area= function that works just like the one in Program [[prog:clos]]. When we call =area=, Lisp looks at the type of the argument and invokes the corresponding method.


Together with this way of breaking up functions into distinct methods, object-oriented programming implies *<<<inheritance>>>* - both of slots and methods. The empty list given as the second argument in the two =defclasses= in Program [[prog:clos]] is a list of superclasses. Suppose we define a new class of colored objects, and then a class of colored circles that has both =colored= and =circle= as superclasses:
#+begin_src lisp
  (defclass colored ()
    (color))

  (defclass colored-circle (circle colored)
    ())
#+end_src

When we make instance of =colored-circle=, we will see two kinnds of inheritance:
1. Instances of =colored-circle= will have two slots: =radius=, which is inherited from the =circle= class, and =color=, which is inherited from the =colored= class.
2. Because there is no area method defined explicitly for instances of =colored-circle=, if we call =area= on an instance of =colored-circle=, we will get the method defined for the =circle= class.



In practical terms, object-oriented programming means organizing a program in terms of methods, classes, instances, and inheritance. Why would you want to organize programs this way? One of the claims of the object-oriented approach is that it makes programs easier to *change*. If we want to change the way objects of class =ob= are displayed, we just change the =display= method of the =ob= class. If we want to make a new class of objects like =obs= but different in a few respects, we can create a subclass of =ob=; in the subclass, we change the properties we want, and all the rest will be inherited by default from the =ob= class. And if we just want to make a single =ob= that behaves differently from the rest, we can create a new child of =ob= and modify the child's properties directly. If the program was written carefully to begin with, we can make all these types of modifications without even looking at the rest of the code.





** DONE Classes and Instances
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 06:40]
:END:
In Section [[*Structures]] we went through two steps to create structures: we called =defstruct= to lay out the form of a structure, and a specific function like =make-point= to make them. Creating instances requires two analogous steps. First we define a class, using =defclass=:
#+begin_src lisp
  (defclass circle ()
    (radius center))
#+end_src

To make instances of this class, instead of calling a specific function, we call the general =make-instance= with the class name as the first argument:
#+begin_src lisp
CL-USER> (setf c (make-instance 'circle))
#<CIRCLE {1004E39A23}>
#+end_src

To set the slots in this in this instance, we can use =setf= with =slot-value=:
#+begin_src lisp
CL-USER> (setf (slot-value c 'radius) 1)
1  
#+end_src
The values of unitialized slots are undefined.
#+begin_src lisp
CL-USER> (slot-value c 'center)
; Evaluation aborted on #<UNBOUND-SLOT CENTER {1005442393}>.  
#+end_src



** DONE Slot Properties
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 06:40]
:END:

The third argument to =defclass= must be a list of slot definitions. The simplest slot definition is a symbol representing its name. In the general case, a slot definition can be a list of name followed by one or more perperties. Properties are specified like keyword arguments.


By defining an =:accessor= for a slot, we implicitly define a function that refers to the slot, making it unnecessary to call =slot-value=. If we update our difinition of the =circle= class as follows:
#+begin_src lisp
  (defclass circle ()
    ((radius :accessor circle-radius)
     (center :accessor circle-center)))
#+end_src
then we will be able to refer to the slots as =circle-radius= and =circle-center= respectively:
#+begin_src lisp
CL-USER> (setf c (make-instance 'circle))
#<CIRCLE {10017B5E53}>
CL-USER> (setf (circle-radius c) 1)
1
CL-USER> (circle-radius c)
1  
#+end_src
By specifying a =:writer= or a =:reader= instead of an =:accessor=, we could get just the first half of this behavior or just the second.




To specify a default value for a slot, we have to give an =:initform= argument. If we want to be able to initialize the slot in the call to =make-instance=, we define a parameter name as an =:initarg= (Initarg names are usually keywords, but they don't have to be.). With both added, our class definition might become:
#+begin_src lisp
(defclass circle ()
  ((radius :accessor circle-radius
           :initarg :radius
           :initform 1)
   (center :accessor circle-center
           :initarg :center
           :initform (cons 0 0))))
#+end_src
Now when we make an instance of a =circle= we can either pass a value for a slot using the keyword parameter defined as the slot's =:initarg=, or let the value default to that of the slot's =:initform=:
#+begin_src lisp
CL-USER> (setf c (make-instance 'circle :radius 3))
#<CIRCLE {10027AAFE3}>
CL-USER> (circle-radius c)
3
CL-USER> (circle-center c)
(0 . 0)  
#+end_src


We can specify that some slots are to be shared — that is, their value is the same for every instance. We do this by declaring the slot to have =:allocation :class=. (The alternative is for a slot to have =:allocation :instance=, but since this is the default there is no need to say so explicitly.) When we change the value of such a slot in one instance, that slot will get the same value in every other instance. So we would want to use shared slots to contain properties that all the instances would have in common.



For example, suppose we wanted to simulate the behavior of a flock of tabloids. In our simulation we want to be able to represent the fact that when one tabloid takes up a subject, they all do. We can do this by making all the instances share a slot. If the =tabloid= class is defined as follows:
#+begin_src lisp
  (defclass tabloid ()
    ((top-story :accessor tabloid-story
		:allocation :class)))  
#+end_src
then if we make two instances of tabloids, whatever becomes front-age news to one instantly becomes front-page news to the other:
#+begin_src lisp
CL-USER> (setf daily-blab (make-instance 'tabloid)
               unsolicited-mail (make-instance 'tabloid))
#<TABLOID {1003BBAD13}>
CL-USER> (setf (tabloid-story daily-blab) 'adultery-of-senator)
ADULTERY-OF-SENATOR
CL-USER> (tabloid-story unsolicited-mail)
ADULTERY-OF-SENATOR  
#+end_src



The =:documentation= property, if given, should be a string to serve as the slot's documentation. By specifying a =:type=, you are promising that the slot will only contain elements of that type. 


** DONE Superclasses
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 06:43]
:END:
The second argument to =defclass= is a list of superclasses. A class inherits the union of the slots of its superclasses.
#+begin_src lisp
  (defclass circle ()
    ((radius :accessor circle-radius
	     :initarg :radius
	     :initform 1)
     (center :accessor circle-center
	     :initarg :center
	     :initform (cons 0 0))))


  (defclass graphic ()
    ((color :accessor graphic-color
	    :initarg :color)
     (visible :accessor graphic-visible
	      :initarg :visible
	      :initform t)))


  (defclass screen-circle (circle graphic)
    ())  
#+end_src
then instances of =screen-circle= will have four slots, two inherited from each superclass. A class does not have to create any new slots of its own; =screen-circle= exists just to provide something instantiable that inherits from both =circle= and =graphic=.


The accessors and initargs work for instances of screen-circle just as they would for instances of circle or graphic:
#+begin_src lisp
CL-USER> (graphic-color (make-instance 'screen-circle
                                       :color 'red
                                       :radius 3))
RED  
#+end_src
We can add or change the properties to the slots. For example we can cause every =screen-circle= to have some default initial =color= by specifying an initform this slot in the =defclass=:
#+begin_src lisp
  (defclass screen-circle (circle graphic)
    ((color :initform 'purple)))  
#+end_src

#+begin_src lisp
CL-USER> (graphic-color (make-instance 'screen-circle))
PURPLE  
#+end_src

#+begin_src lisp
  (defclass screen-circle (circle graphic)
    ((color :initform 'purple)
     (radius :initform 3)))
#+end_src

#+begin_src lisp
CL-USER> (circle-radius (make-instance 'screen-circle))
3  
#+end_src


** DONE Precedence
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 13:46]
:END:

When there are methods defined for several of the classes to which an instance belongs, Lisp needs some way to decide which one to use. The point of <<<precedence>>> is to ensure that this happpens in an intuitive way.


For every class there is a <<<precedence list>>>: an ordering of itself and its superclasses from most specific to least specific.
#+begin_src lisp
  (defclass sculpture () (height width depth))

  (defclass status (sculpture) (subject))

  (defclass metalwork () (metal-type))

  (defclass casting (metalwork) ())

  (defclass cast-status (status casting) ())
#+end_src

Figure [[fig:class-hierarchy]] contains a newwork representing =cast-status= and its superclass.
#+caption: Class hierarchy
#+label: fig:class-hierarchy
[[file:images/class-hierarchy.png]]



To build such a network for a class, start at the bottom with a node representing that class. Draw links upward to nodes representing each of its immediate superclasses, laid out from left to right as they appeared in the calls to =defclass=. Repeat the process for each of those nodes,and soon,until you reach classes whose only immediate superclass is =standard-object= - that is, classes for which the second argument to =defclass= was =()=. Create links from those classes up to a node representing =standard-object=, and one from that node up to another node representing the class =t= . The result will be a network that comes to a point at both top and bottom, as in Figure [[fig:class-hierarchy]].


The precedence list for a class can be computed by traversing the corresponding networks as follows:
1. Start at the bottom of the network.
2. Walk upward, always taking the leftmost unexplored branch.
3. If you are about to enter a node and you notice another path entering the same node from the right, then instead of entering the node, retrace your steps until you get to a node with an unexplored path leading upward. Go back to step 2.
4. When you get to the node representing =t=, you're done. The order in which you first entered each node determines its place in the precedence list.


One of the consequences of this definition (in fact, of rule 3) is that no class appears in the precedence list before one of its subclasses.


The arrows in Figure [[fig:class-hierarchy]] show how it would be traversed. The precedence list determined by this graph is: =cast-statue, statue, sculpture, casting, metalwork, standard-object, t=. Sometimes the word specific is used as shorthand to refer to the position of a class in a given precedence list. The preceding list runs from most specific to least specific.



The main point of precedence is to decide what method gets used when a generic function is invoked. The other time precedence matters is when a slot with a given name is inherited from several superclasses. 




** DONE Generic Functions
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 13:56]
:END:
A <<<generic function>>> is a function made up of one or more methods. Methods are defined with =defmethod=, which is similar in form to =defun=:
#+begin_src lisp
  (defmethod combine (x y)
    (list x y))
#+end_src

Now =combine= has one method. If we call =combine= at this point, we will get the two arguments in alist:
#+begin_src lisp
CL-USER> (combine 'a 'b)
(A B)  
#+end_src


So far we haven't done anything we could not have done with a normal function. The unusual thing about a generic function is that we can continue to add new methods for it.


First, we define some classes for the new methods to refer to:
#+begin_src lisp
  (defclass stuff ()
    ((name :accessor name
	   :initarg :name)))

  (defclass ice-cream (stuff) ())

  (defclass topping (stuff) ())
#+end_src


Now here is a second method for =combine=:
#+begin_src lisp
  (defmethod combine ((ic ice-cream) (top topping))
    (format nil "~A ice-cream with ~A topping."
	    (name ic)
	    (name top)))
#+end_src

In this call to =defmethod= the parameters are <<<specialized>>>: each one appears in a list with the name of a class. The <<<specialization>>> of a method indicate the kinds of arguments to which it applies. The method just defined will only be used if the arguments to =combine= are instances of =ice-cream= and =topping= respectively.



How does Lisp decide which method to use when a generic function is called? It will use the most specific method for which the classes of the arguments match the specializations of the parameters. Which means that if we call =combine= with an instance of =ice-cream= and an instance of =topping=, we'll get the method we just defined:
#+begin_src lisp
CL-USER> (combine (make-instance 'ice-cream :name 'fig)
                  (make-instance 'topping :name 'treacle))
"FIG ice-cream with TREACLE topping."  
#+end_src


But with any other arguments, we'll get the first method we defined:
#+begin_src lisp
CL-USER> (combine 123 'cheese)
(123 CHEESE)  
#+end_src

Because neither of the parameters of the first method is specialized, it will always get last priority, yet will always get called if no other method does. An unspecialized method acts as a safety net, like an =otherwise= clause in a =case= expression.


Any combination of the parameters in a method can be specialized. In this method only the first argument is:
#+begin_src lisp
  (defmethod combine ((ic ice-cream) x)
    (format nil "~A ice-cream with ~A."
	    (name ic)
	    x))
#+end_src


If we call =combine= with an instance of =ice-cream= and an instance of =topping=, we'll still get the method that's looking for both, because it's more specific:
#+begin_src lisp
CL-USER> (combine (make-instance 'ice-cream :name 'grape)
                  (make-instance 'topping :name 'marshmallow))
"GRAPE ice-cream with MARSHMALLOW topping."  
#+end_src



However, if the first argument is =ice-cream= and the second argument is anything but =topping=, we'll get the method we just defined above:
#+begin_src lisp
CL-USER> (combine (make-instance 'ice-cream :name 'clam)
                  'reluctance)
"CLAM ice-cream with RELUCTANCE."  
#+end_src




When a generic function is called, the arguments determine a set of one or more <<<applicable methods>>>. A method is applicable if the arguments in the call come within the specializations of all its parameters.


If there are no applicable methods we get an error. If there is just one, it is called. If there is more than one, the most specific gets called. The most specific applicable method is determined based on the class precedence for the arguments in the call. The arguments are examined left to right. If the first parameter of one of the applicable methods is specialized on a more specific class than the first parameters of the other methods, then it is the most specific method. Ties are broken by looking at the second argument, and so on. We can't go through all the arguments and still have a tie, because then we would have two methods with exactly the same specializations. That's impossible because the definition of the second would overwrite the first.



Methods don't have to be specialized on classes defined by =defclass=. They can also be specialized on types (or more precisely, the classes that mirror types). Here is a method for combine that's specialized on numbers:
#+begin_src lisp
  (defmethod combine ((x number) (y number))
    (+ x y))
#+end_src


Methods can even be specialized on individual objects, as determined by =eql=:
#+begin_src lisp
  (defmethod combine ((x (eql 'powder)) (y (eql 'spark)))
    'boom)
#+end_src
Specializations on individual objects take precedence over class specializations.



Methods can have parameter lists as complex as ordinary Common Lisp functions, but the parameter lists of all the methods that compose a generic function must be congruent. They must have the same number of required parameters, the same number of optional parameters (if any), and must either all use =&rest= or =&key=, or all not use them. The following pairs of parameter lists are all congruent,
#+begin_src lisp
  (x)  (a)
  (x &optional y)  (a &optional b)
  (x y &rest z)  (a b &key c)
  (x y &key z)  (a b &key c d)
#+end_src
and the following pairs are not:
#+begin_src lisp
  (x)  (a b)
  (x &optional y)  (a &optional b c)
  (x &optional y)  (a &rest b)
  (x &key x y)  (a)
#+end_src


Only required parameters can be specialized. Thus each method is uniquely identified by its name and the specializations of its required parameters. If we define another method with the same qualifiers and specializations, it overwrites the original one. So by saying
#+begin_src lisp
  (defmethod combine ((x (eql 'powder)) (y (eql 'spark)))
    'kaboom)
#+end_src
we redefine what combine does when its arguments are =powder= and =spark=.


** DONE Auxiliary Methods
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 15:19]
:END:
Methods can be augmented by *<<<auxiliary methods>>>*, including before-, after-, and around-methods. <<<Before-methods>>> allow us to say, "But first, do this." They are called, most specific first, as a prelude to the rest of the method call. <<<After-methods>>> allow us to say, "P.S. Do this too." They are called, most specific last, as an epilogue to the method call. Between them, we run what has till now been considered just the method, but is more precisely known as the *<<<primary method>>>*. The value of this call is the one returned, even if after-methods are called later.



Before- and after-methods allow us to wrap new behavior around the call to the primary method. <<<Around-methods>>> provide a more drastic way of doing the same thing. If an <<<around-method>>> exists, it will be called instead of the primary method. Then, at its own discretion, the around-method may itself invoke the primary method (via the function =call-next-method=, which is provided just for this purpose).



This is called <<<standard method combination>>>. In standard method combination, calling a generic function invokes
1. The most specific around-method, if there is one.
2. Otherwise, in order,
   a) All before-methods, from most specific to least specific.
   b) The most specific primary method.
   c) All after-methods, from least specific to most specific.


The value returned is the value of the around-method (in case 1) or the value of the most specific primary method (in case 2).



Auxiliary methods are defined by putting a quilifiying keyword after the method name in the call to =defmethod=. If we define a primary =speak= method for the =speaker= class as:
#+begin_src lisp
  (defclass speaker () ())

  (defmethod speak ((s speaker) string)
    (format t "~A" string))
#+end_src
then calling =speak= with an instance of =speaker= just prints the second argument:
#+begin_src lisp
CL-USER> (speak (make-instance 'speaker) "I'm hungry")
I'm hungry
NIL  
#+end_src

By defining a subclass =intellectual=, which wraps before- and after-methos around the primary =speak= method:
#+begin_src lisp
  (defclass intellectual (speaker) ())

  (defmethod speak :before ((i intellectual) string)
    (princ "Perhaps "))

  (defmethod speak :after ((i intellectual) string)
    (princ " in some sense."))
#+end_src
we can create a subclass of speakers that always have the last and the first word:
#+begin_src lisp
CL-USER> (speak (make-instance 'intellectual)
                "I'm hungry")
Perhaps I'm hungry in some sense.
NIL  
#+end_src



As the preceding outline of standard method combination noted, all before- and after-methods get called. So if we define before- or after-methods for the speaker superclass:
#+begin_src lisp
  (defmethod speak :before ((s speaker) string)
    (princ "I think "))
#+end_src
they will get called in the middle of the sandwich:
#+begin_src lisp
CL-USER> (speak (make-instance 'intellectual)
                "I'm hungry")
Perhaps I think I'm hungry in some sense.
NIL  
#+end_src

Regardless of what before- or after-methods get called, the value returned by the generic function is the value of the most specific primary method — in this case, the =nil= returned by =format=.


This changes if there are around-methods. If there is an around-method specialized for the arguments passed to the generic function, the around-method will get called first, and the rest of the methods will only run if the around-method decides to let them. An around- or primary method can invoke the next method by calling =call-next-method=. Before doing so, it can use =next-method-p= to test whether there is a next method to call.



With around-methods we can define another, more cautious, subclass of =speaker=:
#+begin_src lisp
  (defclass courtier (speaker) ())

  (defmethod speak :around ((c courtier) string)
    (format t "Does the King believe that ~A? " string)
    (if (eql (read) 'yes)
	(if (next-method-p) (call-next-method))
	(format t "Indeed, it is a preposterous idea.~%"))
    'bow)
#+end_src

When the first argument to =speak= is an instance of the =courtier= class, the courtier's tongue is now guarded by the around-method:
#+begin_src lisp
CL-USER> (speak (make-instance 'courtier) "kings will last")
Does the King believe that kings will last? yes
I think kings will last
BOW
CL-USER> (speak (make-instance 'courtier) "the world is round")
Does the King believe that the world is round? no
Indeed, it is a preposterous idea.
BOW
#+end_src


Unlike before- and after-methods, the value returned by the around- method is returned as the value of the generic function.



** DONE Method Combination
:LOGBOOK:
- State "DONE"       from              [2024-03-08 Fri 17:06]
:END:
In standard method combination the only primary method that gets called is the most specific (though it can call others vis =call-next-method=). Instead we might like to be ale to combine the results of all applicable primary methods.


It's possible to define methods the are combined in other ways - for example, for a generic function to return the sum of all the applicable primary methods. <<<Operator method combination>>> can be understood as if it resulted in the evaluation of a Lisp expression whose first element was some operators, and whose arguments were called to the applicable primary methods, in order of specificity. If we defined the =price= generic function to combine values with +, and there were no applicable around-methods, it would behave as though it were defined:
#+begin_src lisp
  (defun price (&rest args)
    (+ (apply (most-specific-primary-method) args)
       ...
       (apply (least-specific-primary-method) args)))
#+end_src

If there are applicable around-methods, they take precedence, just as in standard method combination. Under operator method combination, an around-method can still call the next method via =call-next-method=. However, primary methods can no longer use =call-next-method=.


We can specify the type of method combination to be used by a generic function with a =:method-combination= clause in a call to =defgeneric=:
#+begin_src lisp
  (defgeneric price (x)
    (:method-combination +))
#+end_src

Now the =price= method will use + method combination; any =defmethod= for =price= must have + as the second argument. If we defind some classes with prices:
#+begin_src lisp
  (defclass jacket () ())

  (defclass trousers () ())

  (defclass suit (jacket trousers) ())

  (defmethod price + ((jk jacket))
    350)

  (defmethod price + ((tr trousers))
    200)
#+end_src
then when we ask for the price of an instance of suit, we get the sum of the applicable =price= methods:
#+begin_src lisp
CL-USER> (price (make-instance 'suit))
550  
#+end_src



The following symbols can be used as the second argument to =defmethod= or in the =:method-combination= option to =defgeneric=:
#+begin_src lisp
  +  and  append  list  max  min  nconc  or  progn
#+end_src
You can also use =standard=, which yields standard method combination.



Once you specify the method combination a generic function should use, all methods for that function must use the same kind. Now it would cause an error if we tried to use another operator (or =:before= or =:after=) as the second argument in a =defmethod= for =price=.
#+begin_example
invalid method error for
  #1=#<STANDARD-METHOD COMMON-LISP-USER::PRICE :BEFORE (SUIT) {1004CD7633}>
method:
  The method #1# on
  #<STANDARD-GENERIC-FUNCTION COMMON-LISP-USER::PRICE (3)>
  has an invalid qualifier.

  The method combination type + was defined with the short form
  of DEFINE-METHOD-COMBINATION and so requires all methods have
  either the single qualifier + or the single qualifier :AROUND.
   [Condition of type SIMPLE-ERROR]
#+end_example

If we want to change the method combination of =price=, we must remove the whole generic function by calling =fmakunboud=.




** DONE Encapsulation
:LOGBOOK:
- State "DONE"       from              [2024-03-09 Sat 12:20]
:END:
object-oriented languages often provide some way of distinguishing between the actual representation of objects and the interface they present to the world. Hiding implementation details brings two advantages: you can change the implementation without affecting the object's outward appearance, and you prevent objects from being modified in potentially dangerous ways. Hidden details are sometimes said to be *<<<encapsulated>>>*.


Although <<<encapsulation>>> is often associated with object-oriented programming, the two ideas are really seprate. You can have either one without the other. For example:
#+begin_src lisp
  (let ((counter 0))
    (defun our-reset ()
      (setf counter 0))
    (defun our-stamp ()
      (setf counter (+ counter 1))))  
#+end_src

#+begin_src lisp
CL-USER> (list (our-stamp) (our-stamp) (our-reset) (our-stamp))
(1 2 0 1) 
#+end_src
The function =our-stamp= and =our-reset= work by sharing a counter, but calling code does not need to know about this counter, nor can it modify it directly.



In Common Lisp, packages are the standard way to distinguish between public and private information. To restrict access to something, we put it in a separate package, and only export the names that are part of the external interface.


We can encapsulate a slot by exporting the name of the methods that can modify it, but not the name of the slot itself. For example, we could define a =counter= class and associated =increment= and =clear= methods as follows:
#+begin_src lisp
  (defpackage "CTR"
    (:use "COMMON-LISP")
    (:export "COUNTER" "INCREMENT" "CLEAR"))

  (in-package ctr)

  (defclass counter ()
    ((state :initform 0)))

  (defmethod increment ((c counter))
    (incf (slot-value c 'state)))

  (defmethod clear ((c counter))
    (setf (slot-value c 'state) 0))
#+end_src
Under this definition, code outside the package would be able to make instances of =counter= and call =increment= and =clear=, but would not have legitimate access to the name =state=.
#+begin_src lisp
  CL-USER> (import 'ctr)
  T
  CL-USER> (setf c (make-instance 'ctr:counter))
  #<CTR:COUNTER {1002753AD3}>
  CL-USER> (slot-value c 'state)
  ; Evaluation aborted on #<SIMPLE-ERROR "~@<When attempting to ~A,
  ; the slot ~S is missing from the object ~S.~@[~a~]~@:>" {1002754993}>.  
#+end_src


If you want to do more than just distinguish between the internal and external interface to a class, and actually make it impossible to reach the value stored in a slot, you can do that too. Simply =unintern= its name after you've defined the code that needs to refer to it:
#+begin_src lisp
  (unintern 'state)
#+end_src
Then there is no way, legitimate or otherwise, to refer to the slot from any package.




* DONE Structure

Section [[*Why Lisp Has No Pointers]] explained how Lisp's use of pointers allows us to put any value anywhere. This statement is full of possibilities, not all of them good. For example, an object can be an element of itself. Whether this is good or bad depends on whether it's done on purpose or by accident.


** DONE <<<Shared Structure>>>

Lists can share conses in common. In the simplest case, one list might be part of another.
#+begin_src lisp
CL-USER> (setf part (list 'b 'c))
(B C)
CL-USER> (setf whole (cons 'a part))
(A B C)
#+end_src
The first cons is part of (in face, is the cdr of) the second. In situations like this, we say that the two lists *<<<share structure>>>***. The underlying structure of the two lists is represented in Figure [[fig:shared-structure]].

#+caption: Shared structure
#+label: fig:shared-structure
[[file:images/shared-structure.png]]


The predicate =tailp= detects this situation. It takes two lists and returns true if the first would be encountered on traversing the second:
#+begin_src lisp
CL-USER> (tailp part whole)
T  
#+end_src


We could imagine it written as:
#+begin_src lisp
  (defune our-tailp (x y)
    (or (eql x y)
	(and (consp y)
	     (our-tailp x (cdr y)))))
#+end_src
As the definition suggests, every list is a stail of itself, and =nil= is a tail of every proper list.



In the more complex case, two lists can share structure without either one being a tail of the other. This happens when they share a tail in common, as in Figure [[fig:shared-tail]]. We can create this situation as follows:
#+begin_src lisp
  (setf part (list 'b 'c)
	whole1 (cons 1 part)
	whole2 (cons 2 part))
#+end_src

#+caption: A shared tail
#+label: fig:shared-tail
[[file:images/shared-tail.png]]


Now =whole1= and =whole2= share structure without either list being part of the other.


When we have nested lists, it's important to distinguish between the lists <<<sharing structure>>>, and their elements sharing structure. *<<<Top-level list structure>>>* refers to the conses that make up a list, not including any conses that make up its elements. Figure [[fig:top-level-list-structure]] shows the top-level list structure of a nested list.
#+caption: Top-level list structure
#+label: fig:top-level-list-structure
[[file:images/top-level-list-structure.png]]




Whether two conses share structure depends on whether we are considering them as lists or as trees. Two nested lists may share structure as trees, without sharing structure as lists. The following code creates the situation shown in Figure [[fig:shared-subtree]], in which two lists contain the same list as an element:

#+begin_src lisp
  (setf element (list 'a 'b)
	holds1 (list 1 element 2)
	holds2 (list element 3))
#+end_src

#+caption: Shared subtree
#+label: fig:shared-subtree
[[file:images/shared-subtree.png]]


Although the second element of =holds1= shares structure with (in fact, is identical) to the first element of =holds2=, =holds1= and =holds2= do not share structure as lists. Two lists only <<<share structure as lists>>> if they share top-level list structure, which =holds1= and =holds2= do not.



If we want to avoid sharing structure, we can do it by copying. The function =copy-list=, which could be defined as
#+begin_src lisp
  (defun our-copy-list (lst)
    (if (null lst)
	nil
	(cons (car lst) (our-copy-list (cdr lst)))))
#+end_src
will return a list that doesn't share top-level list structure with the original list.


The function =copy-tree=, which might be defined as
#+begin_src lisp
  (defun our-copy-tree (tr)
    (if (atom tr)
	tr
	(cons (our-copy-tree (car tr))
	      (our-copy-tree (cdr tr)))))
#+end_src
will return a list that doesn't even share tree structure with original list. Figure shows the different between calling =copy-list= and =copy-tree= on a nested list.


[[file:images/two-kinds-of-copying.png]]

** DONE Modification

Why would we want to avoid sharing structure? Up to this point, the issue of shared structure has been just an intellectual exercise. It would not have made any difference to any program we've written so far. It is when we modify objects that shared structure becomes an issue. If two lists share structure, and we modify one, then we may inadvertently be modifying the other.
#+begin_src lisp
CL-USER> (setf whole (list 'a 'b 'c)
               tail (cdr whole))
(B C)
CL-USER> (setf (second tail) 'e)
E
CL-USER> tail
(B E)
CL-USER> whole
(A B E)  
#+end_src

It's not always an error to modify two things at once. Sometimes it might be what you want. But when it happens inadvertently, modifying shared structure can cause some very subtle bugs. Lisp programmers learn to be aware of shared structure, and to suspect it immediately in certain kinds of errors. When a list mysteriously changes for no apparent reason, it is probably because you changed something else that shared structure with it.


It is not the shared structure that's dangerous, but the changing. To be on the safe side, simply avoid using =setf= (or related operators like =pop=, =rplaca=, etc.) on list structure, and you won't run into any problems. If some application absolutely requires you to modify list structure, find out where the lists come from to make sure that they don't share structure with anything that shouldn't be changed. If they do, or if you can't predict where the lists will come from, make the changes to a =copy=.





You have to be doubly careful when you are calling a function written by someone else. Until you know otherwise, consider the possibility that anything you pass to the function
1. could have destructive operations done to it, and/or
2. could be saved somewhere, so that if you later modified the object, you would also be modifying part of something that the other code was maintaining for its own use.

In both cases, the solution is to pass a copy.



In Common Lisp, a function called in the course of travering list structrue (e.g. an argument to =mapcar= or =remove-if=) is not allowed to modify the structure being traversed. The consequence of evaluating such code are undefined.


** DONE Destructive Functions
Common Lisp includes several function that are allowed to modify list structure. This functions are destructive for reason of efficiency. Though they may recycle conses passed to them as arguments, they are not meant to be called for their side-effects.


For example, =delete= is a destructive version of =remove=. While it is allowed to trash the list passed to it as an argument, it doesn't promise to do anything. This is what happens in most implementations:
#+begin_src lisp
CL-USER> (setf lst '(a r a b i a))
(A R A B I A)
CL-USER> (delete 'a lst)
(R B I)
CL-USER> lst
(A R B I)  
#+end_src

As with =remove=, if you want side-effects, you should use =setf= with the return value:
#+begin_src lisp
  (setf lst (delete 'a lst))
#+end_src


As an example of how destructive functions recycle the lists passed to them, consider =nconc= (The =n= originally stood for "non-consing." Several destructive functions have names beginning with =n=.), the destructive version of =append=. This two-argument version shows clearly how two existing lists are sewn together:
#+begin_src lisp
  (defun nconc2 (x y)
    (if (consp x)
	(progn
	  (setf (cdr (last x)) y)
	  x)
	y))
#+end_src
We go the last cons cell in the first list, and set its cdr to point to the second list.
#+begin_src lisp
CL-USER> (setf lst1 '(a b c))
(A B C)
CL-USER> (setf lst2 '(1 2 3))
(1 2 3)
CL-USER> (append lst1 lst2)
(A B C 1 2 3)
CL-USER> lst1
(A B C)
CL-USER> lst2
(1 2 3)
CL-USER> (nconc lst1 lst2)
(A B C 1 2 3)
CL-USER> lst1
(A B C 1 2 3)
CL-USER> lst2
(1 2 3)  
#+end_src



The function =mapcan= is like =mapcar=, but splices together the values returned by the function (which must be lists) using =nconc=:
#+begin_src lisp
  CL-USER> (setf lst1 '(a b c))
  (A B C)
  CL-USER> (setf lst2 '(1 2 3 4))
  (1 2 3 4)
  CL-USER> (mapcar #'list lst1 lst2)
  ((A 1) (B 2) (C 3))
  CL-USER> lst1
  (A B C)
  CL-USER> lst2
  (1 2 3 4)  
  CL-USER> (mapcan #'list lst1 lst2)
  (A 1 B 2 C 3)
  CL-USER> lst1
  (A B C)
  CL-USER> lst2
  (1 2 3 4)
#+end_src

This function might be defined as follows:
#+begin_src lisp
  (defun our-mapcan (fn &rest lsts)
    (apply #'nconc (apply #'mapcar fn lsts)))
#+end_src
Use =mapcan= with caution, because it is destructive. It splices together the returned lists with =nconc=, so they had better not be needed elsewhere.



This kind of function is particularly useful in problems that can be understood as collecting all the nodes at one level of some tree. For example, if =children= returns a list of someone's children, then we could define a function to return a list of someone's grandchildren as follows:
#+begin_src lisp
  (defun grandchildren (x)
    (mapcan #'(lambda (c)
		(copy-list (children c)))
	    (children x)))
#+end_src
This function calls =copy-list= on the assumption that =children= returns a list that's stored somewhere, instead of making a fresh one.


A nondestructive variant of =mapcan= might be defined:
#+begin_src lisp
  (defun mappend (fn &rest lsts)
    (apply #'append (apply #'mapcar fn lsts)))
#+end_src

If we used =mappend=, we could leave out the =copy-list= in the definition of =grandchildren=:
#+begin_src lisp
  (defun grandchildren (x)
    (mappend #'children (children x)))
#+end_src


** DONE Circular Structure
There are two kinds of circular lists. The most useful are those whose top-level list structure is a loop. Such lists are called *<<<cdr-circular>>> because the loop passes through the cdr part of a cons.



To make a cdr-circular list with one element, you set the cdr of a list to be the list itself:
#+begin_src lisp
CL-USER> (setf x '(a))
(A)
CL-USER> (progn (setf (cdr x) x) nil)
NIL  
#+end_src


If Lisp tries to print the list we just create, it would usually display =(a a a , ad infininum)= (or stucked). But if we set the global =*print-circle*= to =t=, objects will be displayed in a way that can represent circular structure:
#+begin_src lisp
CL-USER> (setf *print-circle* t)
T
CL-USER> x
#1=(A . #1#)  
#+end_src
If you need to, you can use the #n= and #n# read-macro to represent shared structure youself.



cdr-circular lists could be useful - to represent buffers or pools, for example. The following function would take any non-cdr-circular, nonempty list and convert it into  cdr-circular list with the same elements:
#+begin_src lisp
    (defun circular (lst)
      (setf (cdr (last lst)) lst))
#+end_src


The other kind of circular lists are *<<<car-circular>>> lists. A car-circular list is a tree that has itself as a subtree. They are so called because the loop passes through the car of some cons. Here we create a car-circular list whose second element is itself:
#+begin_src lisp
CL-USER> (let ((y (list 'a)))
           (setf (car y) y)
           y)
#1=(#1#)  
#+end_src


Figure [[fig:circular-lists]] shows the resulting structure. Though car-circular, this list is a proper list. Cdr-circular lists are never proper lists, but car-circular lists can be, unless they are disqualified for some other reason.
#+caption: Circular lists
#+label: fig:circular-lists
[[file:images/circualr-lists.png]]


A list could be both car-circular and cdr-circular. The car and the cdr of this cons will be the cons itself:
#+begin_src lisp
CL-USER> (let ((c (cons 1 1)))
           (setf (car c) c
                 (cdr c) c)
           c)
#1=(#1# . #1#)  
#+end_src
It's hard to imagine what the use of such an object would be. Indeed, the main reason to know about circular lists may be to avoid creating them by accident, because most functions that traverse list structure will go into an infinite loop if they are given a list that's circular in the dimension they traverse.




Circular structure can be an issue for other kinds of objects besides lists. For example, an array can contain itself as an element:
#+begin_src lisp
CL-USER> (setf *print-array* t)
T
CL-USER> (let ((a (make-array 1)))
           (setf (aref a 0) a)
           a)
#1=#(#1#)  
#+end_src
Indeed, just about anything that can have elements can have itself as an element.



It's quite common to have circularities involving structures created by =defstruct=. For example, a structure =c= representing an element in a tree might have a =parent= field that contained another structure =p= whose =child= field in turn contained =c=:
#+begin_src lisp
CL-USER> (progn
           (setf *print-circle* t)
           (defstruct my-elt
             (parent nil)
             (child nil))
           (let ((c (make-my-elt))
                 (p (make-my-elt)))
             (setf (my-elt-parent c) p
                   (my-elt-child p) c)
             c))
#1=#S(MY-ELT :PARENT #S(MY-ELT :PARENT NIL :CHILD #1#) :CHILD NIL)  
#+end_src

* DONE Speed

Lisp is really two languages: a language for writting fast programs and a language for writting programs fast. In the early stages of a program you can trade speed for convenience. Then once the structure of your program begins to crystallize, you can refine critical portions to make them faster.



It's difficult to give general advice about optimization, because of the variation between Common Lisp implementations. A change that made your program faster in one implementation might make it slower in another. This is something that comes with the territory. The more powerful the language, the further you are from the machine, and the further you are from the machine, the greater the chance that different implementations will take different paths toward it. So while there are some techniques that are almost certain to make your programs faster, the aim of this chapter will be to suggest rather than to prescribe.



** DONE The <<<Bottleneck Rule>>>
Three points can be made about optimization, regardless of the implementation:
1. It should be focused on bottlenecks.
2. It should not begin too early.
3. It should begin with algorithms.


Probably the most important thing to understand about optimization is that programs tend to have a few bottlenecks that account for a great part of the execution time. According to Knuth, "most of the running time in non-IO-bound programs is concentrated in about 3% of the source text." Optimizing these parts of the program will make it run noticeably faster; optimizing the rest of the program will be a waste of time in comparison.




So the crucial *first* step in optimizing any program is to find the bottlenecks. Many Lisp implementations come with <<<profilers>>> that can watch a program as it's running and report the amount of time spent in each part. A profiler is a valuable tool — perhaps even a necessity — in producing the most efficient code.


A corollary of the bottleneck rule is that one should not put too much effort into optimization early in a program's life. Knuth puts the point even more strongly: "Premature optimization is the root of all evil (or at least most of it) in programming." It's hard to see where the real bottlenecks will be when you've just started writing a program, so there's more chance you'll be wasting your time. Optimizations also tend to make a program harder to change.




You end up with better programs if each task can be emphasized at the appropriate time. One of the benefits of Lisp is that it lets you work at a range of different speeds: you can write slow code fast or fast code slow. In the early stages of a program you tend to work in the former mode, then as optimization takes precedence you switch into the latter. As the bottleneck rule suggests, this is a more effective use of your time. In a very low-level language, like assembler, you are essentially optimizing every line of the program. Most of this effort is wasted, because the bottlenecks only make up a small part of it. A more abstract language allows you to spend a greater proportion of your time on the bottlenecks, and so get most of the gains with a fraction of the effort.



When you do turn to optimization, begin at the top. That is, make sure that you're using the most efficient algorithm before you resort to low-level coding tricks. The potential gains are greater — perhaps great enough that you won't have to resort to coding tricks after all. This rule has to be balanced against the preceding one, though. Sometimes decisions about algorithms have to be made early.


** DONE Compilation

Five parameters control the way your code is compiled:
- speed :: refers to the speed of the code produced by the compiler;
- compilation-speed :: refers to the speed at which your program will be compiled;
- safety :: refers to the amount of error-checking done in the object code;
- space :: refers to the size and memory needs of the object code;
- debug :: refers to the amount of information retained for debugging.




The compilation parameters are not real variables. They are assigned weights from 0 (unimportant) to 3 (most important) in declarations. If a major bottleneck occurred in the inner loop of some function, we might add a declaration like the following:
#+begin_src lisp
  (defun bottleneck (...)
    (do (...)
	(...)
      (do (...)
	  (...)
	(declare (optimize (speed 3) (safety 0)))
       ...)))
#+end_src
Generally you would not want to add such declarations until the code was finished and tested.



To ask globally for the fastest possible code, regardless of the consequences, you could say:
#+begin_src lisp
  (declaim (optimize (speed 3)
		     (compilation-speed 0)
		     (safety 0)
		     (debug 0)))
#+end_src
This would be a drastic step, and probably not even necessary, given the bottleneck rule.



One particularly important kind of optimization done by Lisp compilers is the optimization of tail calls. Giving =speed= the maximum weight will ensure tail call optimization by any compiler capable of it.

A call is a <<<tail call>>> if nothing remians to be done after it returns. The following function returns the length of a list:
#+begin_src lisp
  (defun length/r (lst)
    (if (null lst)
	0
	(1+ (length/r (cdr lst)))))
#+end_src

The recursive call is not a tail call, because after it returns, its value has to be passed to =1+=. However, this version is tail-recursive,
#+begin_src lisp
  (defun length/tr (lst)
    (labels ((len (lst acc)
	       (if (null lst)
		   acc
		   (len (cdr lst) (1+ acccc)))))
      (len lst 0)))
#+end_src
or more precisely, the local function =len= is, because nothing more has to happen after the recursive call returns. Instead of building its return value on the way back up the recursion, like =length/r=, it accumulates the return value in the additional parameter =acc= on the way down.


A good compiler can compile a tail call into a goto, and so can compile a tail-recursive function into a loop. In typical machine language code, when control arrives for the first time at the segment of instructions representing =len=, there is information on the stack saying what to do upon returning. Because nothing remains to be done after the recursive call, this information remains valid for the second invocation as well: what we are supposed to do on returning from the second invocation is simply to return from the first invocation. So after setting the parameters to their new values, we can just jump back to the beginning of the function and act as if this were the second invocation. There is no need to do a real function call.


Another way to have the abstraction of function calls without the cost is to have functions compiled inline. This is valuable mainly for small functions, where the machinery of calling the function could entail more work than the function itself performs. For example, the following function tells whether something is a list of a single element:
#+begin_src lisp
      (declaim (inline single?))

      (defun single? (lst)
	(and (consp lsp)
	     (null (cdr lst))))
#+end_src
Because this function is globally decalred inline, a reference to =single?= within a compiled function should no longer require a real function call. If we define a function that calls it,
#+begin_src lisp
    (defun foo (x)
      (single? (bar x)))
#+end_src
then when =fool= is compiled, the code for =single?= should be compiled right into it, just as if we had written
#+begin_src lisp
  (defun foo (x)
    (let ((lst (bar x)))
      (and (consp lst)
	   (null (cdr lst)))))
#+end_src
in the first place.


There are two limitations on inline compilation. Recursive functions can't be inlined. And if an inlined function is redefined, we have to recompile any function that calls it, or the calling function will still reflect the old definition.


Different Lisp compilers do varying amounts of optimiztion. If you want to see the code your compiler produce for a function, try calling =disassemble=. This function takes a function or function name and displays its compiled form.
#+begin_src lisp
CL-USER> (defun foo (x)
           x)
FOO
CL-USER> (disassemble 'foo)
; disassembly for FOO
; Size: 16 bytes. Origin: #x2277EF0D                          ; FOO
; 0D:       498B4510         MOV RAX, [R13+16]                ; thread.binding-stack-pointer
; 11:       488945F8         MOV [RBP-8], RAX
; 15:       488BE5           MOV RSP, RBP
; 18:       F8               CLC
; 19:       5D               POP RBP
; 1A:       C3               RET
; 1B:       CC10             INT3 16                          ; Invalid argument count trap
NIL  
#+end_src
Even if what you see is completely incomprehensible, you can still use =disassemble= to determine whether declarations are being used: compile two version of the function, one with the declaration and one without, and see if the code displayed by =disassemble= differs between the two. You can use a similar technique to see if functions are being compiled inline. In either case, be sure to set the compilation parameters beforehand to get the fatest code.


** DONE Type Declarations
In most languages, you have to declare the type of each variable, and the variable can only hold values of that type. Such a language is said to be *<<<strong typed>>>*. As well as being a lot of work for the programmer, this approach imposes restrictions on what you can do. In such a language it's hard to write functions that work for different kinds of arguments, or to have data structure that contain different kinds of elements. The advantage of this approach is that whenever the compiler sees an addition, for example, it knows beforehand what kind of addition is involved. If both arguments are integers, it can hard-wire an integer addition in the object code.


Common Lisp uses a more flexible approach called manifest typing (There are two ways to describe Lisp's approach to typing: by where the type information is kept, and by when it is used. Manifest typing means that the type information is attached to the data objects, and <<<run-time typing>>> means that type information is used at run-time. In practice they mean the same thing.). Values have types, not variables. Variables can hold objects of any type.


If we left it at that, we would have to pay for this flexibility in speed. Because it can take several different types of numbers, + would have to look at the types of each of its arguments, and decide what kind of addition to do at run-time.




If we just want an integer addition after all, this is an inefficient way to get it. So Common Lisp's approach is: tell me as much as you know. If we know ahead of time that both of the arguments in some addition will be fixnums, then we can declare them to be such, and the compiler will hard-wire an integer addition just as in C.



So the difference between the two approaches to typing need not entail any difference in speed. It's just that strong typed approach makes <<<type declarations>>> mandatory, and manifest typing doesn't. In Common Lisp, type declarations are completely optional. They may make a program faster, but (unless incorrect) they will not change its behavior.



<<<Global declarations>>> are made with =declaim=, which should be followed by one or more declaration forms. A type declaration is a list containing the symbol =type=, followed by a type name and the name of one or more variables. So to declare the type of a global variable, one could say:
#+begin_src lisp
  (declaim (type fixnum *count*))
#+end_src
In ANSI Common Lisp you can omit the =type= and say simply:
#+begin_src lisp
  (declaim (fixnum *count*))
#+end_src



<<<Local declarations>>> are made with =declare=, which takes the same arguments as =declaim=. Declarations can begin any body of code where variables have just been created: in =defun=, =let=, =do=, and so on. To declare a functions's parameters to be =fixnum=, we would say:
#+begin_src lisp
  (defun ploy (a b x)
    (declare (fixnum a b c))
    (+ (* a (expt x 2)) (* b x)))
#+end_src
A variable name in a type declaration refers to the variable with that name in the context where the declaration occurs.


You can also declare that the value of ean expression will be of a certain type, by using =the=. If we know beforehand that =a, b= and =x= will not only be fixnums, but that they will be small enough fixnums that all the intermediate results will be fixnums, we can say:
#+begin_src lisp
  (defun ploy (a b x)
    (declare (fixnum a b x))
    (the fixnum (+ (the fixnum (* a (the fixnum (expt x 2))))
		   (the fixnum (* b x)))))
#+end_src
This looks awkward. Fortunately, there are two reasons that you rarely have to clutter up your numeric code with =the= in this way. One is that it's easy to use macros to insert such declarations for you. The other is that some implementations use special tricks to make fixnum arithmetic fast without declarations.




There are a great many types in Common Lisp — a potentially unlimited number, considering that you can define new types yourself. However, declarations only matter for a few. When does it pay to make type declarations? There are two general rules:

1. It pays to declare the types of arguments to functions that work for arguments of several different types (but not all types). If you knew that the arguments in a call to + would always be fixnums, or that the first argument in a call to =aref= would always be a particular kind of array, it could pay to make a type declaration.
2. It is usually only worthwhile to make declarations for types near the bottom of the type hierarchy: declaring something to be of type =fixnum= or =simple-array= might be useful, but declaring something to be of type =integer= or =sequence= probably would not.



Type declarations are particularly important for the contents of complex objects, including arrays, structures, and instances. Such declarations can improve efficiency in two ways: as well as allowing the compiler to determine the types of arguments to functions, they make it possible to represent these objects more efficiently in memory.


If nothing is known about the type of elements an array will contain, it has to be represented in memory as a block of pointers. But if it is known that the array will only contain, say, double-floats, then the array can be represented as a block of actual double-floats. This way the array will take less space, because we no longer need a pointer to point to each of the double-floats, and access will be faster, because we don't have to follow pointers to read and write elements.


You can specify the kind of values that an array will contain by giving the =:element-type= argument to =make-array=. Such an an array is called a specialized array. Figure [[fig:element-type]] shows what would happen, in most implementations, as a result of evaluating the following code:
#+begin_src lisp
  (setf x (vector 1.234d0 2.345d0 3.456d0)
	y (make-array 3 :element-type 'double-float)
	(aref y 0) 1.234d0
	(aref y 1) 2.345d0
	(aref y 2) 3.456d0)
#+end_src
#+caption: Effect of specifying element type
#+label: fig:element-type
[[file:images/effect-of-specifying-element-type.png]]

Each rectangle in Figure [[fig:element-type]] represents a word of memory. The two arrays each consist of a header of unspecified length, followed by some representation of the tree elements. In =x=, each element is represented by a pointer. All three pointers happen to point to double-floats at the moment, but we could store objects of any type in this vector. In =y=, each element is an actual double-float. This is fater and takes less space, but it means that the vector can only hold double-floats. Note that we use aref to refer to the elements of y. A specialized vector is no longer a simple vector, so we can no longer use svref to refer to its elements.


As well as specifying the element type of an array when you create it, you should declare the dimensions and element type of an array in code that uses it. A full vector declaration would look like:
#+begin_src lisp
  (declare (type (vector fixnum 20) v))
#+end_src
This declare =v= to be a vector of length 20, specialized for fixnums.


The most general form of array declaration consists of the array type followed by the element type and a list of dimensions:
#+begin_src lisp
  (declare (type (simple-array fixnum (4 4)) arr))
#+end_src
This declare that =arr= will be $4\times 4$ simple array specialized for fixnums.




The following code shows how to create a $1000 \times 1000$ array of single-floats, and how to write a function to sum the elements of such an array. Arrays are
stored in row-major order and should be traversed that way when possible.
#+begin_src lisp
  (setf a (make-array '(1000 1000)
		      :element-type 'single-float
		      :initial-element 1.0s0))


  (defun sum-elts (a)
    (declare (type (simple-array single-float (1000 1000)) a))
    (let ((sum 0.0s0))
      (declare (type single-float sum))
      (dotimes (r 1000)
	(dotimes (c 1000)
	  (incf sum (aref a r c))))
      sum))
  
#+end_src


We use =time= to compare the performance of =sum-elts= with and without declarations. The =time= macro displays some (implementation-dependent) measure of how long it takes to evaluate an expression. It's only meaningful to time compiled functions.
#+begin_src lisp
CL-USER> (time (sum-elts a))
Evaluation took:
  0.001 seconds of real time
  0.001061 seconds of total run time (0.001060 user, 0.000001 system)
  100.00% CPU
  2,870,804 processor cycles
  0 bytes consed
  
1000000.0  
#+end_src

If we take the type declarations out of =sum-elts= and recompile it, the same computation takes more time:
#+begin_src lisp
CL-USER> (time (sum-elts a))
Evaluation took:
  0.008 seconds of real time
  0.008579 seconds of total run time (0.008564 user, 0.000015 system)
  112.50% CPU
  23,358,101 processor cycles
  0 bytes consed
  
1000000.0
#+end_src


The importance of type declarations, especially for arrays and numbers, cannot be overemphasized. 


** DONE Garbage Avoidance
As Lisp allows you to delay thinking about the types of variables, it also allows you to delay thinking about memory allocation. In the early stages of a program it frees your imagination not to have to think about (or deal with bugs involving) memory allocation. As a program matures, it can rely less on dynamic allocation and so become faster.


However, consing less does not always make a program faster. In Lisp implementations with bad garbage collectors, programs that cons a lot tend to run slowly. Until recently, most Lisp implementations have had bad garbage collectors, and so it has become a tradition that efficient programs should cons as little as possible. Recent developments have turned this conventional wisdom on its head. Some implementations now have such sophisticated garbage collectors that it is faster to cons up new objects and throw them away than it is to recycle them.


This section introduces some ways to make programs cons less. Whether consing less will make your programs run faster depends on the implementation. Again, the best advice is to try it and see.




There are a lot of things you can do to reduce consing. Some of them won't affect the shape of your program at all. For example, one of the easiest steps you can take is to use destructive functions. The following table lists some commonly used functions and their destructive counterparts.
| SAFE              | DESTRUCTIVE       |
|-------------------+-------------------|
| append            | nconc             |
| reverse           | nreverse          |
| remove            | delete            |
| remove-if         | delete-if         |
| remove-duplicates | delete-duplicates |
| subst             | nsubst            |
| subst-if          | nsubst-if         |
| union             | nunion            |
| intersection      | nintersection     |
| set-difference    | nset-difference   |
When you know it's safe to modify a list, you can use =delete= instead of =remove=, =nreverse= instead of =reverse=, and so on.


If you want to eliminate consing entirely, you don't have to give up the possibility of creating things on the fly. What you have to avoid is allocating space for them on the fly, and reclaiming it by garbage collection. The general solution is to allocate blocks of memory beforehand, and explicitly recycle used blocks yourself. Beforehand could mean at compile-time, or in some initialization routine. When spped begins to matter depends on the application.




For example, when circumstances allow us to impose a limit on the size of a stack, we could have the stack grow and shrink along a pre-allocated vector, instead of building it out of conses. Common Lisp has built-in support for using vectors as stacks. If we give the optional =fill-pointer= argument to =make-array=, we will get a vector that seems to be expandable. The first argument to =make-array= specifies the amount of storage to be allocated for the vector, but the =fill-pointer=, when given, specifies the initial effective length:
#+begin_src lisp
CL-USER> (setf *print-array* t)
T
CL-USER> (setf vec (make-array 10 :fill-pointer 2
				  :initial-element nil))
#(NIL NIL)  
#+end_src
The vector we just made will seem to sequence functions as if it had only two elements,
#+begin_src lisp
CL-USER> (length vec)
2  
#+end_src
but it will be able to grow until it has up to ten. Because =vec= has a fill pointer, we can use the functions =vector-push= and =vector-pop= to push and pop elements as if it where a list:
#+begin_src lisp
CL-USER> (vector-push 'a vec)
2
CL-USER> vec
#(NIL NIL A)
CL-USER> (vector-pop vec)
A
CL-USER> vec
#(NIL NIL)  
#+end_src
When we called =vector-push=, it incremented the fill pointer and returned its old value. As long as the fill pointer is less than the initial argument to =make-array=, we can push new elements onto the vector; when it runs out of space, =vector-push= will return =nil=. We could push up to eight more elements onto =vec= at this point.


One disadvantage of vectors with fill pointers is that they are no longer simple vectors. We have to use =aref= instead of =svref= to refer to elements. This cost has to be balanced against the potential gains.



In applications that involve very long sequences, you may want to use =map-into= instead of =map=. Instead of a sequence type, =map-into= takes as its first argument an actual sequence to hold the result. This sequence can be one of those from which the arguments to the function are taken. So, for example, if you want to increment each element of a vector =v=, you might write:
#+begin_src lisp
  (setf v (map-into v #'1+ v))
#+end_src


Another way to avoid garbage collection is to encourage the compiler to allocate objects on the stack instead of the heap. When you know that you will only need something temporarily, you may be able to avoid allocating space for it on the heap by declaring it to have <<<dynamic extent>>>.


By giving a dynamic extent declaration for a variable, you're saying that the variable's value need not last any longer than the variable does. When could the value last longer than the variable? Here's an example:
#+begin_src lisp
  (defun our-reverse (lst)
    (let ((rev nil))
      (dolist (x lst)
	(push x rev))
      rev))
#+end_src
In =our-reverse=, the list passed as an argument will be accumulated in reverse order in =rev=. When the function returns, the variable =rev= will go away. However, the list that is its value will persist: it is sent back to the calling function, where who knows what fate awaits it.



In contrast, consider the following implementation of =adjoin=:
#+begin_src lisp
  (defun our-adjoin (obj lst &rest args)
    (if (apply #'member obj lst args)
	lst
	(cons obj lst)))
#+end_src
In this case, we can see from the definition of the function that the list in =args= is going nowhere. It need not last longer than the variable itself. This is the kind of situation where it would make sense to make a dynamic extent declaration. If we add such a declaration,
#+begin_src lisp
  (defun our-adjoin (obj lst &rest args)
    (declare (dynamic-extent args))
    (if (apply #'member obj lst args)
	lst
	(cons obj lst)))
#+end_src
then the compiler is free (but not required) to allocate space for =args= on the stack, where it will be automatically discarded on return from =our-adjoin=.



** DONE Fast Operators

The beginning of this chapter described Lisp as two different languages. In one sense this is literally true. If you look closely at the design of Common Lisp, you can see that some features are intended mainly for speed, and others mainly for convenience.



For example, there are three functions you could use to retrieve the element at a given position in a vector: =elt=, =aref=, and =svref=. Such variety exists to allow you to squeeze as much performance out of a program as possible. So if you can use =svref=, do. Conversely, a part of a program where speed is important probably should not be calling =elt= , which works for both arrays and lists.


Instead of calling =elt= on a list, you can call =nth=, which is specifically for lists. Yet there is only a single function, =length=, for finding the length of any sequence. Why doesn't Common Lisp provide a separate version for lists? Because if your program is finding the lengths of lists, it's already lost, as far as speed is concerned. In this case, as in many others, the design of the language suggests what is fast and what isn't.


Another pair of similar functions are =eql= and =eq=. The former is the default predicate for testing identity, but the latter is faster if you know that the arguments won't be characters or numbers. Two objects are =eq= when they have the same location in memory. Numbers and characters may not be associated with any particular memory location, so =eq= does not apply to them (though in most implementations it does work for fixnums). For arguments of any other kind, =eq= will return the same value as =eql=.


It's always fastest to compare objects using =eq=, because all Lisp has to do is compare the pointers to them. In an =eq= hash table, =gethash= can just hash on pointers, without even looking at what they point to. Access is not the only thing to consider, however; =eq= and =eql= hash tables incur extra costs under copying garbage collection algorithms because they have to be rehashed after a GC. If this becomes a problem, the best solution may be to use an =eql= hash table with fixnums as keys.



Calling =reduce= can be a more efficient alternative to =apply= when the function in question has a rest parameter. For example, instead of something like
#+begin_src lisp
  (apply #'+ '(1 2 3))
#+end_src
it can be more efficient to say:
#+begin_src lisp
  (reduce #'+ ' (1 2 3))  
#+end_src


Not only does it help to call the right functions, it helps to call them the right way. Rest, optional, and keyword parameters are expensive. With ordinary parameters, the arguments in a function call are simply left by the caller where the callee knows to look for them. But other kinds of parameters involve processing at run-time. Keyword parameters are the worst. For built-in functions, good compilers take special measures to compile calls with keyword arguments into fast code. But in your own functions it is just as well to avoid using them in speed-critical parts of a program. It is also wise not to push large numbers of arguments into rest parameters, if this can be avoided.


Individual compilers sometimes perform their own particular optimizations. For example, some compilers can optimize =case= statements where the keys are integers in a narrow range. Check your user's manual for hints about such implementation-specific optimizations.



** DONE Two-Phase Development
In applications where speed is paramount, you may want to rewrite part of a Lisp program in a lower-level language like C or assembler. You can use this technique with programs written in any language — critical parts of C programs are often rewritten in assembler — but the more abstract the language, the greater the benefits of developing programs in two phases.


Common Lisp does not prescribe a way of integrating code written in other languages. This is left up to the implementation, but almost all implementations provide some way to do it.


It may seem wasteful to write a program in one language and then to rewrite part of it in another. In fact, experience has shown this to be a good way to develop software. It can be easier to aim for functionality first, and then for speed, than to try to achieve both at the same time.



If programming were an entirely mechanical process — a matter of simply translating specifications into code — it would be reasonable to do everything in a single step. But programming is never like that. No matter how precise the specifications, programming always involves a certain amount of exploration — usually a lot more than anyone had anticipated.

It might seem that if the specifications were good, programming would simply be a matter of translating them into code. This is a widespread misconception. Programming necessarily involves exploration, because specifications are necessarily vague. If they weren't vague, they wouldn't be specifications.



In other fields, it may be desirable for specifications to be as precise as possible. If you're asking for a piece of metal to be cut to a certain shape, it's probably best to say exactly what you want. But this rule does not extend to software, because programs and specifications are made out of the same thing: text. You can't write specifications that say exactly what you want. If the specifications were that precise, then they would be the program.


In applications that involve a substantial amount of exploration, it can pay to separate implementation into two phases. And the medium you use in the first phase need not be the final one. It can be better to write a program in Lisp, and then rewrite it in C, than to try to write it in C from the start.

* Advanced Topics
Common Lisp is like an iceberg: a great part of its functionality is invisible to most users, who never need it. You may never need to define packages or read-macros of your own, but when you do, it is helpful to have examples to work from.



** DONE Type Specifiers
Types are not objects in Common Lisp. There is no object that corresponds to the type =integer=, for example. What we get from a function like =type-of=, and give as an argument to function like =typep=, is not a type, but a type specifier.


A <<<type specifier>>> is the name of a type. The simplest type specifiers are symbols like =integer=. These form a hierarchy in Common Lisp. At the top of the hierarchy is the type =t= - all objects are of type =t=. The hierarchy is a tree. There are two paths from =nil= to the top, for example: one through =atom=, and the other through =list= and =sequence=.


A type is really just a set of objects. Which means that there are as many types as there are sets of objects: an ifinite number. We can denote some of these sets with <<<atomic type specifiers>>>: =integer= denotes the set of all the integers. But we can also construct <<<compound type specifiers>>> that refer to any set of objects.


For example, if =a= and =b= are two type specifiers, the =(or a b)= denotes the union of the type denoted by =a= and that denoted by =b=.That is, an object is of type =(or a b)= if it is of type =a= or type =b=.
#+begin_src lisp
CL-USER> (mapcar #'(lambda (x)
		 (typep x '(or integer string)))
		 '(1 "hello"))
(T T)  
#+end_src



Some of the atomic type specifiers can also appear in compound type specifiers. To denote the set of integers between 1 and 100 inclusive, we could use:
#+begin_src lisp
  (integer 1 100)
#+end_src
Such a type specifier is said to denote a <<<finite type>>>.
#+begin_src lisp
CL-USER> (typep 3 '(integer 1 100))
T  
#+end_src

In a compound type specifier, you can leave some information unspecifed by using * in place of an argument. So
#+begin_src lisp
  (simple-array fixnum (* *))
#+end_src
describes the set of two-dimensional simple arrays specialized for fixnums, and
#+begin_src lisp
  (simple-array fixnum *)
#+end_src
describes the set (a supertype of the first) of simple arrays specialized for fixnums. Trailing asterisks can be dropped, so in the latter case we could have said:
#+begin_src lisp
  (simple-array fixnum)
#+end_src
If no argument are given to a compound type specifier, you can use an atom. So =simple-array= describes the set of all simple arrays.



If there is some compound type specifiers that you'd like to use repreatedly, you can define an abbreviation for it with =deftype=. This macro is jsut like =defmacro=, but expands into a type specifier instead of an expression. By saying,
#+begin_src lisp
  (deftype integer-or-string ()
    `(or integer string))
#+end_src
we define =proseq= as a new atomic type specifier:
#+begin_src lisp
CL-USER> (typep 1 'integer-or-string)
T
CL-USER> (typep "hello" 'integer-or-string)
T
#+end_src


If you define a type specifier to take arguments, the arguments are treated as forms (that is, not evaluated), just as with def macro. So
#+begin_src lisp
  (deftype multiple-of (n)
    (let ((my-predicate (gensym)))
      (setf (symbol-function my-predicate)
	    #'(lambda (x)
		(zerop (mod x n))))
      `(and integer (satisfies ,my-predicate))))

;  (deftype multiple-of (n)
;    `(and integer (satisfies (lambda (x)
;			       (zerop (mod x ,n))))))
#+end_src
defines =(multiple-of n)= as a specifier for all multiples of =n=:
#+begin_src lisp
CL-USER> (typep 12 '(multiple-of 4))
T
CL-USER> (typep 12 '(multiple-of 3))
T
CL-USER> (typep 12 '(multiple-of 5))
NIL  
#+end_src


Type specifiers are interpreted, and therefore slow, so you would generally be better off defining a function to make this kind of test.


** DONE Binary Streams
A <<<binary stream>>> is a source and/or destination of integers. You create a binary stream by specifying a subtype of =integer= — most often =unsigned-byte= — as the =:element-type= when you open the stream.

There are only two functions for I/O on binary streams, =read-byte= and =write-byte=. So here is how you might define a function to copy a file:
#+begin_src lisp
  (defun copy-file (from to)
    (with-open-file (in from :direction :input
			     :element-type 'unsigned-byte)
      (with-open-file (out to :direction :output
			      :element-type 'unsigned-byte)
	(do ((i (read-byte in nil -1) (read-byte in nil -1)))
	    ((minusp i))
	  (declare (fixnum i))
	  (write-byte i out)))))  
#+end_src



By specifying just =unsigned-byte= as the =:element-type=, you let the operating system choose the length of a byte. If you specifically wanted to read or write 7-bit integers, for example, you would use
#+begin_src lisp
  (unsigned-byte 7)
#+end_src
as the =:element-type= instead.



** Read-Macros


A macro character has a special meaning to =read=. Each such character has a function associated with it that tells =read= what to do when the character is encountered. You can change the function associated with an existing macro character, or define new read-macros of your own.


The function =set-macro-character= provides one way to define read-macros. It takes a character and a function, and thereafter when =read= encounter the character, it returns the result of calling the function.

One of the oldest read-macros in Lisp is ', the quote. We could define ti as:
#+begin_src lisp
  (set-macro-character #\'
		       #'(lambda (stream char)
			   (list (quote quote)
				 (read stream t nil t))))  
#+end_src
When =read= encounters an instance of ' in normal text, it will return the result of calling this function on the current stream and character. (The function ignores this second parameter, which will always be the quote character.) So when =read= see ='a=, it will return =(quote a)=.

Now we see the point of the last argument to =read=. It says whether the call to =read= occurs within a call to =read=. The arguments to =read= will be the same in nearly all read-macros: the stream; the second argument, =t=, which says that =read= should signal an error if the next thing it sees is the end-of-file; the third argument, which says what to return instead of generating an error is therefore irrelevant; and the fourth argument, =t=, which says that the call to =read= is a recursive one.


You can (with =make-dispatch-macro-character=) define your own dispatching macro characters, but since # is alreadly define as one, you may as well use it. Six combinations beginning with # are explicitly reserved for your use: =#!, #? #[, #], #{= and =#}=.



You can define new dispatching macro character combinations by calling =set-dispatch-macro-character=, which is like =set-macro-character= except that it takes two character arguments. This code defines =#?= as a read-macro that returns a list of integers.
#+begin_src lisp
  (set-dispatch-macro-character #\# #\?
				#'(lambda (stream char1 char2)
				    (list 'quote
					  (let ((lst nil))
					    (dotimes (i (+ (read stream t nil t) 1))
					      (push i lst))
					    (nreverse lst)))))
#+end_src

Now =#?n= will be read as a list of all the integers from 0 to n. For example:
#+begin_src lisp
CL-USER> #?7
(0 1 2 3 4 5 6 7)
#+end_src



After simple macro characters, the most commonly defined macro characters are list delimiters. Another character combination reserved for the user is =#{=. Here we define it as a more elaborate kind of left parenthesis:
#+begin_src lisp
  (set-macro-character #\}
		       (get-macro-character #\)))


  (set-dispatch-macro-character #\# #\{
				#'(lambda (stream char1 char2)
				    (let ((accum nil)
					  (pair (read-delimited-list #\} stream t)))
				      (do ((i (car pair) (+ i 1)))
					  ((> i (cadr pair))
					   (list 'quote (nreverse accum)))
					(push i accum)))))  
#+end_src

This defines an expression of the form =#{x y}= to read as a list of all the integers between x and y, inclusive:
#+begin_src lisp
CL-USER> #{2 9}
(2 3 4 5 6 7 8 9)  
#+end_src

The function =read-delimited-list= is provided just for such read-macros. Its first argument is the character to treat as the end of the list. For =}= to be recognized as a delimiter, it must first be given this role, hence the preliminary call to =set-macro-character=.




If you want to use a read-macro in the file in which it is defined, the definition should be wrapped in an =eval-when= expression, to ensure that it is evaluated at compile time. Otherwise the definition will be compiled, but not evaluated until the compiled file is loaded.



** Packages

A package is a Lisp object that maps names to symbols. The current package is always stored in the global variable =*package*=. When Common Lisp starts up, the current package will be =common-lisp-user=, informally known as the user package. The function =package-name= returns the name of a package, and =find-package= returns the package with a given name:
#+begin_src lisp
CL-USER> (package-name *package*)
"COMMON-LISP-USER"
CL-USER> (find-package "COMMON-LISP-USER")
#<PACKAGE "COMMON-LISP-USER">  
#+end_src


Usually a symbol is interned in the package that was current at the time it was read. The function =symbol-package= takes a symbol and returns the package in which it is interned.
#+begin_src lisp
CL-USER> (symbol-package 'sym)
#<PACKAGE "COMMON-LISP-USER">
#+end_src

Interestingly, this expression returns the value it does because the expression had to be read before it could be evaluated, and reading the expression caused =sym= to be interned.



For future use, let's give =sym= a value:
#+begin_src lisp
CL-USER> (setf sym 99)
99
#+end_src


Now we will create and switch to a new package:
#+begin_src lisp
CL-USER> (setf *package* (make-package 'mine
				       :use '(common-lisp)))
#<PACKAGE "MINE">  
#+end_src



At this point there should be eerie music, because we are in a different world: =sym= here is not what it used to be.
#+begin_src lisp
CL-USER> sym
;The variable SYM is unbound.
;   [Condition of type UNBOUND-VARIABLE]
; Evaluation aborted on #<UNBOUND-VARIABLE SYM {1001CD0463}>.  
#+end_src


Why did this happen? Because the =sym= we set to 99 above is a distinct symbol from =sym= here in =mine=. To refer to the original =sym= from outside the user package, we must prefix the package name and two colons:
#+begin_src lisp
MINE> common-lisp-user::sym
99  
#+end_src



So different symbols with the same print-name can coexist in different packages. There can be one =sym= in package =common-lisp-user= and another =sym= in package =mine=, and they will be distinct symbols. That's the point of packages. If you're writing your program in a separate package, you can choose names for your functions and variables without worrying that someone will use the same name for something else. Even if they use the same name, it won't be the same symbol.



It's usually bad style to use package prefixes with double colons. By doing so you are violating the modularity that packages are supposed to provide. If you have to use a double colon to refer to a symbol, it's because someone didn't want you to.


Usually one should only refer to symbols that have been exported. If we go back to the user package and export a symbol interned there,
#+begin_src lisp
MINE> (in-package common-lisp-user)
#<PACKAGE "COMMON-LISP-USER">
CL-USER> (export 'bar)
T
CL-USER> (setf bar 5)
5  
#+end_src
we cause it to be visible to other packages. Now when we return to =mine=, we can refer to =bar= with only a single colon, because it is a publicly available name:
#+begin_src lisp
CL-USER> (in-package mine)
#<PACKAGE "MINE">
MINE> common-lisp-user:bar
5  
#+end_src


By importing =bar= into =mine=, we can go one step further and make =mine= actually share the symbol =bar= with the user package:
#+begin_src lisp
MINE> (import 'common-lisp-user:bar)
T
MINE> bar
5  
#+end_src


After importing =bar= we can refer to it without any package qualifier at all. The two packages now share the same symbol; there can't be a distinct mine: bar.


What if there already was one? In that case, the call to =import= would have caused an error, as we see if we try to import =sym=:
#+begin_src lisp
MINE> (import 'common-lisp-user::sym)
; IMPORT COMMON-LISP-USER::SYM causes name-conflicts in
; #<PACKAGE "MINE"> between the following symbols:
;   COMMON-LISP-USER::SYM, MINE::SYM
;    [Condition of type SB-EXT:NAME-CONFLICT]
; See also:
;   Common Lisp Hyperspec, 11.1.1.2.5 [:section]

; Evaluation aborted on #<NAME-CONFLICT {1002B83C83}>.    
#+end_src



Before, when we tried unsuccessfully to evaluate =sym= in =mine=, we thereby caused a symbol =sym= to be interned there. It had no value and therefore generated an error, but the interning happened simply as a consequence of typing its name. So now when we try to import =sym= into =mine=, there is already a symbol there with the same name.



Another way to get access to symbols from another package is to use it:

#+begin_src lisp
MINE> (use-package common-lisp-user)
T
#+end_src

Now all symbols exported by the user package can be used without any qualifier in mine. (If sym had been exported by the user package, this call would also have generated an error.)




The package containing the names of built-in operators and variables is called =common-lisp=. Since we gave the name of this package in the =:use= argument of the =make-package= that created =mine=, all of Common Lisp's names will be visible here:
#+begin_src lisp
MINE> #'cons
#<FUNCTION CONS>  
#+end_src


Operations on packages are not usually done at the toplevel like this. More often the calls are contained in source files. Generally it will suffice to begin a file with a =defpackage= and an =in-package=.






** Conditions
In Common Lisp, <<<conditions>>> include errors and other situations that can arise at run-time. When a condition is signalled, the corresponding handler is invoked. The default handler for error conditions usually invokes a break-loop. But Common Lisp provides a variety of operators for signalling and handling conditions. It's possible to override the default handlers, oven wrtie new handlers of your own.



Most programmers will not deal with conditions directly. However, there are several layers of more abstract operators that use conditions, and to understand these operators it helps to know about the underlying mechanism.



Common Lisp has several operators for signalling errors. The most basic is =error=. One way to call it is to give it the same arguments that you might pass to =format=:
#+begin_src lisp
CL-USER> (error "Your report uses ~A as a verb." 'status)
; Evaluation aborted on #<SIMPLE-ERROR "Your report uses ~A as a verb." {1001B241D3}>.

Your report uses STATUS as a verb.
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [RETRY] Retry SLIME REPL evaluation request.
 1: [*ABORT] Return to SLIME's top level.
 2: [ABORT] abort thread (#<THREAD "new-repl-thread" RUNNING {10043D0503}>)

Backtrace:
  0: (SB-INT:SIMPLE-EVAL-IN-LEXENV (ERROR "Your report uses ~A as a verb." (QUOTE STATUS)) #<NULL-LEXENV>)
  1: (EVAL (ERROR "Your report uses ~A as a verb." (QUOTE STATUS)))
 --more--
  
#+end_src
Unless such a condition is handled, execution will be interrupted, as above.




More abstract operators for signalling errors include =ecase=, =check-type= and =assert=.


=ecase= is like =case=, but signals an error if none of the keys match:
#+begin_src lisp
CL-USER> (ecase 1 (2 3) (4 5))
; Evaluation aborted on #<SB-KERNEL:CASE-FAILURE expected-type: (MEMBER 2 4) datum: 1>.

1 fell through ECASE expression. Wanted one of (2 4).
   [Condition of type SB-KERNEL:CASE-FAILURE]

Restarts:
 0: [RETRY] Retry SLIME REPL evaluation request.
 1: [*ABORT] Return to SLIME's top level.
 2: [ABORT] abort thread (#<THREAD "new-repl-thread" RUNNING {1001CD8743}>)

Backtrace:
  0: ((LAMBDA ()))
  1: (SB-INT:SIMPLE-EVAL-IN-LEXENV (ECASE 1 (2 3) (4 5)) #<NULL-LEXENV>)
  2: (EVAL (ECASE 1 (2 3) (4 5)))
 --more--

#+end_src

The regular =case= will return =nil= if no key matches, but since it's bad style to take advantage of this return value, you might as well use =ecase= whenever you don't have an =otherwise= clause.



The =check-type= macro takes a place, a type name, and an optional string, and signals a <<<correctable error>>> if the value of the place is not of the designated type. The handler for a correctable error will give us the option of providing a new value:
#+begin_src lisp
CL-USER> (let ((x '(a b c)))
	   (check-type (car x) integer "an integer")
	   x)
Enter a form to be evaluated: 99


The value of (CAR X) is A, which is not an integer.
   [Condition of type SIMPLE-TYPE-ERROR]

Restarts:
 0: [STORE-VALUE] Supply a new value for (CAR X).
 1: [RETRY] Retry SLIME REPL evaluation request.
 2: [*ABORT] Return to SLIME's top level.
 3: [ABORT] abort thread (#<THREAD "new-repl-thread" RUNNING {1003140AC3}>)

Backtrace:
  0: (SB-KERNEL:CHECK-TYPE-ERROR (CAR X) A INTEGER "an integer")
  1: ((LAMBDA ()))
  2: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((X #)) (CHECK-TYPE (CAR X) INTEGER "an integer") X) #<NULL-LEXENV>)
  3: (EVAL (LET ((X #)) (CHECK-TYPE (CAR X) INTEGER "an integer") X))
 --more--
  
#+end_src

In this example, =(car x)= was set to the new value that we supplied, and the execution resumed, returning what it would have returned if =(car x)= had originally contained the value we supplied.



=check-type= is defined in terms of the more general =assert=, which takes a test expression and a list of one or more places, followed by the arguments you might give to error:
#+begin_src lisp
CL-USER> (let ((sandwich '(ham on rye)))
	   (assert (eql (car sandwich) 'chicken)
		   ((car sandwich))
		   "I want a ~A sandwich." 'chicken)
	   sandwich)



I want a CHICKEN sandwich.
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [CONTINUE] Retry assertion with new value for (CAR SANDWICH).
 1: [RETRY] Retry SLIME REPL evaluation request.
 2: [*ABORT] Return to SLIME's top level.
 3: [ABORT] abort thread (#<THREAD "new-repl-thread" RUNNING {1004FB0003}>)

Backtrace:
  0: (SB-KERNEL:ASSERT-ERROR (EQL (CAR SANDWICH) (QUOTE CHICKEN)) 1 (CAR SANDWICH) HAM ((CAR SANDWICH)) "I want a ~A sandwich." CHICKEN)
  1: ((LAMBDA ()))
  2: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((SANDWICH #)) (ASSERT (EQL # #) (#) "I want a ~A sandwich." (QUOTE CHICKEN)) SANDWICH) #<NULL-LEXENV>)
  3: (EVAL (LET ((SANDWICH #)) (ASSERT (EQL # #) (#) "I want a ~A sandwich." (QUOTE CHICKEN)) SANDWICH))
 --more--


  
#+end_src




It's also possible to establish new handlers, but most programmers will only take advantage of this possibility indirectly, by using macros like =ignore-errors=. This macro behaves like =progn= if none of its arguments cause an error. But if an error is signalled during the evaluation of one of its arguments, execution will not be interrupted. Instead the =ignore-errors= expression will immediately return two values: =nil= and the condition that was signalled.



For example, if at some point you want the user to be able to enter an expression, but you don't want an error to interrupt execution if the input is syntactically ill-formed, you could write:
#+begin_src lisp
  (defun user-input (prompt)
    (format t prompt)
    (let ((str (read-line)))
      (or (ignore-errors (read-from-string str))
	  nil)))
#+end_src


This function just return =nil= if the input contains syntax errors:
#+begin_src lisp
CL-USER> (user-input "Please type an expression> ")
Please type an expression> #123
NIL
CL-USER> (user-input "Please type an expression> ")
Please type an expression> (+ 1 1)
(+ 1 1)
#+end_src


* NEEDLES

** TO GET HELP INFORMATION

*** =documation=
#+begin_src lisp
CL-USER> (documentation '+ 'function)
"Return the sum of its arguments. With no args, returns 0."  
#+end_src

*** =describe=
#+begin_src lisp
CL-USER> (describe '+)
COMMON-LISP:+
  [symbol]

+ names a special variable:
  Declared type: T
  Declared always-bound.
  Value: (DESCRIBE 'MAP)
  Documentation:
    the value of the most recent top level READ

+ names a compiled function:
  Lambda-list: (&REST NUMBERS)
  Declared type: (FUNCTION (&REST NUMBER) (VALUES NUMBER &OPTIONAL))
  Derived type: (FUNCTION (&REST T) (VALUES NUMBER &OPTIONAL))
  Documentation:
    Return the sum of its arguments. With no args, returns 0.
  Known attributes: foldable, flushable, unsafely-flushable, movable, commutative
  Source file: SYS:SRC;CODE;NUMBERS.LISP
; No value
#+end_src

*** =inspect=
#+begin_src lisp
CL-USER> (inspect '+)

The object is a SYMBOL.
0. Name: "+"
1. Package: #<PACKAGE "COMMON-LISP">
2. Value: (DOCUMENTATION '+ 'FUNCTION)
3. Function: #<FUNCTION +>
4. Plist: NIL  
#+end_src




** FUNCTION BOUND PREDICATE
#+begin_src lisp
CL-USER> (fboundp '+)
#<FUNCTION +>  
#+end_src

** BOUND PREDICATE
#+begin_src lisp
CL-USER> (boundp '+)
T
CL-USER> (boundp *print-array*)
T  
#+end_src

** TYPE
#+begin_src lisp
CL-USER> (typep 123 'number)
T  
#+end_src

#+begin_src lisp
CL-USER> (type-of 123)
(INTEGER 0 4611686018427387903)  
#+end_src









