<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-13 Wed 09:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>common lisp</title>
<meta name="author" content="Mingming Li" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">common lisp</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org3c0f99d">1. <span class="done DONE">DONE</span> Introduction</a></li>
<li><a href="#orgcfe13c0">2. IDE</a>
<ul>
<li><a href="#orgc6cf2c8">2.1. SBCL</a></li>
<li><a href="#org2d7f336">2.2. Emacs</a></li>
<li><a href="#orge5355c5">2.3. SLIME</a>
<ul>
<li><a href="#org565ec5b">2.3.1. Top Level</a></li>
</ul>
</li>
<li><a href="#orgeadd3f8">2.4. Quicklisp</a>
<ul>
<li><a href="#org6af2844">2.4.1. Advanced Dependencies Management</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4fa68fd">3. <span class="done DONE">DONE</span> Welcome to Lisp</a>
<ul>
<li><a href="#org8db3367">3.1. Form&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></a></li>
<li><a href="#org650110c">3.2. Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></a></li>
<li><a href="#orgda1fe46">3.3. Data</a>
<ul>
<li><a href="#org54fb67d">3.3.1. Integer</a></li>
<li><a href="#orgd44b5c6">3.3.2. String</a></li>
<li><a href="#orga1a6cb0">3.3.3. Symbol</a></li>
<li><a href="#org4492f50">3.3.4. List</a></li>
</ul>
</li>
<li><a href="#orgd1a5f11">3.4. List Operations</a></li>
<li><a href="#org6488357">3.5. Truth</a></li>
<li><a href="#org10f56eb">3.6. Functions</a></li>
<li><a href="#org5142193">3.7. Recursion</a></li>
<li><a href="#org4c783aa">3.8. Reading Lisp</a></li>
<li><a href="#orgfd5458a">3.9. Input and Output</a></li>
<li><a href="#org7ec66f2">3.10. Variables</a></li>
<li><a href="#org407e03c">3.11. Assignment</a></li>
<li><a href="#org0b6ab5b">3.12. Functional Programming</a></li>
<li><a href="#org8d5bff7">3.13. Iteration</a></li>
<li><a href="#org486beba">3.14. Functions as Objects</a></li>
<li><a href="#org392e200">3.15. Types</a></li>
<li><a href="#org97f39c4">3.16. Summary</a></li>
</ul>
</li>
<li><a href="#orge4568be">4. <span class="done DONE">DONE</span> Lists</a>
<ul>
<li><a href="#org168270e">4.1. Conses</a></li>
<li><a href="#org586ba90">4.2. Equality</a></li>
<li><a href="#orgbde7013">4.3. Why Lisp Has No Pointers</a></li>
<li><a href="#orgaa88255">4.4. Building Lists</a></li>
<li><a href="#orga2a087c">4.5. Access</a></li>
<li><a href="#org9f207ed">4.6. Mapping Functions</a></li>
<li><a href="#orgf2a0887">4.7. Trees</a></li>
<li><a href="#orgeca0508">4.8. Understanding Recursion</a></li>
<li><a href="#orgb0f6df5">4.9. Sets</a></li>
<li><a href="#org814b16e">4.10. Sequences</a></li>
<li><a href="#orgc4fa51c">4.11. Stacks</a></li>
<li><a href="#org2c179f1">4.12. Dotted Lists</a></li>
<li><a href="#orgca464d3">4.13. Assoc-lists</a></li>
<li><a href="#orgbe3ea42">4.14. Garbage</a></li>
</ul>
</li>
<li><a href="#orgcb62d42">5. <span class="done DONE">DONE</span> Specialized Data Structures</a>
<ul>
<li><a href="#org16dc56f">5.1. <span class="done DONE">DONE</span> Arrays</a></li>
<li><a href="#org4879292">5.2. <span class="done DONE">DONE</span> Strings and Characters</a></li>
<li><a href="#org3127e44">5.3. <span class="done DONE">DONE</span> Sequences</a></li>
<li><a href="#org8c2276b">5.4. <span class="done DONE">DONE</span> Structures</a></li>
<li><a href="#orga400538">5.5. <span class="done DONE">DONE</span> Hash Tables</a></li>
</ul>
</li>
<li><a href="#org0ad3201">6. <span class="done DONE">DONE</span> Control</a>
<ul>
<li><a href="#orga58f047">6.1. <span class="done DONE">DONE</span> Blocks</a></li>
<li><a href="#org8bec33b">6.2. <span class="done DONE">DONE</span> Context</a></li>
<li><a href="#org1849038">6.3. <span class="done DONE">DONE</span> Conditionals</a></li>
<li><a href="#org0e8f6bc">6.4. <span class="done DONE">DONE</span> Iteration</a></li>
<li><a href="#org3e212d2">6.5. <span class="done DONE">DONE</span> Multiple Values</a></li>
<li><a href="#org9530600">6.6. <span class="done DONE">DONE</span> Aborts</a></li>
</ul>
</li>
<li><a href="#orgfdd9c66">7. <span class="done DONE">DONE</span> Functions</a>
<ul>
<li><a href="#orgd9c95f0">7.1. <span class="done DONE">DONE</span> Global Functions</a></li>
<li><a href="#org345e505">7.2. <span class="done DONE">DONE</span> Local Functions</a></li>
<li><a href="#org565058d">7.3. <span class="done DONE">DONE</span> Parameter Lists</a></li>
<li><a href="#org1766a92">7.4. <span class="done DONE">DONE</span> Utilities</a></li>
<li><a href="#org3256ab0">7.5. <span class="done DONE">DONE</span> Closures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></a></li>
<li><a href="#orga2ab504">7.6. <span class="done DONE">DONE</span> Dynamic Scope</a></li>
<li><a href="#org4dcd5e8">7.7. <span class="done DONE">DONE</span> Compilation</a></li>
<li><a href="#org4a7a7c9">7.8. <span class="done DONE">DONE</span> Using Recursion</a></li>
</ul>
</li>
<li><a href="#org48b97a3">8. <span class="done DONE">DONE</span> Input and Output</a>
<ul>
<li><a href="#orge6406f2">8.1. <span class="done DONE">DONE</span> Character Streams</a></li>
<li><a href="#org387c863">8.2. <span class="done DONE">DONE</span> Input</a></li>
<li><a href="#orgfadeb3c">8.3. <span class="done DONE">DONE</span> Output</a></li>
<li><a href="#org800cd4b">8.4. <span class="done DONE">DONE</span> Macro Characters</a></li>
</ul>
</li>
<li><a href="#org48b576e">9. <span class="done DONE">DONE</span> Symbols</a>
<ul>
<li><a href="#orgfefc506">9.1. <span class="done DONE">DONE</span> Symbol Names</a></li>
<li><a href="#org1a0c817">9.2. <span class="done DONE">DONE</span> Property Lists</a></li>
<li><a href="#org80d32df">9.3. <span class="done DONE">DONE</span> Symbols Are Big</a></li>
<li><a href="#orgae23d0a">9.4. <span class="done DONE">DONE</span> Creating Symbols</a></li>
<li><a href="#org4dfc6da">9.5. <span class="done DONE">DONE</span> Multiple Packages</a></li>
<li><a href="#orgadaea46">9.6. <span class="done DONE">DONE</span> Keywords</a></li>
<li><a href="#org904e3e3">9.7. <span class="done DONE">DONE</span> Symbols and Variables</a></li>
</ul>
</li>
<li><a href="#org0bb7a4e">10. <span class="done DONE">DONE</span> Numbers</a>
<ul>
<li><a href="#org3846853">10.1. <span class="done DONE">DONE</span> Types</a></li>
<li><a href="#org9e676bb">10.2. <span class="done DONE">DONE</span> Conversion and Extraction</a></li>
<li><a href="#orgccb80a7">10.3. <span class="done DONE">DONE</span> Comparison</a></li>
<li><a href="#org3ba4ee1">10.4. <span class="done DONE">DONE</span> Arithmetic</a></li>
<li><a href="#orgf6e3a6b">10.5. <span class="done DONE">DONE</span> Exponentiation</a></li>
<li><a href="#org18ef93a">10.6. <span class="done DONE">DONE</span> Trigonometric Functions</a></li>
<li><a href="#org7f1e0be">10.7. <span class="done DONE">DONE</span> Representation</a></li>
</ul>
</li>
<li><a href="#org98e5e98">11. <span class="done DONE">DONE</span> Macros</a>
<ul>
<li><a href="#orgd54d945">11.1. <span class="done DONE">DONE</span> Eval</a></li>
<li><a href="#orgd995a5b">11.2. <span class="done DONE">DONE</span> Macros&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></a></li>
<li><a href="#orga8a8fb4">11.3. <span class="done DONE">DONE</span> Backquote</a></li>
<li><a href="#org8877f83">11.4. <span class="done DONE">DONE</span> Macro Design</a></li>
<li><a href="#org5b09bd9">11.5. <span class="done DONE">DONE</span> Generalized Reference</a></li>
<li><a href="#org47ed6dc">11.6. <span class="done DONE">DONE</span> On Lisp</a></li>
</ul>
</li>
<li><a href="#org9952b68">12. <span class="done DONE">DONE</span> CLOS</a>
<ul>
<li><a href="#org67a23bd">12.1. <span class="done DONE">DONE</span> Object-Oriented Programming</a></li>
<li><a href="#org5f08a6c">12.2. <span class="done DONE">DONE</span> Classes and Instances</a></li>
<li><a href="#org1d458d4">12.3. <span class="done DONE">DONE</span> Slot Properties</a></li>
<li><a href="#org047ccc3">12.4. <span class="done DONE">DONE</span> Superclasses</a></li>
<li><a href="#org05326de">12.5. <span class="done DONE">DONE</span> Precedence</a></li>
<li><a href="#orgad2d2fc">12.6. <span class="done DONE">DONE</span> Generic Functions</a></li>
<li><a href="#orgdd5716b">12.7. <span class="done DONE">DONE</span> Auxiliary Methods</a></li>
<li><a href="#orga6672b7">12.8. <span class="done DONE">DONE</span> Method Combination</a></li>
<li><a href="#orga6bddc3">12.9. <span class="done DONE">DONE</span> Encapsulation</a></li>
</ul>
</li>
<li><a href="#org7769f2a">13. <span class="done DONE">DONE</span> Structure</a>
<ul>
<li><a href="#orgbab37f3">13.1. <span class="done DONE">DONE</span> Shared Structure</a></li>
<li><a href="#orgdc31a67">13.2. <span class="done DONE">DONE</span> Modification</a></li>
<li><a href="#org3eb41df">13.3. <span class="done DONE">DONE</span> Destructive Functions</a></li>
<li><a href="#org85dc6f5">13.4. <span class="done DONE">DONE</span> Circular Structure</a></li>
</ul>
</li>
<li><a href="#org92a99b0">14. <span class="done DONE">DONE</span> Speed</a>
<ul>
<li><a href="#orga9f92b2">14.1. <span class="done DONE">DONE</span> The Bottleneck Rule</a></li>
<li><a href="#org7693b3c">14.2. <span class="done DONE">DONE</span> Compilation</a></li>
<li><a href="#org97c3aa6">14.3. <span class="done DONE">DONE</span> Type Declarations</a></li>
<li><a href="#org3e32324">14.4. <span class="done DONE">DONE</span> Garbage Avoidance</a></li>
<li><a href="#org8b4dce5">14.5. <span class="done DONE">DONE</span> Fast Operators</a></li>
<li><a href="#orgcfb6765">14.6. <span class="done DONE">DONE</span> Two-Phase Development</a></li>
</ul>
</li>
<li><a href="#org9e814f2">15. Advanced Topics</a>
<ul>
<li><a href="#org1ac0d18">15.1. Type Specifiers</a></li>
<li><a href="#orgb83aa84">15.2. Binary Streams</a></li>
<li><a href="#org10d9b72">15.3. Read-Macros</a></li>
<li><a href="#orged2694e">15.4. Packages</a></li>
<li><a href="#org57f435a">15.5. Conditions</a></li>
</ul>
</li>
<li><a href="#org73f3296">16. NEEDLES</a>
<ul>
<li><a href="#orgd8c29ec">16.1. TO GET HELP INFORMATION</a>
<ul>
<li><a href="#orgb934ac6">16.1.1. <code>documation</code></a></li>
<li><a href="#orgc146f85">16.1.2. <code>describe</code></a></li>
<li><a href="#org34f9b36">16.1.3. <code>inspect</code></a></li>
</ul>
</li>
<li><a href="#org2badd12">16.2. FUNCTION BOUND PREDICATE</a></li>
<li><a href="#orgce5282a">16.3. BOUND PREDICATE</a></li>
<li><a href="#org86fae85">16.4. TYPE</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org3c0f99d" class="outline-2">
<h2 id="org3c0f99d"><span class="section-number-2">1.</span> <span class="done DONE">DONE</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Lisp has the following properites:<br />
</p>
<ul class="org-ul">
<li>Lisp is designed to evolve.<br /></li>
<li>Lisp gives you tools that other languages don't provide.<br /></li>
<li>Lisp is natrual for bottom-up programming.<br /></li>
<li>Lisp style depend less on planning and more on exploration.<br /></li>
</ul>

<p>
Programming languages teach you not to want what they cannot provide. You have to think in a language to write programs in it, and it's hard to want something you can't describe. That's also why a programming language can evolve is important.<br />
</p>


<p>
A new model of programming is that instead of hoping that people won't make mistakes, it tries to make the cost of mistakes very low.<br />
The cost of a mistake is the time required to correct it.<br />
</p>
</div>
</div>


<div id="outline-container-orgcfe13c0" class="outline-2">
<h2 id="orgcfe13c0"><span class="section-number-2">2.</span> IDE</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgc6cf2c8" class="outline-3">
<h3 id="orgc6cf2c8"><span class="section-number-3">2.1.</span> <a href="#org2e0b77e">SBCL</a></h3>
<div class="outline-text-3" id="text-2-1">
<p>
<a id="org2e0b77e">SBCL</a>: Steel Bank Common Lisp system.<br />
It is a common lisp implementation.<br />
</p>


<p>
On MacOS:<br />
</p>
<div class="org-src-container">
<pre class="src src-shell">brew install sbcl
</pre>
</div>
</div>
</div>

<div id="outline-container-org2d7f336" class="outline-3">
<h3 id="org2d7f336"><span class="section-number-3">2.2.</span> Emacs</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Emacs is the prefered eidtor for common lisp.<br />
</p>
</div>
</div>

<div id="outline-container-orge5355c5" class="outline-3">
<h3 id="orge5355c5"><span class="section-number-3">2.3.</span> <a href="#org2d691d6">SLIME</a></h3>
<div class="outline-text-3" id="text-2-3">
<p>
<a id="org2d691d6">SLIME</a>: The Superior Lisp Interaction Mode for Emacs<br />
<a href="#org2d691d6">SLIME</a> is a Emacs mode for Common Lisp development.<br />
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(use-package slime
  :ensure t
  :config
  (setq inferior-lisp-program "/opt/sbcl/bin/sbcl"))
</pre>
</div>
</div>

<div id="outline-container-org565ec5b" class="outline-4">
<h4 id="org565ec5b"><span class="section-number-4">2.3.1.</span> Top Level</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
After installed <a href="#org82bfe8d">package</a>, you can you <code>M-x slime</code> to invoke Lisp top-level.<br />
In top-level, you can use<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(declaim (sb-ext:muffle-conditions cl:warning))  
</pre>
</div>
<p>
to deprecate the warnnings.<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgeadd3f8" class="outline-3">
<h3 id="orgeadd3f8"><span class="section-number-3">2.4.</span> Quicklisp</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Quicklisp is more than a <a href="#org82bfe8d">package</a> manager, it is also a central repository (a dist) that ensures that all libraries build together.<br />
It provides its own dist but it is also possible to build our own.<br />
</p>

<p>
To install it:<br />
</p>
<ol class="org-ol">
<li><p>
Download the file.<br />
</p>
<div class="org-src-container">
<pre class="src src-shell">curl -O https://beta.quicklisp.org/quicklisp.lisp
</pre>
</div></li>
<li><p>
Enter a Lisp REPL (Read Eval Print Loop) and load this file.<br />
</p>
<div class="org-src-container">
<pre class="src src-shell">sbcl --load quicklisp.lisp  
</pre>
</div></li>
<li><p>
Run the command in REPL.<br />
</p>
<div class="org-src-container">
<pre class="src src-shell">(quicklisp-quickstart:install)
</pre>
</div>
<p>
This will create the <code>~/quicklisp/</code> directory, where Quicklisp will maintain its state and downloaded projects.<br />
</p></li>
<li><p>
(Optional) If you want Quicklisp to always be loaded in you Lisp session.<br />
</p>
<div class="org-src-container">
<pre class="src src-shell">(ql:add-to-init-file)
</pre>
</div>
<pre class="example" id="org1a9dc68">
To load a system, use: (ql:quickload "system-name")

To find systems, use: (ql:system-apropos "term")

To load Quicklisp every time you start Lisp, use: (ql:add-to-init-file)

For more information, see http://www.quicklisp.org/beta/
</pre></li>
</ol>
</div>


<div id="outline-container-org6af2844" class="outline-4">
<h4 id="org6af2844"><span class="section-number-4">2.4.1.</span> Advanced Dependencies Management</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="org-src-container">
<pre class="src src-shell">(asdf/source-registry:default-user-source-registry)
(:SOURCE-REGISTRY (:TREE (:HOME "common-lisp/"))
 (:DIRECTORY (:HOME ".sbcl/systems/"))
 (:DIRECTORY #P"/Users/mingmingli/.local/share/common-lisp/systems/")
 (:TREE #P"/Users/mingmingli/.local/share/common-lisp/source/")
 :INHERIT-CONFIGURATION)
</pre>
</div>

<p>
A library installed in the previous lists is a vailable for every project.<br />
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org4fa68fd" class="outline-2">
<h2 id="org4fa68fd"><span class="section-number-2">3.</span> <span class="done DONE">DONE</span> Welcome to Lisp</h2>
<div class="outline-text-2" id="text-3">
</div>

<div id="outline-container-org8db3367" class="outline-3">
<h3 id="org8db3367"><span class="section-number-3">3.1.</span> Form&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></h3>
<div class="outline-text-3" id="text-3-1">
<p>
It is particularly true of Lisp that you learn it by using it, because Lisp is an interactive language. Any Lisp system will include an interactive front-end called the <b><a id="org4641b96">toplevel</a></b>. You type Lisp expressions into the <a href="#org4641b96">toplevel</a>, and the system displays their values.<br />
</p>

<p>
Lisp usually displays a prompt to tell you that it's waiting for you to type something. Many implementations of Common Lisp use <code>&gt;</code> as the <a href="#org4641b96">toplevel</a> prompt.<br />
</p>


<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; 1
1
CL-USER&gt; (+ 2 3)
5
CL-USER&gt; (/ (- 7 1) (- 4 2))
3
</pre>
</div>

<p>
In the expression (+ 2 3), the + is called the <b>operator</b>, and the numbers 2 and 3 are called <b>arguments</b>.<br />
This is called <b><a id="org058fc6e">prefix notation</a></b>, because the operator comes first.<br />
In our real life, you usually write like \(1 + 2 + 3\). This is called infix notation.<br />
</p>

<p>
All Lisp expressions are either <b><a id="org726a58e">atoms</a></b>, like 1, or <b><a id="org1a9ed34">list</a></b>, which consist of zero or more expressions enclosed in parentheses. All Lisp code take this form.<br />
</p>
</div>
</div>

<div id="outline-container-org650110c" class="outline-3">
<h3 id="org650110c"><span class="section-number-3">3.2.</span> Evaluation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></h3>
<div class="outline-text-3" id="text-3-2">
<p>
In the expression (+ 2 3), + is a function and an expression like (+ 2 3) is a function call. When lisp evaluates a function call. it does so in two steps:<br />
</p>
<ol class="org-ol">
<li>The arguments are evaluated, from left to right. In this case, each argument evaluates to itself, so the values of the arguments are 2 and 3, respectively.<br /></li>
<li>The values of the arguments are passed to the function named by the operator. In this case, it is the + function, which returns 5.<br /></li>
</ol>


<p>
Not all the operators in Common Lisp are functions, but most are. And function calls are always evaluated this way. The arguments are evaluated left-to-right, and their values are passed to the function, which returns the value of the expression as a whole. This is called the <b><a id="orge23b230">evaluation rule</a></b> for Common Lisp.<br />
</p>



<p>
One operator that doesn't follow the Common Lisp <a href="#orge23b230">evaluation rule</a> is <code>quote</code>. The <code>quote</code> operator is a <b><a id="org31c3e37">special operator</a></b>, meaning that it has a distinct <a href="#orge23b230">evaluation rule</a> of its own. And the rule is: do nothing. The <code>quote</code> operator takes a single argument, and just returns it verbatim:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (quote (+ 3 5))
(+ 3 5)
</pre>
</div>

<p>
For convenience, Common Lisp defines ' as an abbreviation for <code>quote</code>.<br />
You can get the effect of calling <code>quote</code> by affixing a ' to the front of any expression:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; '(+ 3 5)
(+ 3 5)
</pre>
</div>


<p>
It is much more common to use the abbreviation than to write out the whole <code>quote</code> expression.<br />
</p>


<p>
Lisp provides the quote as a way of protecting expressions from evaluation.<br />
</p>
</div>
</div>
<div id="outline-container-orgda1fe46" class="outline-3">
<h3 id="orgda1fe46"><span class="section-number-3">3.3.</span> Data</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org54fb67d" class="outline-4">
<h4 id="org54fb67d"><span class="section-number-4">3.3.1.</span> Integer</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
Integer is written as a series of digits.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; 1024
1024  
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd44b5c6" class="outline-4">
<h4 id="orgd44b5c6"><span class="section-number-4">3.3.2.</span> String</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
String is represented as a series of <a href="#org9caef75">characters</a> surrounded by double-quotes.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; "China"
"China"
</pre>
</div>

<p>
Intergers and <a href="#orgf8f4f91">strings</a> are both evaluate to themselves.<br />
</p>
</div>
</div>
<div id="outline-container-orga1a6cb0" class="outline-4">
<h4 id="orga1a6cb0"><span class="section-number-4">3.3.3.</span> Symbol</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
Symbols ae words. Ordinarily they are converted to uppercase, regardless of how you type them.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; 'China
CHINA  
</pre>
</div>

<p>
Symbols do not (usually) evaluate to themselves, so if you want to refer to a symbol, you should quote it, as above.<br />
</p>
</div>
</div>
<div id="outline-container-org4492f50" class="outline-4">
<h4 id="org4492f50"><span class="section-number-4">3.3.4.</span> <a href="#org1a9ed34">List</a></h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
Lists are represented as zero or more elements enclosed in parentheses. The elements can be of any type, including lists. You have to quote lists, or Lisp would take them for function calls.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; '(the list (a b c) has 3 elements)
(THE LIST (A B C) HAS 3 ELEMENTS)  
</pre>
</div>

<p>
One quote protects a whole expressions, including expressings within it.<br />
</p>



<p>
You can build lists by calling <code>list</code> . Since <code>list</code> is a function, its arguments are evaluated.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (list 'i 'have (- 3 1) "computers")
(I HAVE 2 "computers")  
</pre>
</div>

<p>
We are now in a position to appreciate one of the most remarkable features of Lisp. <b>Lisp programs are expressed as lists</b>. It means that Lisp programs can generate Lisp code. Lisp programmers can (and often do) write programs to write their programs for them.<br />
</p>

<p>
The relation between expressions and lists is: if a <a href="#org1a9ed34">list</a> is quoted, evaluation returns the <a href="#org1a9ed34">list</a> itself; if it is not quoted, the  <a href="#org1a9ed34">list</a> is treated as code, and evaluation returns its values.<br />
</p>

<p>
In Common Lisp, there are two ways of representing the empty <a href="#org1a9ed34">list</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; ()
NIL
CL-USER&gt; nil
NIL
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd1a5f11" class="outline-3">
<h3 id="orgd1a5f11"><span class="section-number-3">3.4.</span> <a href="#org1a9ed34">List</a> Operations</h3>
<div class="outline-text-3" id="text-3-4">
<p>
There are three basic functions:<br />
</p>
<dl class="org-dl">
<dt><a href="#org11893e9">cons</a></dt><dd>build <a href="#org1a9ed34">list</a><br /></dd>
<dt>car</dt><dd>the first element of a <a href="#org1a9ed34">list</a><br /></dd>
<dt>cdr</dt><dd>everything after the first element<br /></dd>
</dl>


<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (cons 'a '(b c d))
(A B C D)
CL-USER&gt; (car '(a b c))
A
CL-USER&gt; (cdr '(a b c))
(B C)  
</pre>
</div>
</div>
</div>

<div id="outline-container-org6488357" class="outline-3">
<h3 id="org6488357"><span class="section-number-3">3.5.</span> Truth</h3>
<div class="outline-text-3" id="text-3-5">
<p>
The symbol <code>t</code> is the default representation for truth. Like <code>nil</code> , <code>t</code> evaluates to itself. The function <code>listp</code> returns true if its argument is a <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (listp '(a b c))  
T
</pre>
</div>

<p>
A function whose return value is intended to be interpreted as truth or falsity is called a <b>predicate</b>. Common Lisp predicates often have names that end with <code>p</code>.<br />
</p>


<p>
Falsity is represented by <code>nil</code> , the empty <a href="#org1a9ed34">list</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (listp 123)
NIL
</pre>
</div>

<p>
Because <code>nil</code> plays two roles in Common Lisp, the function <code>null</code>, whick returns true of the empty <a href="#org1a9ed34">list</a><br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (null nil)
T  
</pre>
</div>
<p>
and the function <code>not</code>, which return true if its arguments is false<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (not nil)
T  
</pre>
</div>
<p>
do the exactly the same thing.<br />
</p>



<p>
The simplest conditional in Common Lisp is <code>if</code>. It usually takes three arguments: a test expression, a then expression, and an else expression. The test expression is evaluated. If it returns true, the then expression is evaluated and its value is returned. If the test expression returns false, the else expression is evaluated and its value is returned:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (if (listp '(a))
             (+ 1 2)
             (+ 5 6))
3
CL-USER&gt; (if (listp 1)
             (+ 1 2)
             (+ 5 6))
11  
</pre>
</div>
<p>
Like <code>quote</code>, <code>if</code> is a <a href="#org31c3e37">special operator</a>. It could not possibly be implemented as a function, because the arguments in a function call are always evaluated, and the whole point of <code>if</code> is that only one of the last two arguments is evaluated.<br />
</p>

<p>
The last argument is optional. If you omit it, it defaults to <code>nil</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (if (listp 1)
             (+ 1 2))
NIL 
</pre>
</div>


<p>
Although <code>t</code> is the default representation for truth, everything except <code>nil</code> also counts as true in a logical context.<br />
</p>


<p>
The logical operators <code>and</code> and <code>or</code> resemble conditionals. Both take any number of arguments, but only evaluates as many as they need to in order to decide what to return. If all its arguments are true, then <code>and</code> returns the value of the last one:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (and t (+ 1 2))
3
</pre>
</div>
<p>
But if one of the arguments turns out to be false, none of the arguments after that get evaluated. Similarly for <code>or</code>, which stops as soon as it finds an argument that is true:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (or nil 3 (listp '(a)))
3  
</pre>
</div>


<p>
These two operators are <b><a href="#orge6ba26a">macros</a></b>. Like special operators, <a href="#orge6ba26a">macros</a> can circumvent the usual <a href="#orge23b230">evaluation rule</a>.<br />
</p>
</div>
</div>


<div id="outline-container-org10f56eb" class="outline-3">
<h3 id="org10f56eb"><span class="section-number-3">3.6.</span> Functions</h3>
<div class="outline-text-3" id="text-3-6">
<p>
You can define new functions with <code>defun</code>. It usually takes three or more arguments: a name, a <a href="#org1a9ed34">list</a> of parameters, and one or more expressions that will make up the body of the function. Here is how we might define third:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defun our-third (x)
           (car (cdr (cdr x))))
OUR-THIRD  
</pre>
</div>


<p>
The first argument says that the name of this function will be <b>our-third</b>. The second argument, the <a href="#org1a9ed34">list</a> <code>(x)</code>, says that the function will take exactly one argument: <code>x</code>. A symbol used as a placeholder in this way is called a <b><a id="orge9b5a96">variable</a></b>. When the <a href="#orge9b5a96">variable</a> represents an argument to a function, as <code>x</code> does, it is also called a <b><a id="org44ae6ab">parameter</a></b>.<br />
</p>

<p>
The rest of the definition, <code>(car (cdr (cdr x)))</code>, is known as the body of the function. It tells Lisp what it has to do to calculate the return value of the function.<br />
</p>



<p>
Now that we've seen variables, it's easier to understand what symbols are. They are <a href="#orge9b5a96">variable</a> names, existing as objects in their own right. And that's why symbols, like lists, have to be quoted. A <a href="#org1a9ed34">list</a> has to be quoted because otherwise it will be treated as code; a symbol has to be quoted because otherwise it will be treated as a <a href="#orge9b5a96">variable</a>.<br />
</p>


<p>
You can think of a function definition as a generalized version of a Lisp expression. The following expression tests whether the sum of 1 and 4 is greater than 3:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (&gt; (+ 1 4) 3)
T  
</pre>
</div>
<p>
By replacing these particular numbers with variables, we can write a function that will test whether the sum of any two numbers is greater than a third:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defun sum-greater (x y z)
           (&gt; (+ x y) z))
SUM-GREATER
CL-USER&gt; (sum-greater 1 4 3)
T  
</pre>
</div>
</div>
</div>


<div id="outline-container-org5142193" class="outline-3">
<h3 id="org5142193"><span class="section-number-3">3.7.</span> Recursion</h3>
<div class="outline-text-3" id="text-3-7">
<p>
The functions we defined in the previous section called other functions to do some of their work for them. For example, <code>sum-greater</code> called <code>+</code> and <code>&gt;</code>. A function can call any function, including itself.<br />
</p>

<p>
A function that calls itself is <b><a id="org7e3c89d">recursive</a></b>. The Common Lisp function <code>member</code> tests whether something is an element of a <a href="#org1a9ed34">list</a>. Here is a simplified version defined as a <a href="#org7e3c89d">recursive</a> function:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-member (obj lst)
  (if (null lst)
      nil
      (if (eql (car lst) obj)
      lst
      (our-member obj (cdr lst)))))  
</pre>
</div>

<p>
The predicate <code>eql</code> tests whether its two arguments are identical. Here is in action:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (our-member 'b '(a b c))
(B C)
CL-USER&gt; (our-member 'z '(a b c))
NIL  
</pre>
</div>

<p>
The definition of <code>our-member</code> corresponds to the following English description. To test whether an object <code>obj</code> is a member of a <a href="#org1a9ed34">list</a> <code>lst</code>, we<br />
</p>
<ol class="org-ol">
<li>First check whether <code>lst</code> is empty. If it is, then <code>obj</code> is clearly not a member of it, and we're done.<br /></li>
<li>Otherwise, if <code>obj</code> is the first element of <code>lst</code>, it is a member.<br /></li>
<li>Otherwise <code>obj</code> is only a member of <code>lst</code> if it is a member of the rest of <code>lst</code>.<br /></li>
</ol>
<p>
When you want to understand how a <a href="#org7e3c89d">recursive</a> function works, it can help to translate it into a description of this kind.<br />
</p>
</div>
</div>

<div id="outline-container-org4c783aa" class="outline-3">
<h3 id="org4c783aa"><span class="section-number-3">3.8.</span> Reading Lisp</h3>
<div class="outline-text-3" id="text-3-8">
<p>
The pseudo-<code>member</code> defined in the preceding section ends with five parentheses. More elaborate function definitions might end with seven or eight. How is one to see which parenthesis matches which?<br />
</p>

<p>
The answer is, one doesn't have to. Lisp programmers read and write code by <b>indentation</b>, not by parentheses. When they're writing code, they let the text editor show which parenthesis matches which.<br />
</p>

<p>
With a good editor, matching parentheses ceases to be an issue when you're writing code. And because there are universal conventions for Lisp indentation, it's not an issue when you're reading code either. Because everyone uses the same conventions, you can read code by the indentation, and ignore the parentheses.<br />
</p>
</div>
</div>

<div id="outline-container-orgfd5458a" class="outline-3">
<h3 id="orgfd5458a"><span class="section-number-3">3.9.</span> Input and Output</h3>
<div class="outline-text-3" id="text-3-9">
<p>
The most general output function in Common Lisp is <code>format</code>. It takes two or more arguments: the first indicates where the output is to be printed, the second is a string template, and the remaining arguments are usually objects whose printed representations are to be inserted into the template. Here is a typical example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format t "~A plus ~A equals ~A ~%" 2 3 (+ 2 3))
2 plus 3 equals 5 
NIL  
</pre>
</div>

<p>
Notice that two things get displayed here. The first line is displayed by <code>format</code>. The second line is the value returned by the call to <code>format</code>, displayed in the usual way by the <a href="#org4641b96">toplevel</a>. Ordinarily a function like <code>format</code> is not called directly from the <a href="#org4641b96">toplevel</a>, but used within programs, so the return value is never seen.<br />
</p>


<p>
The first argument to <code>format</code>, <code>t</code>, indicates that the output is to be sent to the default place. Ordinarily this will be the <a href="#org4641b96">toplevel</a>. The second argument is a string that serves as a template for output. Within this string, each <code>~A</code> indicates a position to be filled, and the <code>~%</code> indicates a newline. The positions are filled by the values of the remaining arguments, in order.<br />
</p>



<p>
The standard function for input is <code>read</code>. Then given no arguments, it reads from the default place, which will usually the the <a href="#org4641b96">toplevel</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (read)
16
16
</pre>
</div>

<p>
<code>read</code> will sit waiting indefinitely until you type something and (usually) hit reuturn. <code>read</code> is very powerful: <code>read</code> is a complete Lisp parser. It doesn't just read <a href="#org9caef75">characters</a> and return them as a string. It parses what it reads, and returns the Lisp object that results. In the case above, it returned a number.<br />
</p>

<p>
"Pure" Lisp is Lisp without side-effects. A <b><a id="org81281e1">side-effect</a></b> is some change to the state of the world that happens as a consequence of evaluating an expression. When we evaluate a pure Lisp expression like <code>(+ 1 2)</code>, there are no side-effects; it just returns a value. But when we call <code>format</code>, it prints something. That's one kind of <a href="#org81281e1">side-effect</a>.<br />
</p>


<p>
When we are writing code without side-effects, there is no point in defining functions with bodies of more than one expression. The value of the last expression is returned as the value of the function, but the values of any preceding expressions are thrown away. If such expressions didn't have side-effects, you would have no way of telling whether Lisp bothered to evaluate them at all.<br />
</p>
</div>
</div>




<div id="outline-container-org7ec66f2" class="outline-3">
<h3 id="org7ec66f2"><span class="section-number-3">3.10.</span> Variables</h3>
<div class="outline-text-3" id="text-3-10">
<p>
One of the most frequently used operators in Common Lisp is <code>let</code>, which allows you to introduce new <a href="#orgf3afcdc">local variables</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 1) (y 2))
           (+ x y))
3
</pre>
</div>

<p>
A <code>let</code> expression has two parts. First comes a <a href="#org1a9ed34">list</a> of instructions for creating variables, each of the form <code>(variable expression)</code>. Each <code>variable</code> will initially be set to the value of the corresponding <code>expression</code>. So in the example above, we create two new variables, <code>x</code> and <code>y</code>, which are initially set to 1 and 2, respectively. These variables are valid within the body of the <code>let</code>.<br />
</p>


<p>
After the <a href="#org1a9ed34">list</a> of variables and values comes a body of expressions, which are evaluated in order. In this case there is only one, a call to <code>+</code>. The value of the last expression is returned as the value of the <code>let</code>.<br />
</p>



<p>
Variables like those we have seen so far are called <b><a id="orgf3afcdc">local variables</a></b>. They are only valid within a certain context. There is another kind of <a href="#orge9b5a96">variable</a>, called a <b><a id="org402c5bb">global variable</a></b>, that can be visible everywhere.<br />
</p>


<p>
You can create a <a href="#org402c5bb">global variable</a> by giving a symbol and a value to <code>defparameter</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defparameter *glob* 99)
*GLOB*  
</pre>
</div>
<p>
Such a <a href="#orge9b5a96">variable</a> will then be accessible everywhere, except in expressions that create a new local <a href="#orge9b5a96">variable</a> with the same name. To avoid the possibility of this happening by accident, it's conventional to give global variables names hat begin and end with asterisks.<br />
</p>

<p>
You can also define global constants, by calling <code>defconstant</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defconstant limit (+ *glob* 1))
LIMIT  
</pre>
</div>

<p>
There is no'need to give constants distinctive names, because it will cause an error if anyone uses the same name for a <a href="#orge9b5a96">variable</a>. If you want to check whether some symbol is the name of a <a href="#org402c5bb">global variable</a> or constant, use <code>boundp</code>:<br />
</p>


<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (boundp '*glob*)
T
CL-USER&gt; (boundp 'limit)
T  
</pre>
</div>
</div>
</div>



<div id="outline-container-org407e03c" class="outline-3">
<h3 id="org407e03c"><span class="section-number-3">3.11.</span> Assignment</h3>
<div class="outline-text-3" id="text-3-11">
<p>
In Common Lisp the most general assignment operator is <code>setf</code>. We can use it to do assignments to either kind of <a href="#orge9b5a96">variable</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf *glob* 98)
98
CL-USER&gt; (let ((n 10))
           (setf n 2)
           n)
2  
</pre>
</div>

<p>
When the first argument to <code>setf</code> is a symbol that is not the name of a local <a href="#orge9b5a96">variable</a>, it is taken to be a <a href="#org402c5bb">global variable</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x (list 'a 'b 'c))
; in: SETF X
;     (SETF X (LIST 'A 'B 'C))
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::X
; 
; compilation unit finished
;   Undefined variable:
;     X
;   caught 1 WARNING condition
(A B C)  
</pre>
</div>
<p>
That is, you can create global variables implicitly, just by assigning them values. In source files, at least, it is better style to use explicit <code>defparameters</code>.<br />
</p>


<p>
You can do more than just assign values to variables. The first argument to <code>setf</code> can be an expression as well as a <a href="#orge9b5a96">variable</a> name. In such cases, the<br />
value of the second argument is inserted in the place referred to by the first:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf (car x) 'n)
N
CL-USER&gt; x
(N B C)  
</pre>
</div>

<p>
The first argument to <code>setf</code> can be almost any expression that refers to a particular place.<br />
</p>


<p>
You can give any (even) number of arguments to <code>setf</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf a 1
      b 2
      c 3)

;; equal to
(setf a 1)
(setf b 2)
(setf c 3)
</pre>
</div>
</div>
</div>


<div id="outline-container-org0b6ab5b" class="outline-3">
<h3 id="org0b6ab5b"><span class="section-number-3">3.12.</span> <a href="#org2a7a2f8">Functional Programming</a></h3>
<div class="outline-text-3" id="text-3-12">
<p>
<b><a id="org2a7a2f8">Functional programming</a></b> means writing programs that work by returning values, instead of by modifying things. It is the dominant paradigm in Lisp. Most built-in Lisp functions are meant to be called for the values they return, not for side-effects.<br />
</p>



<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst '(a b c d e f))
(A B C D E F)
CL-USER&gt; (remove 'a lst)
(B C D E F)
CL-USER&gt; lst
(A B C D E F)
CL-USER&gt;   
</pre>
</div>
<p>
In this example, the function <code>remove</code> returned a new <a href="#org1a9ed34">list</a> and did not change the original <a href="#org1a9ed34">list</a>.<br />
</p>

<p>
So what if you really do want to remove something from a <a href="#org1a9ed34">list</a>? In Lisp you generally do such things by passing the <a href="#org1a9ed34">list</a> as an argument to some function, and using <code>setf</code> with the return value. To remove all the as from a <a href="#org1a9ed34">list</a> <code>x</code>, we say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf x (remove 'a x))  
</pre>
</div>


<p>
The more <a href="#org81281e1">side-effect</a> you do without, the better off you'll be.<br />
</p>

<p>
One of the most import advantage of <a href="#org2a7a2f8">functional programming</a> is that it allows <b>interactice testing</b>. In purely functional code, you can test each function as you write it. If it returns the values you expect, you can be confident that it is correct.<br />
</p>
</div>
</div>

<div id="outline-container-org8d5bff7" class="outline-3">
<h3 id="org8d5bff7"><span class="section-number-3">3.13.</span> Iteration</h3>
<div class="outline-text-3" id="text-3-13">
<p>
When we want to do something repeatedly, it is sometimes more natural to use iteration than recursion. A typical case for iteration is to generate some sort of table. This function<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun show-squares (start end)
  (do ((i start (+ i 1)))
      ((&gt; i end) 'done)
    (format t "~A ~A~%" i (* i i))))
</pre>
</div>
<p>
prints out the squares of the integers from <code>start</code> to <code>end</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (show-squares 2 5)
2 4
3 9
4 16
5 25
DONE  
</pre>
</div>

<p>
The <code>do</code> macro is the fundamental iteration operator in Common Lisp. Like <code>let</code>, <code>do</code> can create variables, and the first argument is a <a href="#org1a9ed34">list</a> of <a href="#orge9b5a96">variable</a> specifications. Each element of this <a href="#org1a9ed34">list</a> can be of the form<br />
</p>
<pre class="example" id="org3188ebb">
(variable initial update)
</pre>
<p>
where <code>variable</code> is a symbol, and <code>initial</code> and <code>update</code> are expressions. Initially each <code>variable</code> will be set to the value of the corresponding <code>initial</code>, on each iteration it will be set to the value of the corresponding <code>update</code>. The <code>do</code> in <code>show-squares</code> creates just one <a href="#orge9b5a96">variable</a>, <code>i</code>. On the first iteration <code>i</code> will be set to the value of <code>start</code>, and on successive iterations its value will be incremented by one.<br />
</p>


<p>
The second argument to <code>do</code> should be a <a href="#org1a9ed34">list</a> containing one or more expressions. The first expression is used to test whether iteration should stop. In the case above, the test expression is <code>(&gt; i end)</code>. The remaining expressions in this <a href="#org1a9ed34">list</a> will be evaluated in order when iteration stops, and the value of the last will be returned as the value of the <code>do</code>. So <code>show-squares</code> will always return <code>done</code>.<br />
</p>


<p>
The remaining arguments to <code>do</code> comprise the body of the loop. They will be evaluated, in order, on each iteration. On each iteration the variables are updated, then the termination test is evaluated, and then (if the test failed) the body is evaluated.<br />
</p>


<p>
Common Lisp has simpler iteration operators for special cases. To iterate through the elements of a <a href="#org1a9ed34">list</a>, for example, you would be more likely to use <code>dolist</code>. Here is a function that returns the length of a <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-length (lst)
  (let ((len 0))
    (dolist (obj lst)
      (setf len (+ len 1)))
    len))
</pre>
</div>
<p>
Here <code>dolist</code> takes an argument of the form <code>(variable expression)</code>, followed by a body of expressions. The body will be evaluated with <code>variable</code> bounded to successive elements of the <a href="#org1a9ed34">list</a> returned by <code>expression</code>. So the loop above says, for each <code>obj</code> in <code>lst</code>, increment <code>len</code>.<br />
</p>
</div>
</div>


<div id="outline-container-org486beba" class="outline-3">
<h3 id="org486beba"><span class="section-number-3">3.14.</span> Functions as Objects</h3>
<div class="outline-text-3" id="text-3-14">
<p>
In Lisp, functions are regular objects, like symbols or <a href="#orgf8f4f91">strings</a> or lists. If we give the name of a function to <code>function</code>, it will return the associated object. Like <code>quote</code>, <code>function</code> is a <a href="#org31c3e37">special operator</a>, so we don't have to quote the argument:<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (function +)
#&lt;FUNCTION +&gt;  
</pre>
</div>

<p>
Until now we have only dealt with objects that look the same when Lisp displays them as when we typed them in. This convention does not apply to functions. Internally, a built-in function like <code>+</code> is likely to be a segment of machine language code. A Common Lisp implementation may choose whatever external representation it likes.<br />
</p>


<p>
Just as we can use <code>'</code> as an abbreviation for <code>quote</code>, we can use <code>#'</code> as an abbreviation for <code>function</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; #'+
#&lt;FUNCTION +&gt;  
</pre>
</div>
<p>
This abbreviation is known as sharp-quote.<br />
</p>

<p>
Like any other kind of object, we can pass functions as arguments. One function that takes a function as an argument is <code>apply</code>. It takes a function and a <a href="#org1a9ed34">list</a> of arguments for it, and returns the result of applying the function to the arguments:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (apply #'+ '(1 2 3))
6
CL-USER&gt; (+ 1 2 3)
6
</pre>
</div>
<p>
It can be given any number of arguments, so long as the last is a <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (apply #'+ 1 2 '(3 4 5))
15  
</pre>
</div>


<p>
The function <code>funcall</code> does the same thing but does not need the arguments to be packaged in a <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (funcall #'+ 1 2 3)
6  
</pre>
</div>

<p>
The <code>defun</code> macro creates a function and gives it a name. But functions don't have to have names, and we don't need <code>defun</code> to define them. Like most other kinds of Lisp objects, we can refer to functions literally.<br />
</p>

<p>
To refer literally to an integer, we use a series of digits; to refer literally to a function, we use what's called a <b>lambda expression</b>. A lambda expression is a <a href="#org1a9ed34">list</a> containing the symbol <code>lambda</code>, followed by a <a href="#org1a9ed34">list</a> of parameters, followed by a body of zero or more expressions.<br />
</p>

<p>
Here is a lambda expression representing a function that takes two numbers and returns their sum:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(lambda (x y)
  (+ x y))  
</pre>
</div>
<p>
The <a href="#org1a9ed34">list</a> <code>(x y)</code> is the <a href="#org44ae6ab">parameter</a> <a href="#org1a9ed34">list</a>, and after it comes the body of the function.<br />
</p>


<p>
A lambda expression can be considered as the name of a function. Like an ordinary function name, a lambda expression can be the first element of a function call<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; ((lambda (x) (+ x 100)) 1)
101  
</pre>
</div>
<p>
and by affixing a sharp-quote to a lambda expression, we get the corresponding function,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (funcall #'(lambda (x) (+ x 100))
                  1)
101  
</pre>
</div>
</div>
</div>

<div id="outline-container-org392e200" class="outline-3">
<h3 id="org392e200"><span class="section-number-3">3.15.</span> <a href="#orgcc779bc">Types</a></h3>
<div class="outline-text-3" id="text-3-15">
<p>
Lisp has an unusually flexible approach to <b><a id="orgcc779bc">types</a></b>. In many languages, variables are what have <a href="#orgcc779bc">types</a>, and you can't use a <a href="#orge9b5a96">variable</a> without specifying its type. In Common Lisp, values have <a href="#orgcc779bc">types</a>, not variables. You could imagine that every object had a label attached to it, identifying its type. This approach is called <b><a id="org2cf8994">manifest typing</a></b>. You don't have to declare the <a href="#orgcc779bc">types</a> of variables, because any <a href="#orge9b5a96">variable</a> can hold objects of any type.<br />
</p>

<p>
Though <a href="#org8dffea0">type declarations</a> are never required, you may want to make them for reasons of efficiency.<br />
</p>

<p>
The built-in Common Lisp <a href="#orgcc779bc">types</a> form a hierarchy of subtypes and supertypes. An object always has more than one type. For example, the number 27 is of type <code>fixnum, integer, rational, real, number, atom</code>, and <code>t</code>, in order of increasing generality. The type <code>t</code> is the supertype of all <a href="#orgcc779bc">types</a>, so everything is of type <code>t</code>.<br />
</p>

<p>
The function <code>typep</code> takes an object and a <a href="#org3d0cae7">type specifier</a>, and returns true if the object is of that type:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (typep 27 'integer)
T
</pre>
</div>
</div>
</div>


<div id="outline-container-org97f39c4" class="outline-3">
<h3 id="org97f39c4"><span class="section-number-3">3.16.</span> Summary</h3>
<div class="outline-text-3" id="text-3-16">
<p>
Richard Gabriel once half-jokingly described C as a language for writing Unix. We could likewise describe Lisp as a language for writing Lisp. But this is a different kind of statement. A language that can be written in itself is fundamentally different from a language good for writing some particular class of applications. It opens up a new way of programming: as well as writing your program in the language, you can improve the language to suit your program. If you want to understand the essence of Lisp programming, this idea is a good place to begin.<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orge4568be" class="outline-2">
<h2 id="orge4568be"><span class="section-number-2">4.</span> <span class="done DONE">DONE</span> Lists</h2>
<div class="outline-text-2" id="text-4">
<p>
Lists are one the fundamental data structures in Lisp. In the earliest dialects they are the only data <a href="#orge221c9c">structure</a>: the name "Lisp" originally stood for "<a href="#org1a9ed34">LISt</a> Processor". But Lisp has long since outgrown this acronym. Common Lisp is a general-purpose programming language with a wide variety of data structures.<br />
</p>



<p>
The development of Lisp programs often echoes the development of Lisp itself. In the initial version of a Lisp program, you may use a lot of lists. Then in later versions you may switch to faster, <a href="#org36bef2b">specialized</a> data structures.<br />
</p>


<p>
This chapter describes the many things you can do with lists, and uses them to illustrate some general Lisp concepts.<br />
</p>
</div>

<div id="outline-container-org168270e" class="outline-3">
<h3 id="org168270e"><span class="section-number-3">4.1.</span> Conses</h3>
<div class="outline-text-3" id="text-4-1">
<p>
What <code>cons</code> really do is combine two objects into a two-part object called <b><a id="org11893e9">cons</a></b>. Conceptuallly, a <a href="#org11893e9">cons</a> is a paire of pointers; the first one is the car and the second is the cdr. This provide the possiblity to build lists with conses. Any nonempty <a href="#org1a9ed34">list</a> can be considered as a pair of the first element and the rest of the <a href="#org1a9ed34">list</a>. Lisp lists are the embodiment of this idea. We use one half of the <a href="#org11893e9">cons</a> to point to the first element of the <a href="#org1a9ed34">list</a>, and the other to point to the rest of the <a href="#org1a9ed34">list</a> (which is either another <a href="#org11893e9">cons</a> or <code>nil</code>). So lists are not a distinct kind of object, but conses linked together in this way.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x (cons 'a nil))
(A)
CL-USER&gt; (car x)
A
CL-USER&gt; (cdr x)
NIL
</pre>
</div>

<p>
The function <code>consp</code> return true if its argument is a <a href="#org11893e9">cons</a>. So listp could be defined:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-listp (x)
  (or (null x) (consp x)))
</pre>
</div>

<p>
Since everything that is not a <a href="#org11893e9">cons</a> is an atom, the preidcate <code>atom</code> could be defined:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-atom (x) (not (consp x)))
</pre>
</div>

<p>
<code>nil</code> is both an atom and a <a href="#org1a9ed34">list</a>.<br />
</p>
</div>
</div>



<div id="outline-container-org586ba90" class="outline-3">
<h3 id="org586ba90"><span class="section-number-3">4.2.</span> Equality</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Each time you cal <code>cons</code>, Lisp allocates a new piece of memory with room for two pointers. So if we call <code>cons</code> twice with the same arguments, we get back two values that look the same, but are in fact distince objects:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (eql (cons 'a nil) (cons 'a nil))
NIL  
</pre>
</div>
<p>
It would be convenient if we could also ask whether two lists had the same<br />
elements. Common Lisp provides another equality predicate for this purpose: <code>equal</code>. While <code>eql</code> returns true only if its arguments are the same object,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x (cons 'a nil))
(A)
CL-USER&gt; (eql x x)
T  
</pre>
</div>
<p>
<code>equal</code> returns true if its arguments would print the same,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (equal (cons 'a nil) (cons 'a nil))
T  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbde7013" class="outline-3">
<h3 id="orgbde7013"><span class="section-number-3">4.3.</span> Why Lisp Has No Pointers</h3>
<div class="outline-text-3" id="text-4-3">
<p>
One of the secrets to understanding Lisp is to realize that variables have values in the same way that lists have elements. As conses have pointers to their elements, variables have pointers to their values.<br />
</p>

<p>
In other languages like C, pointers were manipulated explicitly. In Lisp you never have to do this, because the language handles pointers for you. We've already seen how this happens with lists. Something similar happens with variables. Suppose, for example, we set two variables to the same <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x '(a b c))
(A B C)
CL-USER&gt; (setf y x)
(A B C)
</pre>
</div>

<p>
What actually happens when we set <code>y</code> to the value of <code>x</code>? The location in memory associated with the <a href="#orge9b5a96">variable</a> <code>x</code> does not contain the <a href="#org1a9ed34">list</a> itself, but a pointer to it. When we assign the same value to <code>y</code>, Lisp copies the pointer, not the <a href="#org1a9ed34">list</a>. So whenever you assign one <a href="#orge9b5a96">variable</a> the value of another, the two variables will have <code>eql</code> values:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (eql x y)
T  
</pre>
</div>

<p>
The reason Lisp has no pointers is that every value is conceptually a pointer. When you assign a value to a <a href="#orge9b5a96">variable</a> or store it in a data <a href="#orge221c9c">structure</a>, what gets stored is actually a pointer to the value. When you ask for the contents of the data <a href="#orge221c9c">structure</a> or the value of the <a href="#orge9b5a96">variable</a>, Lisp returns what it points to. But all this happens beneath the surface. You can just put values in structures or "in" variables without thinking about it.<br />
</p>
</div>
</div>


<div id="outline-container-orgaa88255" class="outline-3">
<h3 id="orgaa88255"><span class="section-number-3">4.4.</span> Building Lists</h3>
<div class="outline-text-3" id="text-4-4">
<p>
The function <code>copy-list</code> takes a <a href="#org1a9ed34">list</a> and returns a copy of it. The new <a href="#org1a9ed34">list</a> will have the same elements, but contained in new conses.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x '(a b c)
               y (copy-list x))
(A B C)
CL-USER&gt; (equal x y)
T
CL-USER&gt; (eql x y)
NIL  
</pre>
</div>

<p>
We could think of <code>copy-list</code> as being defined,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-copy-list (lst)
  (if (atom list)
      lst
      (cons (car lst) (our-copy-list (cdr lst)))))  
</pre>
</div>




<p>
The function <code>append</code> returns the concatenation of any number of <a href="#org1a9ed34">list</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (append '(a b) '(c d) '(e))
(A B C D E)  
</pre>
</div>
<p>
In doing so, it copies all the arguments except the last.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x '(a)) (y '(b c)) (lst))
           (setf lst (append x y))
           (format t "lst: ~A~%" lst)
           (eql y (cdr lst)))
lst: (A B C)
T  
</pre>
</div>
</div>
</div>

<div id="outline-container-orga2a087c" class="outline-3">
<h3 id="orga2a087c"><span class="section-number-3">4.5.</span> Access</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Common Lisp has additional accesss functions defined in terms of <code>car</code> and <code>cdr</code>. To find the element at a given position in a slit we call <code>nth</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (nth 0 '(a b c))
A  
</pre>
</div>
<p>
and to find the nth cdr, we call <code>nthcdr</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (nth 1 '(a b c))
B  
</pre>
</div>
<p>
Both <code>nth</code> and <code>nthcdr</code> are zero-indexed. In Common Lisp, whenever you use a number to refer to an element of a data <a href="#orge221c9c">structure</a>, the numbering start at zero.<br />
</p>


<p>
The function <code>last</code> return the last <a href="#org11893e9">cons</a> in a <a href="#org1a9ed34">list</a>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (last '(a b c))
(C)  
</pre>
</div>
<p>
This is not the same as getting the last element. To get the last element of a <a href="#org1a9ed34">list</a>, you would take the <code>car</code> of <code>last</code>.<br />
</p>


<p>
Common Lisp define <code>first</code> through <code>tenth</code> as functions that retrieve the corresponding element of a <a href="#org1a9ed34">list</a>. These function are not zero-indexed,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (first '(a b c))
A  
</pre>
</div>
</div>
</div>



<div id="outline-container-org9f207ed" class="outline-3">
<h3 id="org9f207ed"><span class="section-number-3">4.6.</span> Mapping Functions</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Common Lisp provides several functions for calling functions on the elements of a <a href="#org1a9ed34">list</a>. The most frequently used is <code>mapcar</code>, which takes a function and one or more lists, and returns the result of applying the function to elements taken from each <a href="#org1a9ed34">list</a>, until some <a href="#org1a9ed34">list</a> runs out,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (mapcar #'(lambda (x) (+ x 10))
                 '(1 2 3))
(11 12 13)
CL-USER&gt; (mapcar #'list
                 '(a b c)
                 '(1 2 3 4))
((A 1) (B 2) (C 3))  
</pre>
</div>

<p>
The related <code>maplist</code> takes the same arguments, but calls the function on successive cdrs of the lists,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (maplist #'(lambda (x) x)
                  '(a b c))
((A B C) (B C) (C))
CL-USER&gt; (maplist #'length '(a b c))
(3 2 1)  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf2a0887" class="outline-3">
<h3 id="orgf2a0887"><span class="section-number-3">4.7.</span> <a href="#orga9b0a3a">Trees</a></h3>
<div class="outline-text-3" id="text-4-7">
<p>
Conses can also be considered as binary <b><a id="orga9b0a3a">trees</a></b>, with the car representing the left subtree and the cdr the right. For examle, the <a href="#org1a9ed34">list</a><br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(a (b c) d)
</pre>
</div>
<p>
is also the tree represented in the Figure <a href="#org22c6320">1</a>.<br />
</p>

<div id="org22c6320" class="figure">
<p><img src="images/binary-tree.png" alt="binary-tree.png" /><br />
</p>
<p><span class="figure-number">Figure 1: </span>Binary tree</p>
</div>


<p>
Common Lisp has several built-in functions for use with <a href="#orga9b0a3a">trees</a>. For example, <code>copy-tree</code> takes a tree and returns a copy of it. It might be defined,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-copy-tree (tr)
  (if (atom tr)
      tr
      (cons (our-copy-tree (car tr))
            (our-copy-tree (cdr tr)))))
</pre>
</div>

<p>
Comparing this to the sketch of <code>copy-list</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-copy-list (lst)
  (if (atom list)
      lst
      (cons (car lst) (our-copy-list (cdr lst)))))  
</pre>
</div>
<p>
<code>copy-tree</code> copies both the car and cdr of each <a href="#org11893e9">cons</a>, while copy-<a href="#org1a9ed34">list</a> copies only the cdr.<br />
</p>


<p>
Common Lisp includes functions for operating on <a href="#orga9b0a3a">trees</a> not because one needs <a href="#orga9b0a3a">trees</a> as such, but because one needs a way to do something to a <a href="#org1a9ed34">list</a> and all the lists within it. For example, suppose we have a <a href="#org1a9ed34">list</a> like<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(and (integerp x) (zerop (mod x 2)))
</pre>
</div>
<p>
and we want to substitute <code>y</code> for <code>x</code> throughtout. It won't do to call <code>substitute</code>, which replaces elements in a <a href="#orgfef3696">sequence</a>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (substitute 'y 'x '(and (integerp x) (zerop (mod x 2))))
(AND (INTEGERP X) (ZEROP (MOD X 2)))  
</pre>
</div>
<p>
Because the <a href="#org1a9ed34">list</a> has tree elements and none of them are <code>x</code>. What we need here is a <code>subst</code>, which replaces elements in a tree,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (subst 'y 'x '(and (integerp x) (zerop (mod x 2))))
(AND (INTEGERP Y) (ZEROP (MOD Y 2)))  
</pre>
</div>

<p>
If we define a version of subst, it comes out looking a lot like <code>copy-tree</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-subst (new old tree)
  (if (eql tree old)
      new
      (if (atom tree)
          tree
          (cons (our-subst new old (car tree))
                (our-subst new old (cdr tree))))))  
</pre>
</div>
<p>
Functions that operate on <a href="#orga9b0a3a">trees</a> usually have this form, recursing down both the car and cdr. Such functions are said to be <b>doubly <a href="#org7e3c89d">recursive</a></b>.<br />
</p>
</div>
</div>


<div id="outline-container-orgeca0508" class="outline-3">
<h3 id="orgeca0508"><span class="section-number-3">4.8.</span> Understanding Recursion</h3>
<div class="outline-text-3" id="text-4-8">
<p>
Students learning about recursion are sometimes encouraged to trace all the invocations of a <a href="#org7e3c89d">recursive</a> function on a piece of paper. This exercise could be misleading: a programmer defining a <a href="#org7e3c89d">recursive</a> function usually does not think explicitly about the <a href="#orgfef3696">sequence</a> of invocations that results from calling it.<br />
</p>


<p>
If one always had to think of a program in such terms, recursion would be burdensome, not helpful. The advantage of recursion is precisely that it lets us view algorithms in a more abstract way. You can judge whether or not a <a href="#org7e3c89d">recursive</a> function is correct without considering all the invocations that result when the function is actually called.<br />
</p>


<p>
To see if a <a href="#org7e3c89d">recursive</a> function does what it's supposed to, all you have to ask is, does it cover all the cases? This is similar to <b>mathematical induction</b>.<br />
</p>

<p>
For example, here is a <a href="#org7e3c89d">recursive</a> function for finding the length of a <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun len (lst)
  (if (null lst)
      0
      (+ (len (cdr lst)) 1)))
</pre>
</div>

<p>
We can assure that this function is correct by verifying two things:<br />
</p>
<ol class="org-ol">
<li>That it works for lists of length 0.<br /></li>
<li>Given that it works for lists of length \(n\), that it also works for lists of length \(n+1\).<br /></li>
</ol>
<p>
If we can establish both points, then we know that the function is correct for all possible lists.<br />
</p>


<p>
Our definition obviously satisfies the first point: <code>if 1st is nil</code> , the function immediately returns 0. Now suppose that the function works for lists of length \(n\). We give it a <a href="#org1a9ed34">list</a> of length \(n+1\). The definition says that the function will return the <code>len</code> of the cdr of this <a href="#org1a9ed34">list</a>, plus 1. The cdr is a <a href="#org1a9ed34">list</a> of length \(n\). We know by our assumption that its <code>len</code> is \(n\). Thus the len of the whole <a href="#org1a9ed34">list</a> is \(n+1\).<br />
</p>


<p>
Being able to judge whether or not a <a href="#org7e3c89d">recursive</a> function is correct is only the first half of understanding recursion. The other half is being able to write a <a href="#org7e3c89d">recursive</a> function that does what you want.<br />
</p>
</div>
</div>




<div id="outline-container-orgb0f6df5" class="outline-3">
<h3 id="orgb0f6df5"><span class="section-number-3">4.9.</span> <a href="#orgc8b66b2">Sets</a></h3>
<div class="outline-text-3" id="text-4-9">
<p>
Lists are a good way to represent small <b><a id="orgc8b66b2">sets</a></b>. Every element of a <a href="#org1a9ed34">list</a> is a member of the set it represents:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (member 'b '(a b c))
(B C)  
</pre>
</div>
<p>
When <code>member</code> returns true, instead of simply returning <code>t</code>, it returns the part of <a href="#org1a9ed34">list</a> beginning with the object it was looking for. Logically, a <a href="#org11893e9">cons</a> serves<br />
just as well as <code>t</code>, and this way the function returns more information.<br />
</p>


<p>
By default, <code>member</code> compares objects using <code>eql</code>. You can override this default by using something called a <b>keyword</b> argument. Many Common Lisp functions take one or more keyword arguments. The unusual thing about these arguments is that they are not matched with the corresponding parameters by their position, but by special tags, called <a href="#org88f010a">keywords</a>, that must precede them in the call. A keyword is a symbol preceded by a colon.<br />
</p>

<p>
One of the keyword arguments accepted by member is a <code>:test</code> argument.<br />
If you pass some function as the <code>:test</code> argument in a call to member, then that function will be used to test for equality instead of <code>eql</code>. So if we want to find a member of a <a href="#org1a9ed34">list</a> that is <code>equal</code> to a given object, we might say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (member '(b) '((a) (b) (c)))
NIL
CL-USER&gt; (member '(b) '((a) (b) (c)) :test #'equal)
((B) (C))  
</pre>
</div>

<p>
Keyword arguments are always optional. If any are included in a call, they come last; if more than one keyword argument is given, their order doesn't matter.<br />
</p>


<p>
The other keyword argument accepted by member is a <code>:key</code> argument. By providing this argument you can specify a function to be applied to each element before comparison:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (member 'b '((a b) (b c) (c d)))
NIL
CL-USER&gt; (member 'b '((a b) (b c) (c d)) :key #'car)
((B C) (C D))  
</pre>
</div>


<p>
If we want to find an element satisfying an arbitrary <b>predicate</b> - like <code>oddp</code>, which returns true for odd integers - we can use <code>member-if</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (member-if #'oddp '(1 2 3 4))
(1 2 3 4)
CL-USER&gt; (member-if #'oddp '(2 3 4))
(3 4)
</pre>
</div>

<p>
We could imagine a limited version of <code>member-if</code> being written:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-member-if (fn lst)
  (and (consp lst)
       (if (funcall fn (car lst))
           lst
           (our-member-if fn (cdr lst)))))
</pre>
</div>

<p>
The function <code>adjoin</code> is like a conditional <code>cons</code>. It takes an ojbect and a <a href="#org1a9ed34">list</a>, and conses the object onto the <a href="#org1a9ed34">list</a> only if it is not already a member:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (adjoin 'b '(a b c))
(A B C)
CL-USER&gt; (adjoin 'z '(a b c))
(Z A B C)  
</pre>
</div>

<p>
The operations of set union, intersection, and complement are implemented by the functions <code>union, intersection</code>, and <code>set-difference</code>. These functions expect exactly two lists, but also take the same keyword arguments as member.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (union '(a b c) '(c d e))
(B A C D E)
CL-USER&gt; (intersection '(a b c) '(b b c d))
(C B)
CL-USER&gt; (set-difference '(a b c d e) '(b e))
(D C A)  
</pre>
</div>
<p>
Since there is no notion of ordering in a set, these functions do not necessarily bother to preserve the order of elements found in the original lists.<br />
</p>
</div>
</div>

<div id="outline-container-org814b16e" class="outline-3">
<h3 id="org814b16e"><span class="section-number-3">4.10.</span> Sequences</h3>
<div class="outline-text-3" id="text-4-10">
<p>
Another way to think of a <a href="#org1a9ed34">list</a> is as a series of objects in a particular order. In Common Lisp, <b><a id="orgfef3696">sequence</a></b> include both lists and vectors. This section introduces some of the <a href="#orgfef3696">sequence</a> functions that are especially applicable to lists.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (length '(a b c))
3
</pre>
</div>

<p>
To copy part of a <a href="#orgfef3696">sequence</a>, we use <code>subseq</code>. The second argument (required) is the position of the first element to be included, and the third argument (optional) is the position of the first element not to be included. If the third argument is omitted, the subsequence goes all the way to the end of the original <a href="#orgfef3696">sequence</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (subseq '(a b c d) 1 2)
(B)
CL-USER&gt; (subseq '(a b c d) 1)
(B C D)  
</pre>
</div>

<p>
The function <code>reverse</code> returns a <a href="#orgfef3696">sequence</a> with the same elements as its argument, but in the reverse order:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (reverse '(a b c d))
(D C B A)  
</pre>
</div>

<p>
Common Lisp has a built-in sort function called <code>sort</code>. It takes a <a href="#orgfef3696">sequence</a> and a comparision and returns a <a href="#orgfef3696">sequence</a> with the same elements, sorted according to the function:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (sort '(1 3 5 2 4) #'&gt;)
(5 4 3 2 1)  
</pre>
</div>

<p>
You have to be careful when using <code>sort</code>, because it's <b>desctructive</b>. For efficiency reasons, <code>sort</code> is allowed to modify the <a href="#orgfef3696">sequence</a> given to it as an argument. So if you don't want your original <a href="#orgfef3696">sequence</a> modifed, pass a copy.<br />
</p>

<p>
The function <code>every</code> and <code>some</code> take a predicate and one or more sequences. When given one <a href="#orgfef3696">sequence</a>, they test whether the elements satisfy the predicate:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (every #'oddp '(1 3 5))
T
CL-USER&gt; (some #'oddp '(1 2 3))
T  
</pre>
</div>

<p>
If they are given more than one <a href="#orgfef3696">sequence</a>, teh predicate must take as many arguments as there are sequences, and arguments are drawn one at a time from all the sequences:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (every #'&gt; '(1 3 5) '(0 2 4))
T
</pre>
</div>
<p>
If the sequences are of different lengths, the shortest one determines the number of tests performed.<br />
</p>
</div>
</div>


<div id="outline-container-orgc4fa51c" class="outline-3">
<h3 id="orgc4fa51c"><span class="section-number-3">4.11.</span> <a href="#orgee5744c">Stacks</a></h3>
<div class="outline-text-3" id="text-4-11">
<p>
The representation of lists as conses makes it natural to use them as pushdown <b><a id="orgee5744c">stacks</a></b>. This is down so often that Common Lisp provides two <a href="#orge6ba26a">macros</a> for the purpose: <code>(push x y)</code> pushes <code>x</code> onto the front of the <a href="#org1a9ed34">list</a> <code>y</code>, and <code>(pop x)</code> removes and returns the first element of the <a href="#org1a9ed34">list</a> <code>x</code>.<br />
</p>

<p>
Both are defined in terms of <code>setf</code>. It's easy to translate calls if the arguments are constants or variables.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(push obj lst)
;; is equivalent to
(setf lst (cons obj lst))

(pop lst)
;; is equivalent to
(let ((x (car lst)))
  (setf lst (cdr lst))
  x)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst '(b))
(B)
CL-USER&gt; (push 'a lst)
(A B)
CL-USER&gt; lst
(A B)
CL-USER&gt; (setf lst-copy lst)
(A B)
CL-USER&gt; (pop lst)
A
CL-USER&gt; lst
(B)
CL-USER&gt; lst-copy
(A B)  
</pre>
</div>


<p>
The <code>pushnew</code> macro is a variant of <code>push</code> that uses <code>adjoin</code> instead of <code>cons</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x '(a b)))
           (pushnew 'c x)
           (pushnew 'a x)
           x)
(C A B)  
</pre>
</div>
<p>
Here, <code>c</code> gets pushed onto the <a href="#org1a9ed34">list</a>, but <code>a</code>, because it is already a member, does not.<br />
</p>
</div>
</div>


<div id="outline-container-org2c179f1" class="outline-3">
<h3 id="org2c179f1"><span class="section-number-3">4.12.</span> Dotted Lists</h3>
<div class="outline-text-3" id="text-4-12">
<p>
The kind of lists that can be built by calling <code>list</code> are more precisely known as <b><a id="orgd400c6b">proper list</a></b>. A <a href="#orgd400c6b">proper list</a> is either <code>nil</code>, or a <a href="#org11893e9">cons</a> whose cdr is a <a href="#orgd400c6b">proper list</a>. All the lists we've built so for have been proper lists.<br />
</p>

<p>
Conses are not just for building lists, however. Whenever you need a <a href="#orge221c9c">structure</a> with two fields you can use a <a href="#org11893e9">cons</a>. You will be able to use <code>car</code> to refer to the first field and <code>cdr</code> refer to the second.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (cons 'a 'b)
(A . B)
</pre>
</div>
<p>
Because this <a href="#org11893e9">cons</a> is not a <a href="#orgd400c6b">proper list</a>, it is displayed in <b><a id="orga095387">dot notation</a></b>. In <a href="#orga095387">dot notation</a>, the car and cdr of each <a href="#org11893e9">cons</a> are shown separated by a period.<br />
</p>


<p>
A <a href="#org11893e9">cons</a> that isn't a <a href="#orgd400c6b">proper list</a> is called a <b><a id="org7afcbf8">dotted list</a></b>. This is not a very good name, because conses that aren't proper lists are usually not meant to represent lists at all: <code>(a . b)</code> is just a two-part data <a href="#orge221c9c">structure</a>.<br />
</p>


<p>
You could express proper lists in <a href="#orga095387">dot notation</a> as well, but when Lisp displays a <a href="#orgd400c6b">proper list</a>, it will always use regular <b><a id="org0ceac1f">list notation</a></b>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; '(a . (b . (c . nil)))
(A B C)  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgca464d3" class="outline-3">
<h3 id="orgca464d3"><span class="section-number-3">4.13.</span> Assoc-lists</h3>
<div class="outline-text-3" id="text-4-13">
<p>
It is also natural to use conses to represent mappings. A <a href="#org1a9ed34">list</a> of conses is called an <b><a id="org35c8928">assoc-list</a></b> or <b><a id="org73b017c">alist</a></b>. Such a <a href="#org1a9ed34">list</a> could represent a set of translations, for example:<br />
</p>


<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf trans '((+ . "add") (- . "subtract")))
((+ . "add") (- . "subtract"))  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">((+ . "add") (- . "subtract"))
CL-USER&gt; (assoc '+ trans)
(+ . "add")
CL-USER&gt; (assoc '* trans)
NIL  
</pre>
</div>
<p>
If <code>assoc</code> doesn't find what it's looking for, it returns <code>nil</code>.<br />
</p>



<p>
Like <code>member</code>, the real <code>assoc</code> takes keyword arguments, including <code>:test</code> and <code>:key</code>. Common Lisp also defines an <code>assoc-if</code>, which is to <code>assoc</code> what<br />
<code>member-if</code> is to <code>member</code>.<br />
</p>
</div>
</div>



<div id="outline-container-orgbe3ea42" class="outline-3">
<h3 id="orgbe3ea42"><span class="section-number-3">4.14.</span> <a href="#org78c2eb2">Garbage</a></h3>
<div class="outline-text-3" id="text-4-14">
<p>
Lists can be slow for several reasons. They offer sequential instead of random access, so retriving a given element takes longer in <a href="#org1a9ed34">list</a> than an <a href="#orge488891">array</a>. Intervally, conses tend to be represented as pointers, so travering a <a href="#org1a9ed34">list</a> means travering a series of pointers, instead of simply incrementing an index, as in an <a href="#orge488891">array</a>. But these two costs can be small compared to the cost of allocating and recycling <a href="#org11893e9">cons</a> cells.<br />
</p>


<p>
<b>Automatic memory management</b> is one of Lisp's most valuable features. The Lisp system maintains a segment of memory called the <b><a id="org177347b">heap</a></b>. The system keeps track of unused memory in the <a href="#org177347b">heap</a> and doles it out as new objects are created. The function <code>cons</code>, for example, returns a newly allocated <a href="#org11893e9">cons</a>. Allocating memory from the <a href="#org177347b">heap</a> is sometimes generically known as <b><a id="org256e883">consing</a></b>.<br />
</p>


<p>
If such memory were never freed, Lisp would run out of space for new objects and have to shut down. So the system must periodically search through the <a href="#org177347b">heap</a>, looking for memory that is no longer needed. Memory that is no longer needed is called <b><a id="org78c2eb2">garbage</a></b>, and the scavenging operation is called <b><a id="orge333f43">garbage collection</a></b>, or <b>GC</b>.<br />
</p>



<p>
Where does <a href="#org78c2eb2">garbage</a> come from? Let's create some:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst (list 'a 'b 'c))
(A B C)
CL-USER&gt; (setf lst nil)
NIL  
</pre>
</div>


<p>
Initially we call <code>list</code> , which calls <code>cons</code>, which allocates new <a href="#org11893e9">cons</a> cells on the <a href="#org177347b">heap</a>. In this case we made three. After we set <code>lst</code> to <code>nil</code>, we no longer have any way of reaching the old value of <code>lst</code>, the <a href="#org1a9ed34">list</a> <code>(a b c)</code>.<br />
</p>


<p>
Since we have no way of reaching this <a href="#org1a9ed34">list</a>, it might as well not exist. Objects that we no longer have any way of reaching are <a href="#org78c2eb2">garbage</a>. The system can safely reuse these three <a href="#org11893e9">cons</a> cells.<br />
</p>



<p>
This way of managing memory is a great convenience to the programmer. You never have to allocate or deallocate memory explicitly. And this means that you never have to deal with the bugs that come from doing so. Memory leaks and dangling pointers are simply impossible in Lisp.<br />
</p>


<p>
But, like any technical advance, automatic memory management can work against you are not careful. The costs associated with using and recycling <a href="#org177347b">heap</a> space are sometimes refered to simply as the costs of <a href="#org256e883">consing</a>. This is reasonable, because unless a program never throws anything away, most of those conses are going to end up as <a href="#org78c2eb2">garbage</a> sooner or later.<br />
</p>


<p>
The trouble with <a href="#org256e883">consing</a> is, allocating storage and scavenging memory to reclaim it can be expensive compared to the routine operations of a program. Recent research has produced greatly improved <a href="#orge333f43">garbage collection</a> algorithms, but <a href="#org256e883">consing</a> will always cost something.<br />
</p>


<p>
<a href="#org256e883">Consing</a> is ok in prototypes and experiments, at least. And if you take advantage of the flexibility that lists give you in the early stages of a program, you're more likely to produce something that survives to the later stages.<br />
</p>
</div>
</div>
</div>



<div id="outline-container-orgcb62d42" class="outline-2">
<h2 id="orgcb62d42"><span class="section-number-2">5.</span> <span class="done DONE">DONE</span> <a href="#org36bef2b">Specialized</a> Data Structures</h2>
<div class="outline-text-2" id="text-5">
<p>
The preceding chapter discussed the <a href="#org1a9ed34">list</a>, Lisp's most versatile data <a href="#orge221c9c">structure</a>. This chapter shows how to use Lisp's other data structures: arrays (including vectors and <a href="#orgf8f4f91">strings</a>), structures, and <a href="#org2df624c">hash tables</a>. They may not be as flexible as lists, but they can make access faster, and take up less space.<br />
</p>
</div>


<div id="outline-container-org16dc56f" class="outline-3">
<h3 id="org16dc56f"><span class="section-number-3">5.1.</span> <span class="done DONE">DONE</span> Arrays</h3>
<div class="outline-text-3" id="text-5-1">
<p>
In Common Lisp, you can make an <b><a id="orge488891">array</a></b> with <code>make-array</code> with a <a href="#org1a9ed34">list</a> of dimensions as the first argument. To make a \(2\times 3\) <a href="#orge488891">array</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf arr (make-array '(2 3) :initial-element nil))
#2A((NIL NIL NIL) (NIL NIL NIL))  
CL-USER&gt; (setf arr (make-array '(2 3)))
#2A((0 0 0) (0 0 0))
</pre>
</div>

<p>
The <code>:initial-element</code> argument is optional. If it is provided, the whole <a href="#orge488891">array</a> will be initialized to that value.<br />
</p>


<p>
To retrieve an <a href="#orge488891">array</a> element we call <code>aref</code> (<a href="#orge488891">array</a> ref). As usual for Common Lisp access functions, <code>aref</code> is zero-indexed:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (aref arr 0 0)
0  
</pre>
</div>

<p>
To replace some element of an <a href="#orge488891">array</a>, we use <code>setf</code> with <code>aref</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf (aref arr 0 0) 'hello)
HELLO
CL-USER&gt; (aref arr 0 0)
HELLO  
</pre>
</div>


<p>
To denote a literal <a href="#orge488891">array</a>, we use the <code>#na</code> syntax, where \(n\) is the number of dimention in the <a href="#orge488891">array</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; #2a((hello nil nil) (nil nil nil))
#2A((HELLO NIL NIL) (NIL NIL NIL))  
</pre>
</div>


<p>
If the global <code>*print-array*</code> is <code>t</code>, <a href="#orge488891">array</a> will be displayed in this form:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf arr (make-array '(2 3) :initial-element nil))
#2A((NIL NIL NIL) (NIL NIL NIL))
CL-USER&gt; (setf *print-array* t)
T
CL-USER&gt; arr
#2A((NIL NIL NIL) (NIL NIL NIL))  
</pre>
</div>
<p>
Otherwise:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf *print-array* nil)
NIL
CL-USER&gt; arr
#&lt;(SIMPLE-ARRAY T (2 3)) {1001A60E0F}&gt;  
</pre>
</div>


<p>
If you want just a one-dimensional <a href="#orge488891">array</a>, you can give an integer instead of a <a href="#org1a9ed34">list</a> as the first argument to <code>make-array</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf vec (make-array 4 :initial-element nil))
#(NIL NIL NIL NIL)  
</pre>
</div>



<p>
A one-dimensional <a href="#orge488891">array</a> is also called a <b><a id="org8f5f037">vector</a></b>. You can create and fill one in a single step by calling <code>vector</code>, which will return a <a href="#org8f5f037">vector</a> of whatever arguments you give it:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (vector "a" 'b 3)
#("a" B 3)
CL-USER&gt; #("a" 'b 3)
#("a" 'B 3)
</pre>
</div>


<p>
You can use <code>aref</code> for <a href="#org8f5f037">vector</a> access, but there is a faster function called <code>svref</code> for use with vectors.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; vec
#("a" B 3)
CL-USER&gt; (aref vec 0)
"a"
CL-USER&gt; (svref vec 0)
"a"  
</pre>
</div>

<p>
The "sv" stands for "simple <a href="#org8f5f037">vector</a>", which is what all vectors are by default. A simpel <a href="#orge488891">array</a> is one that is neither adjustable, nor displaced, nor has a fill-pointer. Arrays are simple by default. A simple <a href="#org8f5f037">vector</a> is a simple <a href="#orge488891">array</a> of one dimention.<br />
</p>
</div>
</div>

<div id="outline-container-org4879292" class="outline-3">
<h3 id="org4879292"><span class="section-number-3">5.2.</span> <span class="done DONE">DONE</span> <a href="#orgf8f4f91">Strings</a> and <a href="#org9caef75">Characters</a></h3>
<div class="outline-text-3" id="text-5-2">
<p>
<b><a id="orgf8f4f91">Strings</a></b> are vectors of <b><a id="org9caef75">characters</a></b>. We denote a constant string as a series of <a href="#org9caef75">characters</a> surrounded by double-quotes, and an individual character <code>c</code> as <code>#\c</code>.<br />
</p>

<p>
Each character has a ssociated integer - usually, but not necessarily, the ASCII number. In most implementations, the function <code>char-code</code> returns the number associated with a character, and <code>code-char</code> returns the character associated with a number.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (char-code #\a)
97
CL-USER&gt; (code-char 97)
#\a  
</pre>
</div>

<p>
The function <code>char&lt;</code> (less than), <code>char&lt;=</code> (less than or equal), <code>char=</code> (equal), <code>char&gt;=</code> (greater than or equal), <code>char&gt;</code> (greater than), and <code>char/=</code> (different) compare <a href="#org9caef75">characters</a>.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (sort "elbow" #'char&lt;)
"below"  
</pre>
</div>

<p>
Because <a href="#orgf8f4f91">strings</a> are vectors, both <a href="#orgfef3696">sequence</a> functions and <a href="#orge488891">array</a> functions work on them. You could use <code>aref</code> to retrieve elements, for example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (aref "abc" 1)
#\b
CL-USER&gt; (elt "abc" 1)
#\b
</pre>
</div>
<p>
but with string you can use the faster <code>char</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (char "abc" 1)
#\b  
</pre>
</div>


<p>
You can use <code>setf</code> with <code>char</code> (or <code>aref</code>) to replace elements:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((str (copy-seq "Acheson")))
           (setf (char str 3) #\i)
           str)
"Achison"  
</pre>
</div>


<p>
If you want to compare two <a href="#orgf8f4f91">strings</a>, you can use the general <code>equal</code>, but there is also a function <code>string-equal</code> that ignores case:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (equal "ming" "ming")
T
CL-USER&gt; (equal "ming" "Ming")
NIL
CL-USER&gt; (string-equal "ming" "Ming")
T  
</pre>
</div>


<p>
There are several ways of building <a href="#orgf8f4f91">strings</a>. The most general is to use <code>format</code>. Calling <code>format</code> with <code>nil</code> as the first argument makes it return as a string what it would have printed:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format nil "~A or ~A" "true" "false")
"true or false"  
</pre>
</div>

<p>
But if you just want to join several <a href="#orgf8f4f91">strings</a> together, you can use <code>concatenate</code>, which takes a symbol indicating the type of the result, plus one or more sequences:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (concatenate 'string "do " "not " "worry")
"do not worry"  
</pre>
</div>
</div>
</div>




<div id="outline-container-org3127e44" class="outline-3">
<h3 id="org3127e44"><span class="section-number-3">5.3.</span> <span class="done DONE">DONE</span> Sequences</h3>
<div class="outline-text-3" id="text-5-3">
<p>
In Common Lisp the type <code>sequence</code> includes both lists and vectors (and therefore <a href="#orgf8f4f91">strings</a>). Some of the functions that we have been using on lists are actually <a href="#orgfef3696">sequence</a> functions, including <code>remove, length, subseq, reverse, sort, every</code>, and <code>some</code>.<br />
</p>



<p>
We've already seen four functions for retrieving elements of sequences: <code>nth</code> for lists, <code>aref</code> and <code>svref</code> for vectors, and <code>char</code> for <a href="#orgf8f4f91">strings</a>. Common Lisp also provides a function <code>elt</code> that works for sequences of any kind:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (elt '(a b c) 1)
B  
</pre>
</div>
<p>
For sequences of specific <a href="#orgcc779bc">types</a>, the access functions we've already seen should be faster, so there is no point in using <code>elt</code> except in code that is supposed to work for sequences generally.<br />
</p>


<p>
Many <a href="#orgfef3696">sequence</a> functions take one or more keyword arguments from the standard set listed in this table:<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><a href="#org44ae6ab">PARAMETER</a></td>
<td class="org-left">PURPOSE</td>
<td class="org-left">DEFAULT</td>
</tr>

<tr>
<td class="org-left">:key</td>
<td class="org-left">a function to apply to each element</td>
<td class="org-left">identity</td>
</tr>

<tr>
<td class="org-left">:test</td>
<td class="org-left">the test function for comparison</td>
<td class="org-left">eql</td>
</tr>

<tr>
<td class="org-left">:from-end</td>
<td class="org-left">if true, work backwards</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-left">:start</td>
<td class="org-left">postion at which to start</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">:end</td>
<td class="org-left">position, if any, at which to stop</td>
<td class="org-left">nil</td>
</tr>
</tbody>
</table>




<p>
One function that takes the full set is <code>position</code>, which returns the position of an element in a <a href="#orgfef3696">sequence</a>, or <code>nil</code> if it is not found.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (position #\a "fantasia")
1
CL-USER&gt; (position #\a "fantasia" :start 3 :end 5)
4
CL-USER&gt; (position #\a "fantasia" :from-end t)
7
CL-USER&gt; (position 'a '((c d) (a b)) :key #'car)
1
CL-USER&gt; (position '(a b) '((a b) (c d)))
NIL
CL-USER&gt; (position '(a b) '((a b) (c d)) :test #'equal)
0
CL-USER&gt; (position 3 '(1 0 7 5) :test #'&lt;)
2
CL-USER&gt; (position 3 '(1 0 7 5) :test #'&gt;)
0  
</pre>
</div>

<p>
To find an element satisfying a predicate of one argument, we use <code>position-if</code>. It takes a function and a <a href="#orgfef3696">sequence</a>, and returns the position of the first element satisfying the function:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (position-if #'oddp '(2 3 4 5))
1
</pre>
</div>
<p>
It takes all the keyword arguments except <code>:test</code>.<br />
</p>

<p>
There are functions similar to <code>member</code> and <code>member-if</code> for sequences. They are, respectively, <code>find</code> (which takes all the keyword arguments) and <code>find-if</code> (which takes all except <code>:test</code>):<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (find #\a "cat")
#\a
CL-USER&gt; (find-if #'characterp "ham")
#\h  
</pre>
</div>
<p>
Unlike <code>member</code> and <code>member-if</code>, they return only the object they were looking for.<br />
</p>


<p>
The function <code>remove-duplicates</code> preserves only the last of each occurrence of any element of a <a href="#orgfef3696">sequence</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (remove-duplicates "abcdeabcd")
"eabcd"  
</pre>
</div>
<p>
This function takes all the keyword arguments listed in the preceding table.<br />
</p>


<p>
The function <code>reduce</code> is for boiling down a <a href="#orgfef3696">sequence</a> into a single value. It takes at least two arguments, a function and a <a href="#orgfef3696">sequence</a>. The function must be a function of two arguments. In the simplest case, it will be called initially with the first two elements, and thereafter with successive elements as the second argument, and the value it returned last time as the first. The value returned by the last call is returned as the value of the <code>reduce</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (reduce #'intersection '((a b c d e) (c d e) (c d x y z)))
(C D)  
</pre>
</div>
</div>
</div>



<div id="outline-container-org8c2276b" class="outline-3">
<h3 id="org8c2276b"><span class="section-number-3">5.4.</span> <span class="done DONE">DONE</span> Structures</h3>
<div class="outline-text-3" id="text-5-4">
<p>
A <b><a id="orge221c9c">structure</a></b> can be considered as a deluxe kind of <a href="#org8f5f037">vector</a>. Suppose you have to write a program that kept track of a number of rectangular solids. You might consider representing then as vectors of three elements: height, width, and depth. Your program would be easier to read if, instead of using raw <code>svref</code>, you defined functions like<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun block-height (b) (svref b 0))
</pre>
</div>
<p>
and so on. You can think of a <a href="#orge221c9c">structure</a> as a <a href="#org8f5f037">vector</a> in which all these kinds of functions get defined for you. Using filed name to replace the position in a <a href="#org8f5f037">vector</a>.<br />
</p>



<p>
To define a <a href="#orge221c9c">structure</a>, we use <code>defstruct</code>. In the simplest case we just give the name of the <a href="#orge221c9c">structure</a> and the name of the fields:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defstruct point
  x
  y)
</pre>
</div>


<p>
This defines a <code>point</code> to be a <a href="#orge221c9c">structure</a> with two fields, <code>x</code> and <code>y</code>. It also implicitly defined the functions <code>make-point</code>, <code>point-p</code>, <code>copy-point</code>, <code>point-x</code>, and <code>point-y</code>.<br />
</p>

<p>
Lisp programs could write Lisp programs. This is one of the most conspicuous examples. When you call <code>defstruct</code>, it automatically writes code defining several other functions. With <a href="#orge6ba26a">macros</a> you will be able to do the same thing yourself.<br />
</p>


<p>
Each call to <code>make-point</code> will reuturn a new <code>point</code>. We can specify the values of individual fields by giving the corresponding keyword arguments:<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defstruct point x y)
POINT
CL-USER&gt; (setf p (make-point :x 0 :y 0))
#S(POINT :X 0 :Y 0)  
</pre>
</div>

<p>
The access functions for <code>point</code> fields are defined not only to retrieve values, but to work with <code>setf</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (point-x p)
0
CL-USER&gt; (setf (point-y p) 2)
2
CL-USER&gt; p
#S(POINT :X 0 :Y 2)  
</pre>
</div>

<p>
Defining a <a href="#orge221c9c">structure</a> also defines a type of that name. Each point will be of type <code>point</code>, then <code>structure</code>, then <code>atom</code>, then <code>t</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (point-p p)
T
CL-USER&gt; (typep p 'point)
T  
</pre>
</div>


<p>
We can specify default values for <a href="#orge221c9c">structure</a> fields by enclosing the field name and a default expression in <a href="#org73b017c">alist</a> in the original definition:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defstruct polemic
  ;; field: type. with default value read from input.
  (type (progn
          (format t "What kind of polemic was it? ")
          (read)))
  ;; field: effect. with default value nil.
  (effect nil))
</pre>
</div>


<p>
If a call to <code>make-polemic</code> specifies no initial values for these fields, they will be set to the values of the corresponding expressions:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (make-polemic)
What kind of polemic was it? scathing
#S(POLEMIC :TYPE SCATHING :EFFECT NIL)  
</pre>
</div>


<p>
We can also control things like the way a <a href="#orge221c9c">structure</a> is displayed, and the prefix used in the name of the access functions it creates. Here is a more elaborate definition for <code>point</code> that does both:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defstruct (point (:conc-name p)
                  (:print-function print-point))
  (x 0)
  (y 0))

(defun print-point (p stream depth)
  (format stream "#&lt;~A,~A&gt;" (px p) (py p)))
</pre>
</div>

<p>
The <code>:conc-name</code> argument specifies what should be concatenated to the front of the field name to make access functions for them. By default it was <code>point-</code>; now it will be simply <code>p</code>. Not using the default makes you code a little less readable, so you would only want to do this kind of thing if you are goint to be using the acess functions constantly.<br />
</p>

<p>
The <code>:print-function</code> is the name of the function that should be used to print a point when it has to be displayed - e.g. by the <a href="#org4641b96">toplevel</a>. This function must take three arguments: the <a href="#orge221c9c">structure</a> to be printed, the place where it is to be printed, and a third argument that can usually be ignored.<br />
</p>


<p>
The function <code>print-point</code> will display points in an abbreviated form:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (make-point)
#&lt;0,0&gt;  
</pre>
</div>
</div>
</div>


<div id="outline-container-orga400538" class="outline-3">
<h3 id="orga400538"><span class="section-number-3">5.5.</span> <span class="done DONE">DONE</span> <a href="#org2df624c">Hash Tables</a></h3>
<div class="outline-text-3" id="text-5-5">
<p>
Lists could be used to represent both <a href="#orgc8b66b2">sets</a> and mappings. When either grow to a substantial size (say 10 elements) it will be faster to use <b><a id="org2df624c">hash tables</a></b>. You can create a hash table by calling <code>make-hash-table</code>, which has no required arguments:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf ht (make-hash-table))
#&lt;HASH-TABLE :TEST EQL :COUNT 0 {1003A5F6F3}&gt;  
</pre>
</div>


<p>
A hash table, like an <a href="#org35c8928">assoc-list</a>, is a way of associating pairs of objects. To retrieve the value associated with a given key, we call <code>gethash</code> with a key and a hash table. By default, <code>gethash</code> return <code>nil</code> when there is no value associated with the key.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (gethash 'color  ht)
NIL
NIL  
</pre>
</div>

<p>
Here we see for the first time one of the distinctive features of Common Lisp: an expression can return <a href="#org32b8297">multiple values</a>. The function <code>gethash</code> returns two. The first is the value associated with the key, and the second says whether the hash table has any value stored under that key. Because the second value is <code>nil</code>, we know that the first <code>nil</code> was returned by default, not because <code>nil</code> was explicitly associated with <code>color</code>.<br />
</p>


<p>
Most implementations will display all the return values of a call made at the <a href="#org4641b96">toplevel</a>, but code that expects only one return value will get just the first.<br />
</p>


<p>
To associate a value with a key, we use <code>setf</code> with <code>gethash</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf (gethash 'color ht) 'red)
RED
CL-USER&gt; (gethash 'color ht)
RED
T
</pre>
</div>


<p>
The second return value proves that now we're getting a real stored object and not just a default.<br />
</p>


<p>
The objects stored in a hash table or used as keys can be any type.<br />
</p>


<p>
You can use hash table instead of lists to represent <a href="#orgc8b66b2">sets</a>. When the <a href="#orgc8b66b2">sets</a> become large, lookups and deletions should be much faster with <a href="#org2df624c">hash tables</a>. To add a member to a set represented as a hash table, <code>setf</code> the <code>gethash</code> of it to <code>t</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf fruit (make-hash-table))
#&lt;HASH-TABLE :TEST EQL :COUNT 0 {1003D34283}&gt;
CL-USER&gt; (setf (gethash 'apricot fruit) t)
T
CL-USER&gt;   
</pre>
</div>

<p>
Then to test for membership you just call <code>gethash</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (gethash 'apricot fruit)
T
T  
</pre>
</div>


<p>
To remove an object from a set, you would call <code>remhash</code>, which removes an entry from a hash table:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (remhash 'apricot fruit)
T
</pre>
</div>
<p>
The return value shows whether there was an entry to remove; in this case there was.<br />
</p>




<p>
There is an iteration function for <a href="#org2df624c">hash tables</a>: <code>maphash</code>, which takes a function of two arguments and a hash table. The function will be called on every key/value pair in the table, in no particular order:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf (gethash 'shape ht) 'spherical
               (gethash 'size ht) 'giant)
GIANT
CL-USER&gt; (maphash #'(lambda (k v)
                      (format t "~A = ~A~%" k v))
                  ht)
COLOR = RED
SHAPE = SPHERICAL
SIZE = GIANT
NIL  
</pre>
</div>



<p>
<a href="#org2df624c">Hash tables</a> can accommodate any number of elements, because they are expanded when they run out of space. If you want to ensure that a hash table starts with room for a particular number of elements, you can give the optional <code>:size</code> argument to <code>make-hash-table</code>. There are two reasons to do this: because you know the hash table is going to be huge, and you want to avoid expanding it; or because you know the hash table is going to be small, and you don't want to waste memory. The <code>:size</code> argument specifies not the number of spaces in the hash table, but the number of elements, on the average, it will be able to accommodate before being expanded. So<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (make-hash-table :size 5)
#&lt;HASH-TABLE :TEST EQL :COUNT 0 {10040B0633}&gt;  
</pre>
</div>
<p>
would return a hash table intended to hold up to five elements.<br />
</p>

<p>
Like any <a href="#orge221c9c">structure</a> involved in lookups, <a href="#org2df624c">hash tables</a> must have some notion of equality for keys. By default they use <code>eql</code>, but you can specify that a hash table should use <code>eq</code>, <code>equal</code>, or <code>equalp</code> instead by providing the optional <code>:test</code> argument:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (make-hash-table :test #'equal)
#&lt;HASH-TABLE :TEST EQUAL :COUNT 0 {10042B07D3}&gt;  
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org0ad3201" class="outline-2">
<h2 id="org0ad3201"><span class="section-number-2">6.</span> <span class="done DONE">DONE</span> Control</h2>
<div class="outline-text-2" id="text-6">
<p>
What the operators in this chapter have in common is that they all violate the <a href="#orge23b230">evaluation rule</a>. They let you direct the course that evaluation will take through the text of a program.<br />
</p>
</div>


<div id="outline-container-orga58f047" class="outline-3">
<h3 id="orga58f047"><span class="section-number-3">6.1.</span> <span class="done DONE">DONE</span> <a href="#orgb7e4be1">Blocks</a></h3>
<div class="outline-text-3" id="text-6-1">
<p>
Common Lisp has three basic operators for creating <b><a id="orgb7e4be1">blocks</a></b> of code: <code>progn</code>, <code>block</code>, and <code>tagbody</code>.<br />
</p>


<p>
The expressions within <code>progn</code> are evaluated in order and the value of the last is returned:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (progn
           (format t "a")
           (format t "b")
           (+ 11 12))
ab
23  
</pre>
</div>
<p>
Since only the value of the last expression is returned, the use of <code>progn</code> (or any block) implies side-effects.<br />
</p>



<p>
A <code>block</code> is like <code>progn</code> with a name and an emergency exit. The first argument should be a symbol. This becomes the name of the block. At any point within the body, you can halt evaluation and return a value immediately by using <code>return-from</code> with the block name:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (block head
           (format t "Here we go.")
           (return-from head 'idea)
           (format t "We'll never see this."))
Here we go.
IDEA  
</pre>
</div>
<p>
Calling <code>return-from</code> allows your code to make a sudden but graceful exit from anywhere in a body of code. The second argument to <code>return-from</code> is returned as the value of the block named by the first. Expressions after the <code>return-from</code> are not evaluated.<br />
</p>


<p>
There is also a <code>return</code> macro, which returns its argument as the value of an enclosing block named <code>nil</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (block nil
           (return 27))
27  
</pre>
</div>

<p>
Many Common Lisp operators that take a body of expressions implicitly enclose the body in a block named <code>nil</code>. All iteration constructs do, for example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (dolist (x '(a b c d e))
           (format t "~A " x)
           (if (eql x 'c)
               (return 'done)))
A B C 
DONE  
</pre>
</div>


<p>
The body of a function defined with <code>defun</code> is implicitly enclosed in a block with the same name as the function:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun foo ()
  (return-from foo 27))
</pre>
</div>
<p>
Outside of an explicit or implicit <code>block</code>, neither <code>return-from</code> nor <code>return</code> will work.<br />
</p>

<p>
The third basic block construct is <code>tagbody</code>, within which you can use gotos. <a href="#org726a58e">Atoms</a> appearing in the body are interpreted as labels, giving such a label to go sends control to the expression following it. Here is an exceedingly ugly piece of code printing out the numbers from 1 to 10:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(tagbody
   (setf x 0)
   top
   (setf x (+ x 1))
   (format t "~A " x)
   (if (&lt; x 10)
       (go top)))
</pre>
</div>
<p>
This operator is mainly something that other operators are built upon, not something you would use yourself. Most iteration operators have an implicit <code>tagbogy</code>, so it's possible (thought rarely desirable) to use labels and <code>go</code> within their bodies.<br />
</p>



<p>
How do you decide which block construct to use? Nearly all the time you'll use <code>progn</code>. If you want to allow for sudden exits, use <code>block</code> instead. Most programmers will never use <code>tagbody</code> explicitly.<br />
</p>
</div>
</div>


<div id="outline-container-org8bec33b" class="outline-3">
<h3 id="org8bec33b"><span class="section-number-3">6.2.</span> <span class="done DONE">DONE</span> Context</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Another operator to group expression is <code>let</code>. It takes a body of code, but also allows us to establish new variables for use within the body:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 7)
               (y 2))
           (format t "Number")
           (+ x y))
Number
9
</pre>
</div>
<p>
An operator like <code>let</code> creates a new <b><a id="org305427e">lexical context</a></b>.  Within this context there are two new variables and variables from outer contexts may thereby become invisible.<br />
</p>


<p>
Conceptually, a <code>let</code> expression is like a function call. The preceding <code>let</code> expression is exactly equivalent to:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">((lambda (x y)
   (format t "Number")
   (+ x y))
 7 2)
</pre>
</div>
<p>
Any questions you have about <code>let</code> should be dealt with by passing the buck to <code>lambda</code>, because entering a <code>let</code> is conceptually equivalent to doing a function call.<br />
</p>


<p>
One of the thing this model makes clear is that the value of one <code>let</code> created <a href="#orge9b5a96">variable</a> can't depend on other variables create by the say <code>let</code>. For example, if we tried to say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 2)
      (y (+ x 1)))
  (+ x y))
</pre>
</div>
<p>
then the <code>x</code> in <code>(+ x 1)</code> would not be the <code>x</code> established in the previous line, because the whole expression is equivalent to<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">((lambda (x y)
   (+ x y))
 2
 (+ x 1))
</pre>
</div>
<p>
Here it's obvious that <code>(+ x 1)</code> passed as an argument to the function cannot refer to the <a href="#org44ae6ab">parameter</a> <code>x</code> within the function.<br />
</p>


<p>
So what if you do want the value of one new <a href="#orge9b5a96">variable</a> to depend on the value of another <a href="#orge9b5a96">variable</a> established by the same expression? In that case you would use a variant called <code>let*</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let* ((x 1)
                (y (+ x 1)))
           (+ x y))
3  
</pre>
</div>


<p>
A <code>let*</code> is functionally equivalent to a series of nested <code>lets</code>. This particular example is equivalent to:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 1))
  (let ((y (+ x 1)))
    (+ x y)))
</pre>
</div>



<p>
In both <code>let</code> and <code>let*</code>, initial values default to <code>nil</code>. Such variables need not be enclosed within lists:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let (x y)
           (list x y))
(NIL NIL)  
</pre>
</div>


<p>
The <code>destructuring-bind</code> macro is a generalization of <code>let</code>. Instead of single variables, it takes a pattern - one or more variables arranged in the form of a tree - and binds them to the corresponding parts of some actual tree. For example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (destructuring-bind (w (x y) . z) '(a (b c) d e)
           (list w x y z))
(A B C (D E))  
</pre>
</div>
<p>
It causes an error if the tree given as the second argument doesn't match the pattern given as the first.<br />
</p>
</div>
</div>


<div id="outline-container-org1849038" class="outline-3">
<h3 id="org1849038"><span class="section-number-3">6.3.</span> <span class="done DONE">DONE</span> Conditionals</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The simplest conditional is <code>if</code>; all the others are built upon it. The simplest after <code>if</code> is <code>when</code>, which takes an expression and a body of code. The body will be evaluated if the test expression returns true.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(when (oddp that)
  (format t "Hmm, that's good.")
  (+ that 1))
;; is equivalent to
(if (oddp that)
    (progn
      (format t "Hmm, that's good.")
      (+ that 1)))
</pre>
</div>

<p>
The opposite of <code>when</code> is <code>unless</code>, it takes the same arguments, but the body will be evaluated only if the test expression returns false.<br />
</p>


<p>
The mother of all conditionals (in both senses) is <code>cond</code>, which brings two new advantages: it allows multiple <a href="#org36dd4bd">conditions</a>, and the code associated with each has an implicit <code>progn</code>. It's intended for use in situations where we would otherwise have to make the third argument of an <code>if</code> another <code>if</code>. For example, this pseudo member:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-member (obj lst)
  (if (atom lst)
      nil
      (if (eql (car lst) obj)
          lst
          (our-member obj (cdr lst)))))
;; could also be defined as
(defun our-member (obj lst)
  (cond ((atom lst) nil)
        ((eql (car lst) obj) lst)
        (t (our-member obj (cdr lst)))))
</pre>
</div>
<p>
In fact, a Common Lisp implementation will probably implement <code>cond</code> by translating the latter into the former.<br />
</p>



<p>
In general, <code>cond</code> takes zero or more arguments. Each one must be a <a href="#org1a9ed34">list</a> consisting of a condition followed by zero or more expressions. When the <code>cond</code> expression is evaluated, the <a href="#org36dd4bd">conditions</a> are evaluated in order until one of them returns true. When it does, the expressions associated with it are evaluated in order, and the value of the last is returned as the value of the <code>cond</code>. If there are no expressions after the successful condition, the value of the condition itself is returned.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (cond (99))
99  
</pre>
</div>

<p>
Since a <code>cond</code> clause with a conditon of <code>t</code> will always succeed, it is conventional to make the final clause have <code>t</code> as the condition. If no clause succeeds, the <code>cond</code> returns <code>nil</code>, but it is usually bad style to take advantage of this return value.<br />
</p>



<p>
When you want to compare a value against a series of constants, there is <code>case</code>. For example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun month-length (mon)
  (case mon
    ((jar mar may jul aug oct dec) 31)
    ((apr jun sept nov) 30)
    (feb (if (leap-year) 29 28))
    (otherwise "unkown moth")))
</pre>
</div>
<p>
A <code>case</code> expression begins with an argument whose value will be compared against the keys in each clause. Then come zero or more clauses, each one beginning with either a key, or a <a href="#org1a9ed34">list</a> of keys, followed by zero or more expressions. The keys are treated as constants; they will not be evaluated. The value of the first argument is compared (using <code>eql</code>) to the key/s at the head of each clause. If there is a match, the expressions in the rest of that clause are evaluated, and the value of the last is returned as the value of the case.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (month-length 'jar)
31
CL-USER&gt; (month-length 'september)
"unkown moth"  
</pre>
</div>


<p>
The default clause may have the key <code>t</code> or <code>otherwise</code>. If no clause succeeds, or the successful clause contains only keys, then the case returns <code>nil</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (case 99 (99))
NIL
</pre>
</div>

<p>
The <code>typecase</code> macro is similar to case, except that the keys in each clause should be type specifiers, and the value of the first argument is compared to the keys using <code>typep</code> instead of <code>eql</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (typecase 1
           (number t))
T  
</pre>
</div>
</div>
</div>

<div id="outline-container-org0e8f6bc" class="outline-3">
<h3 id="org0e8f6bc"><span class="section-number-3">6.4.</span> <span class="done DONE">DONE</span> Iteration</h3>
<div class="outline-text-3" id="text-6-4">
<p>
The basic iteration operator is <code>do</code>. Since <code>do</code> contains both an implicit <code>block</code> and an implicit <code>tagbody</code>, it's possible to use <code>return</code>, <code>return-from</code>, and <code>go</code> within the body of a <code>do</code>.<br />
</p>

<p>
The first argument to <code>do</code> had to be a <a href="#org1a9ed34">list</a> of specifications for variables, each possibly of the form<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(variable initial update)
</pre>
</div>
<p>
The <code>initial</code> and <code>update</code> forms are optional. If the <code>update</code> form is omitted, the <a href="#orge9b5a96">variable</a> won't update on successive iterations. If the <code>initial</code> form is also omitted, the <a href="#orge9b5a96">variable</a> will be initially <code>nil</code>.<br />
</p>




<p>
When more than one <a href="#orge9b5a96">variable</a> is to be updated, the question arises, if an <code>update</code> form refers to a <a href="#orge9b5a96">variable</a> that has its own <code>update</code> form, does it get the updated value or the value from the previous iteration? With <code>do</code>, it gets the latter:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 'a))
           (do ((x 1 (+ x 1))
                (y x x))
               ((&gt; x 5))
             (format t "(~A ~A)  " x y)))
(1 A)  (2 1)  (3 2)  (4 3)  (5 4)  
NIL  
</pre>
</div>
<p>
On each iteration, <code>x</code> gets its previous value plus 1; <code>y</code> also get the <b>previous</b> value of <code>x</code>.<br />
</p>


<p>
There is also a <code>do*</code>, which has the same relation to <code>do</code> as <code>let*</code> does to <code>let</code>. Any <code>initial</code> or <code>update</code> form can refer to a <a href="#orge9b5a96">variable</a> from a previous clause, and it will get the current value:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (do* ((x 1 (+ x 1))
               (y x x))
              ((&gt; x 5))
           (format t "(~A ~A)  " x y))
(1 1)  (2 2)  (3 3)  (4 4)  (5 5)  
NIL  
</pre>
</div>

<p>
Besides <code>do</code> and <code>do*</code> there are several special-purpose iteration operators. To iterate over the elements of a <a href="#org1a9ed34">list</a>, we can use <code>dolist</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (dolist (x '(a b c d) 'done)
           (format t "~A " x))
A B C D 
DONE  
</pre>
</div>
<p>
The third expression within the initial <a href="#org1a9ed34">list</a> will be evaluated and returned as the value of the <code>dolist</code> when iteration terminates. It defaults to <code>nil</code>.<br />
</p>


<p>
Similar in spirit is <code>dotimes</code>, which for some <code>n</code> iterates over the integers from <code>O</code> to <code>n-1</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (dotimes (x 5 x)
           (format t "~A " x))
0 1 2 3 4 
5  
</pre>
</div>
<p>
As with <code>dolist</code>, the third expression in the initial <a href="#org1a9ed34">list</a> is optional and defaults to <code>nil</code>. Notice that it can refer to the iteration <a href="#orge9b5a96">variable</a>.<br />
</p>



<p>
The function <code>mapc</code> is like <code>mapcar</code> but does not <a href="#org11893e9">cons</a> up a new <a href="#org1a9ed34">list</a> a return value, so the only reason to use it is for side-effects. Like <code>mapcar</code>, It is also more flexible than <code>dolist</code>, because it can traverse multiple lists in parallel:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (mapc #' (lambda (x y)
                    (format t "~A ~A  " x y))
                  '(hip flip slip)
                  '(hop flop slop))
HIP HOP  FLIP FLOP  SLIP SLOP  
(HIP FLIP SLIP)  
</pre>
</div>
<p>
It always returns its second argument.<br />
</p>
</div>
</div>


<div id="outline-container-org3e212d2" class="outline-3">
<h3 id="org3e212d2"><span class="section-number-3">6.5.</span> <span class="done DONE">DONE</span> <a href="#org32b8297">Multiple Values</a></h3>
<div class="outline-text-3" id="text-6-5">
<p>
In Common Lisp, an expression can return zero or more values. <b><a id="org32b8297">Multiple values</a></b> allow a function that calculates several things to return them without having to build a <a href="#orge221c9c">structure</a> to contain them all. For example, the built-in <code>get-decoded-time</code> returns the current time in nine values: seconds, minutes, hours, day, month, year, day of the week, daylight savings time flag and time zone.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (get-decoded-time)
44
50
16
5
2
2024
0
NIL
5  
</pre>
</div>

<p>
<a href="#org32b8297">Multiple values</a> also make it possible to have lookup functions that can distinguish between finding <code>nil</code> and failing to find something. This is why <code>gethash</code> returns two values. Because it uses the second value to indicate success or failure, we can store <code>nil</code> in a hash table just like any other value.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((ht (make-hash-table)))
           (gethash 'color ht))
NIL
NIL
CL-USER&gt; (let ((ht (make-hash-table)))
           (setf (gethash 'color ht) nil)
           (gethash 'color ht))
NIL
T  
</pre>
</div>

<p>
The <code>values</code> function returns <a href="#org32b8297">multiple values</a>. It returns exactly the values you give it as arguments:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (values 'a nil (+ 1 2))
A
NIL
3  
</pre>
</div>




<p>
If a <code>values</code> expression is the last thing to be evaluated in the body of a function, its return values become those of the function. <a href="#org32b8297">Multiple values</a> are passed on intact through any number of returns:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; ((lambda ()
            ((lambda ()
               (values 1 2)))))
1
2
</pre>
</div>


<p>
However, if something is expecting only one value, all but the first will be discarded:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x (values 1 2)))
           x)
1  
</pre>
</div>
<p>
By using <code>values</code> with no arguments, it's possible to return no values. In that case, something expecting one will get <code>nil</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (values)
; No value
CL-USER&gt; (let ((x (values)))
           x)
NIL  
</pre>
</div>



<p>
To receive <a href="#org32b8297">multiple values</a>, we use <code>multiple-value-bind</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (multiple-value-bind (x y z) (values 1 2 3)
           (list x y z))
(1 2 3)
CL-USER&gt; (multiple-value-bind (x y z) (values 1 2)
           (list x y z))
(1 2 NIL)
CL-USER&gt; (multiple-value-bind (x y z) (values 1 2 3 4)
           (list x y z))
(1 2 3)  
</pre>
</div>
<p>
If there are more variables than values, the leftover ones will be <code>nil</code>. If there are more values than variables, the extra values will be discarded.<br />
</p>



<p>
You can pass on <a href="#org32b8297">multiple values</a> as the arguments to a second function using <code>multiple-value-call</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (multiple-value-call #'+ (values 1 2 3))
6  
</pre>
</div>

<p>
There is also a function <code>multiple-value-list</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (multiple-value-list (values 1 2 3))
(1 2 3)
</pre>
</div>
<p>
which is like using <code>multiple-value-call</code> with <code>#'list</code> as the first argument.<br />
</p>
</div>
</div>




<div id="outline-container-org9530600" class="outline-3">
<h3 id="org9530600"><span class="section-number-3">6.6.</span> <span class="done DONE">DONE</span> Aborts</h3>
<div class="outline-text-3" id="text-6-6">
<p>
You can use <code>return</code> to exit from a <code>block</code> at any point. Sometimes we want to do something even more drastic, and transfer control back through several function calls. To do this we use <code>catch</code> and <code>throw</code>. A <code>catch</code> expression takes a tag, which can be any kind of object, followed by a body of expressions.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun super ()
  (catch 'abort
    (sub)
    (format t "We'll never see this.")))

(defun sub ()
  (throw 'abort 99))
</pre>
</div>
<p>
The expressions are evaluated in order, as if in a <code>progn</code>. At any point within this code or code called by it, a <code>throw</code> with the corresponding tag will cause the catch expression to return immediately:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (super)
99
</pre>
</div>
<p>
A <code>throw</code> with a given tag will pass control through (and thereby kill) any catches with other tags in order to reach the one with the matching tag. If there is no pending <code>catch</code> with the right tag, the <code>throw</code> causes an error.<br />
</p>


<p>
Calling <code>error</code> also interrupts execution, but instead of transferring control to another point higher up in the calling tree, it transfers control to the Lisp error handler.<br />
</p>



<p>
Sometimes you want code to be proof against interruptions like <code>throws</code> and <code>errors</code>. By using an <code>unwind-protect</code>, you can ensure that such interruptions won't leave your program in an inconsistent state. An <code>unwind-protect</code> takes any number of arguments and returns the value of the first. However, the remaining expressions will be evaluated even if the evaluation of the first is interrupted.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x 1)
1
CL-USER&gt; (catch 'abort
           (unwind-protect
                (throw 'abort 99)
             (setf x 2)))
99
CL-USER&gt; x
2  
</pre>
</div>
<p>
Here, even though the <code>throw</code> sends control back to the waiting <code>catch</code>, <code>unwind-protect</code> ensures that the second expression gets evaluated on the way out. Whenever certain actions have to be followed by some kind of cleanup or reset, <code>unwind-protect</code> may be useful.<br />
</p>
</div>
</div>
</div>



<div id="outline-container-orgfdd9c66" class="outline-2">
<h2 id="orgfdd9c66"><span class="section-number-2">7.</span> <span class="done DONE">DONE</span> Functions</h2>
<div class="outline-text-2" id="text-7">
</div>

<div id="outline-container-orgd9c95f0" class="outline-3">
<h3 id="orgd9c95f0"><span class="section-number-3">7.1.</span> <span class="done DONE">DONE</span> <a href="#org51316b5">Global Functions</a></h3>
<div class="outline-text-3" id="text-7-1">
<p>
The predicate <code>fboundp</code> tells whether there is a function with a given symbol as its name. If a symbol is the name of a function, <code>symbol-function</code> will return it:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (fboundp '+)
#&lt;FUNCTION +&gt;
CL-USER&gt; (symbol-function '+)
#&lt;FUNCTION +&gt;  
</pre>
</div>


<p>
By setting the <code>symbol-function</code> of some name to a function,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf (symbol-function 'add2)
      #'(lambda (x) (+ x 2)))
</pre>
</div>
<p>
we thereby define a new global function, which we can use as if we had defined it with <code>defun</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (add2 1)
3  
</pre>
</div>

<p>
In fact, <code>defun</code> does little more than translate something like<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun add2 (x) (+ x 2))
</pre>
</div>
<p>
into the <code>setf</code> expression above. Using <code>defun</code> makes programs look nicer, and may help the compiler, but strictly speaking you don't need it to write programs.<br />
</p>



<p>
By making the first argument to <code>defun</code> a <a href="#org1a9ed34">list</a> of the form <code>(setf f)</code>, you define what happens when the first argument to <code>setf</code> is a call to <code>f</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">;; define primo as a synonym for `car`
CL-USER&gt; (defun primo (lst)
           (car lst))
PRIMO
CL-USER&gt; (primo '(a b c))
A
CL-USER&gt; (defun (setf primo) (val lst)
           (setf (car lst) val))
(SETF PRIMO)
CL-USER&gt; (let ((x (list 'a 'b 'c)))
           (setf (primo x) 480)
           x)
(480 B C)

;; This show that you define what happens when the first
;; argument to `setf` is a call to `f`.
CL-USER&gt; (defun mytest (lst) (car lst))
MYTEST
CL-USER&gt; (defun (setf mytest) (val lst)
           (setf (car lst) (list val val)))
(SETF MYTEST)
CL-USER&gt; (mytest '(a b c))
A
CL-USER&gt; (let ((x (list 'a 'b 'c)))
           (setf (mytest x) 480)
           x)
((480 480) B C)  
</pre>
</div>
<p>
In the definition of a function whose name is of the form <code>(setf f)</code>, the first <a href="#org44ae6ab">parameter</a> represents the new value, and the remaining parameters represent arguments to <code>f</code>.<br />
</p>


<p>
It's not necessary to define <code>primo</code> in order to define <code>(setf primo)</code>, but such definitions usually come in pairs.<br />
</p>



<p>
Since <a href="#orgf8f4f91">strings</a> are Lisp expressions, there is no reason they can't appear within bodies of code. A string by it self does not have side-effects, and so doesn't make any difference unless it's the last expression. If you make a string the first expression in the body of a function defined with <code>defun</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun foo (x)
  "I am document string."
  x)
</pre>
</div>
<p>
then that string will become the function's <a id="org1292dcd">documentation string</a>. The documentation for a globally defined function can be retrieved by calling <code>documentation</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">;; (documentation obj doc-type)
CL-USER&gt; (documentation 'foo 'function)
"I am document string."  
</pre>
</div>
</div>
</div>

<div id="outline-container-org345e505" class="outline-3">
<h3 id="org345e505"><span class="section-number-3">7.2.</span> <span class="done DONE">DONE</span> <a href="#org3966870">Local Functions</a></h3>
<div class="outline-text-3" id="text-7-2">
<p>
Functions defined via <code>defun</code> or <code>setf</code> of <code>symbol-function</code> are <b><a id="org51316b5">global functions</a></b>. Like global variables you have access to them anywhere. It is also possible to define <a href="#org3966870">local functions</a>, which like <a href="#orgf3afcdc">local variables</a>, are only accessible within a certain context.<br />
</p>

<p>
<b><a id="org3966870">Local functions</a></b> can be defined with <code>labels</code>, which is a kind of <code>let</code> for functions. Its first argument is a <a href="#org1a9ed34">list</a> of definitions of new <a href="#org3966870">local functions</a>. Each element of the <a href="#org1a9ed34">list</a> is of the form<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(name parameters . body)
</pre>
</div>
<p>
Within the ramainder of the <code>labels</code> expression, calling <i>name</i> is equivalent to calling <code>(lambda parameters . body)</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (labels ((add10 (x) (+ x 10))
                  (consa (x) (cons 'a x)))
           (consa (add10 3)))
(A . 13)  
</pre>
</div>

<p>
The analogy to <code>let</code> breaks down in one respect. <a href="#org3966870">Local functions</a> defined by a <code>labels</code> expression can refer to any other functions defined there, including themselves. So it's possible to define <a href="#org7e3c89d">recursive</a> <a href="#org3966870">local functions</a> this way:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (labels ((len (lst)
                    (if (null lst)
                        0
                        (+ (len (cdr lst)) 1))))
           (len '(a b c)))
3  
</pre>
</div>
</div>
</div>


<div id="outline-container-org565058d" class="outline-3">
<h3 id="org565058d"><span class="section-number-3">7.3.</span> <span class="done DONE">DONE</span> <a href="#org44ae6ab">Parameter</a> Lists</h3>
<div class="outline-text-3" id="text-7-3">
<p>
With <a href="#org058fc6e">prefix notation</a>, <code>+</code> could take any number of arguments. To write such functions, we need to use something called a <b><a id="org2450710">rest parameter</a></b>.<br />
</p>


<p>
If we insert the token <code>&amp;rest</code> before the last <a href="#orge9b5a96">variable</a> in the <a href="#org44ae6ab">parameter</a> <a href="#org1a9ed34">list</a> of function, then when the function is called, this <a href="#orge9b5a96">variable</a> will be set to a <a href="#org1a9ed34">list</a> of all the remaining arguments. Now we can see how <code>funcall</code> would be written in terms of <code>apply</code>. It might be defined as:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-funcall (fn &amp;rest args)
  (apply fn args))
</pre>
</div>



<p>
Arguments could be omitted and would default to certain values. Such parameters are called <b><a id="org953b219">optional parameters</a></b>. By contract, ordinary parameters are sometime called <b><a id="org5c23343">required parameters</a></b>. If the symbol <code>&amp;optinal</code> occurs in the <a href="#org44ae6ab">parameter</a> <a href="#org1a9ed34">list</a> of a function, then all the arguments after it are optional and default to <code>nil</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defun say (hello &amp;optional name)
           (list hello name))
SAY
CL-USER&gt; (say 'hello)
(HELLO NIL)
</pre>
</div>


<p>
We give an explicit default by enclosing it in a <a href="#org1a9ed34">list</a> with the parameters.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defun say (hello &amp;optional (name 'world))
           (list hello name))
SAY
CL-USER&gt; (say 'hello)
(HELLO WORLD)  
</pre>
</div>

<p>
The default for an optional <a href="#org44ae6ab">parameter</a> need not be a constant. It can be any Lisp expression. If this expression isn't a constant, it will be evaluated anew each time a default is needed.<br />
</p>



<p>
A <b><a id="orgce97b1c">keyword parameter</a></b> is a more flexible kind of optional <a href="#org44ae6ab">parameter</a>. If you put the symbol <code>&amp;key</code> in a <a href="#org44ae6ab">parameter</a> <a href="#org1a9ed34">list</a>, then all the parameters after it are optional. Moreover, when the function is called, these parameters will be identified not by their position, but by symbolic tags that precede them:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defun keylist (a &amp;key x y (z 40))
           (list a x y z))
KEYLIST
CL-USER&gt; (keylist 1 :y 2)
(1 NIL 2 40)
CL-USER&gt; (keylist 1 :y 3 :x 2)
(1 2 3 40)  
</pre>
</div>


<p>
<a href="#org88f010a">Keywords</a> and their associated arguments can be collected in rest parameters and passed on to other functions that are expecting them. For example, we could define <code>adjoin</code> as:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-adjoin (obj lst &amp;rest args)
  (if (apply #'member obj lst args)
      lst
      (cons obj lst)))
</pre>
</div>
<p>
Since <code>adjoin</code> takes the same keyword arguments as <code>member</code>, we just collect them in a rest argument and pass them on to <code>member</code>.<br />
</p>


<p>
Section <a href="#org8bec33b">6.2</a> introduced the <code>destructuring-bind</code> macro. In the general case, each subtree in the pattern given as the first argument may be as complex as the <a href="#org44ae6ab">parameter</a> <a href="#org1a9ed34">list</a> of a function:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (destructuring-bind ((&amp;key w x) &amp;rest y) '((:w 3) a)
           (list w x y))
(3 NIL (A))
CL-USER&gt; (destructuring-bind ((&amp;key w x) &amp;rest y) '((:w 3 :x 4) a b c d )
           (list w x y))
(3 4 (A B C D))
</pre>
</div>
</div>
</div>



<div id="outline-container-org1766a92" class="outline-3">
<h3 id="org1766a92"><span class="section-number-3">7.4.</span> <span class="done DONE">DONE</span> <a href="#orgc9c8777">Utilities</a></h3>
<div class="outline-text-3" id="text-7-4">
<p>
Lisp consists mostly of Lisp functions, just like the ones you can define yourself. This is a useful feature to have in a programming language: you don't have to modify your ideas to suit the language, because you can modify the language to suit your ideas. If you find yourself wishing that Common Lisp included a certain function, you can write it yourself, and it will be just as much a part of the language as <code>+</code> or <code>eql</code>.<br />
</p>


<p>
Experienced Lisp programmers work bottom-up as well as top-down. While they're writing their program down toward the language, they also build the language up toward their program. This way, language and program meet sooner, and more neatly.<br />
</p>


<p>
Operators written to augment Lisp are called <b><a id="orgc9c8777">utilities</a></b>. As you write more Lisp programs, you will find that you develop a collection of them, and that many of the <a href="#orgc9c8777">utilities</a> you write during one project will turn out to be useful in the next one.<br />
</p>



<p>
Professional programmers often find that the program they're working on now has a great deal in common with some program they wrote in the past. It is this feeling that makes the idea of software reuse so attractive. Somehow reuse has become associated with object-oriented programming. But software does not have to be object-oriented to be reusable — this is obvious when we look at programming languages (that is, compilers), which are the most reusable software of all.<br />
</p>


<p>
The way to get reusable software is to write programs bottom-up, and programs don't have to be object-oriented to be written bottom-up. In fact, the functional style seems even better adapted for writing reusable software. Consider <code>sort</code>. You are unlikely ever to have to write your own sort routines in Common Lisp; <code>sort</code> is so fast and so general that it would not be worth the trouble. That's reusable software.<br />
</p>


<p>
You can do the same thing in your own programs by writing <a href="#orgc9c8777">utilities</a>.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defun single? (lst)
  "Returns true when its argument is
is a list of one element."
  (and (consp lst) (null (cdr lst))))

(defun append1 (lst obj)
  "Adds an element to the end of the
list."
  (append lst (list obj)))

(defun map-int (fn n)
  "Takes a function and an integer n,
and returns a list of the results of
calling the function on the integers
from 0 to n-1."
  (let ((acc nil))
    (dotimes (i n)
      (push (funcall fn i) acc))
    ;; nreverse do the same thing as
    ;; reverse, but is more efficient.
    (nreverse acc)))

(defun filter (fn lst)
  "Takes a function and a list, and
return all the non-nil values returned
by the function as it is applied to the
elements of the list."
  (let ((acc nil))
    (dolist (x lst)
      (let ((val (funcall fn x)))
        (if val
            (push val acc))))
    (nreverse acc)))


(defun most (fn lst)
  "Returns the element of a list with
the highest score according to some
scoring function. It returns two values,
the winning element and its score."
  (if (null lst)
      (values nil nil)
      (let* ((wins (car lst))
             (max (funcall fn wins)))
        (dolist (obj (cdr lst))
          (let ((score (funcall fn obj)))
            (when (&gt; score max)
              (setf wins obj
                    max score))))
        (values wins max))))



</pre>
</div>

<p>
The usage of the above <a href="#orgc9c8777">utilities</a> is as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (single? '(a))
T
CL-USER&gt; (single? '())
NIL
CL-USER&gt; (single? '(a b))
NIL
CL-USER&gt; (append1 '(a b c) 'd)
(A B C D)
CL-USER&gt; (map-int #'identity 10)
(0 1 2 3 4 5 6 7 8 9)
CL-USER&gt; (map-int #'(lambda (x) (* x x)) 10)
(0 1 4 9 16 25 36 49 64 81)
CL-USER&gt; (map-int #'(lambda (x) (random 100)) 10)
(92 44 95 5 97 58 43 99 37 68)
CL-USER&gt; (filter #'(lambda (x)
                     (and (evenp x) (+ x 10)))
                 '(1 2 3 4 5 6 7))
(12 14 16)
CL-USER&gt; (most #'length '((a b) (a b c) (a)))
(A B C)
3  
</pre>
</div>


<p>
The last three functions all take functions as arguments. Lisp makes it convenient to pass functions as arguments, and that's one of the reasons it is so well suited to bottom-up programming. A successful utility must be general, and it's easier to abstract out the general when you can pass the specific as a functional argument.<br />
</p>
</div>
</div>



<div id="outline-container-org3256ab0" class="outline-3">
<h3 id="org3256ab0"><span class="section-number-3">7.5.</span> <span class="done DONE">DONE</span> Closures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></h3>
<div class="outline-text-3" id="text-7-5">
<p>
A function can be returned as the value of an expression just like any other kind of object. Here is a function that takes one argument and return a function to combine arguments of that type:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun combiner (x)
  (typecase x
    (number #'+)
    (list #'append)
    (t #'list)))
</pre>
</div>

<p>
On top of this we can build a general combination function<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun combine (&amp;rest args)
  (apply (combiner (car args))
         args))
</pre>
</div>
<p>
which takes arguments of any type and combines them in a way appropriate to their type. To simplify the example, we assume that the arguments will all be of the same type.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (combine 2 3)
5
CL-USER&gt; (combine '(a b) '(c d))
(A B C D)
CL-USER&gt; (combine "hello" "world")
("hello" "world")  
</pre>
</div>


<p>
<a id="orgd47414e">Lexical variable</a> are only valid within the context where they are defined. Along with this restriction comes the promise that they will continue to be valid for as long as something is using the context.<br />
</p>


<p>
If a function is defined within the scope of a <a href="#orgd47414e">lexical variable</a>, it can continue to refer to that <a href="#orge9b5a96">variable</a>, even if it is returned as a value outside the context where the <a href="#orge9b5a96">variable</a> was created. Here we create a function that adds 3 to its argument:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf fn (let ((i 3))
                    #'(lambda (x) (+ x i))))
#&lt;FUNCTION (LAMBDA (X)) {54A3E49B}&gt;
CL-USER&gt; (funcall fn 2)
5  
</pre>
</div>
<p>
When a function refers to a <a href="#orge9b5a96">variable</a> defined outside it, it's called a <b><a id="orga73600f">free variable</a></b>. A function that refers to a free <a href="#orgd47414e">lexical variable</a> is called a <b><a id="org2b27f68">closure</a></b>. The <a href="#orge9b5a96">variable</a> must persist as long as the function does.<br />
</p>

<p>
A <a href="#org2b27f68">closure</a> is a combination of a function and an environment. Closures are created implicitly whenever a function refers to something from the surrounding lexical environment.  This happens quietly in a function like the following one, but it is the same idea:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun add-to-list (num lst)
  (mapcar #'(lambda (x)
              (+ x num))
          lst))
</pre>
</div>
<p>
This function takes a number and a <a href="#org1a9ed34">list</a>, and returns a <a href="#org1a9ed34">list</a> of the sum of each element and the number. The <a href="#orge9b5a96">variable</a> <code>num</code> within the lambda expression is free, so in cases like this we're passing a <a href="#org2b27f68">closure</a> to <code>mapcar</code>.<br />
</p>



<p>
A more conspicuous example would be a function that returned a different <a href="#org2b27f68">closure</a> each time it was called. The following function returns an adder:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun make-adder (n)
  #'(lambda (x)
           (+ x n)))
</pre>
</div>
<p>
It takes a number, and returns a function that adds that number to its argument:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf add3 (make-adder 3))
#&lt;FUNCTION (LAMBDA (X) :IN MAKE-ADDER) {10026F8FEB}&gt;
CL-USER&gt; (funcall add3 2)
5
CL-USER&gt; (setf add27 (make-adder 27))
#&lt;FUNCTION (LAMBDA (X) :IN MAKE-ADDER) {100274B84B}&gt;
CL-USER&gt; (funcall add27 2)
29  
</pre>
</div>



<p>
We can even make several closures share variables. Here we define two functions that share a counter.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((counter 0))
  (defun our-reset ()
    (setf counter 0))
  (defun our-stamp ()
    (setf counter (+ counter 1))))
</pre>
</div>

<p>
Such a pair of functions might be used to create time-stamps. Each time we call <code>our-stamp</code> we get a number one higher than the previous, and by calling <code>our-reset</code> we can set the counter back to zero:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (list (our-stamp) (our-stamp) (our-reset) (our-stamp))
(1 2 0 1)  
</pre>
</div>
<p>
You could do the same thing with a global counter, but this way the counter is protected from unintended references.<br />
</p>



<p>
Common Lisp has a built-in function <code>complement</code> that takes a predicate and returns the opposite predicate. For example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (mapcar (complement #'oddp)
                 '(1 2 3 4 5 6))
(NIL T NIL T NIL T)  
</pre>
</div>
<p>
With closures such a function is easy to write:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-complement (f)
  #'(lambda (&amp;rest args)
      (not (apply f args))))
</pre>
</div>


<p>
Closures are one of the uniquely wonderful things about Lisp. They open the door to programming techniques that would be inconceivable in other languages.<br />
</p>
</div>
</div>





<div id="outline-container-orga2ab504" class="outline-3">
<h3 id="orga2ab504"><span class="section-number-3">7.6.</span> <span class="done DONE">DONE</span> <a href="#org8a25b2e">Dynamic Scope</a></h3>
<div class="outline-text-3" id="text-7-6">
<p>
Section <a href="#org7ec66f2">3.10</a> distinguished between local and global variables. The real distinction here is between lexical variables, which have <a id="orga3ba241">lexical scope</a>, and special variables, which have <a id="org8a25b2e">dynamic scope</a>. But it's almost the same distinction, because <a href="#orgf3afcdc">local variables</a> are nearly always lexical variables, and global variables are always special variables.<br />
</p>

<p>
Under <a href="#orga3ba241">lexical scope</a>, a symbol refers to the <a href="#orge9b5a96">variable</a> that has the name in the context where the symbol appears. <a href="#orgf3afcdc">Local variables</a> have <a href="#orga3ba241">lexical scope</a> by default. So if we define a function in an environment where there is a <a href="#orge9b5a96">variable</a> called <code>x</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 10))
  (defun foo ()
    x))
</pre>
</div>
<p>
then the <code>x</code> in the body will refer to that <a href="#orge9b5a96">variable</a>, regardless of any <code>x</code> that might exist where <code>foo</code> is called:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 20))
           (foo))
10
</pre>
</div>






<p>
With <a href="#org8a25b2e">dynamic scope</a>, we look for a <a href="#orge9b5a96">variable</a> in the environment where the function is called, not in the environment where it was defined. To cause a <a href="#orge9b5a96">variable</a> to have <a href="#org8a25b2e">dynamic scope</a>, we must declare it to be <code>special</code> in any context where it occurs. If we defined <code>foo</code> instead as<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((x 10))
  (defun foo ()
    (declare (special x))
    x))
</pre>
</div>
<p>
then the <code>x</code> within the function will no longer refer to the <a href="#orgd47414e">lexical variable</a> existing where the function was defined, but will refer to whatever speical <code>x</code> exists at the time the function is called:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 20))
           (declare (special x))
           (foo))
20  
</pre>
</div>
<p>
A <code>declare</code> can begin any body of code where new variables are created. The <code>special</code> declaration is unique, in that it can change the way a program behaves.<br />
</p>


<p>
Global variables established by calling <code>setf</code> at the <a href="#org4641b96">toplevel</a> are implicitly special:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x 30)
30
CL-USER&gt; (foo)
30  
</pre>
</div>
<p>
Within a file of code, it makes a program clearer if you don't rely on the implicit special declaration, and instead use <code>defparameter</code>.<br />
</p>




<p>
Where is <a href="#org8a25b2e">dynamic scope</a> useful? Usually it is used to give some <a href="#org402c5bb">global variable</a> a new value temporarily. For example, there are 11 global variables that control the way objects are printed, including <b>print-base</b>. If you want to display numbers in hexadecimal (base 16), you can do it by rebinding <b>print-base</b>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((*print-base* 16))
           (princ 32))
20
32  
</pre>
</div>
<p>
Two things are displayed here: the output generated by <code>princ</code>, and the value it returns. They represent the same number, displayed first in hexadecimal because <code>*print-base*</code> was 16 when it was printed, and the second time in decimal because, outside the let expression, <code>*print-base*</code> reverts to its previous value, 10.<br />
</p>


<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defparameter *ourglobal* 10)
*OURGLOBAL*
CL-USER&gt; *ourglobal*
10
CL-USER&gt; (let ((*ourglobal* 20))
           *ourglobal*)
20
</pre>
</div>
</div>
</div>



<div id="outline-container-org4dcd5e8" class="outline-3">
<h3 id="org4dcd5e8"><span class="section-number-3">7.7.</span> <span class="done DONE">DONE</span> Compilation</h3>
<div class="outline-text-3" id="text-7-7">
<p>
Compilations make the evaluation of expressions faster.<br />
</p>

<p>
Common Lisp functions can be compiled either individually or by file. You can check whether a function is compiled by passing it to <code>compiled-function-p</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defun foo (x)
           (+ x 1))
FOO
CL-USER&gt; (compiled-function-p #'foo)
T  
</pre>
</div>

<p>
You can also give the name of <code>foo</code> to <code>compile</code> to compile a function.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(compile 'foo)
</pre>
</div>



<p>
The usual way to compile Lisp code is not to compile functions individually, but to compile whole files with <code>compile-file</code>. This function takes a filename and creates a compiled version of the source file — typically with the same base name but a different extension. When the compiled file is loaded, <code>compiled-function-p</code> should return true for all the functions defined in the file.<br />
</p>




<p>
When one function occurs within another, and the containing function is compiled, the inner function should also be compiled. So when <code>make-adder</code> is compiled, it will return compiled functions:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun make-adder (n)
  #'(lambda (x)
      (+ x n)))  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (compile 'make-adder)
MAKE-ADDER
NIL
NIL
CL-USER&gt; (compiled-function-p (make-adder 2))
T  
</pre>
</div>
</div>
</div>




<div id="outline-container-org4a7a7c9" class="outline-3">
<h3 id="org4a7a7c9"><span class="section-number-3">7.8.</span> <span class="done DONE">DONE</span> Using Recursion</h3>
<div class="outline-text-3" id="text-7-8">
<p>
Recursion plays a greater role in Lisp than in most other languages. There seem to be three main reasons why:<br />
</p>
<ol class="org-ol">
<li><a href="#org2a7a2f8">Functional programming</a>. <a href="#org7e3c89d">Recursive</a> algorithms are less likely to involve side-effects.<br /></li>
<li><a href="#org7e3c89d">Recursive</a> data <a href="#orge221c9c">structure</a>. Lisp's implicit use of pointers makes it easy to have recursively defined data structures. The most common is the <a href="#org1a9ed34">list</a>: a <a href="#org1a9ed34">list</a> is either <code>nil</code>, or a <a href="#org11893e9">cons</a> whose cdr is a <a href="#org1a9ed34">list</a>.<br /></li>
<li>Elegance. Lisp programmers care a great deal about the beauty of their programs, and <a href="#org7e3c89d">recursive</a> algorithms are often more elegant than their iterative counterparts.<br /></li>
</ol>


<p>
<a href="#orgeca0508">4.8</a> pointed out, you don't have to think about all the invocations of a <a href="#org7e3c89d">recursive</a> function if you want to judge whether or not is correct. The same is true if you want to write a <a href="#org7e3c89d">recursive</a> function. If you can describe a <a href="#org7e3c89d">recursive</a> solution to a problem, it's usually straightforward to translate your solution into code. To solve a problem using recursion, you have to do two things:<br />
</p>
<ol class="org-ol">
<li>You have to show how to solve the problem in the general case by breaking it down into a finite number of similar, but smaller, problems.<br /></li>
<li>You have to show how to solve the smallest version of the problem — the base case — by some finite number of operations.<br /></li>
</ol>

<p>
If you can do this, you're done. You know that a finite problem will get solved eventually, because each recursion makes it smaller, and the smallest problem takes a finite number of steps.<br />
</p>

<p>
Some algorithms are most naturally expressed in recursion and some are not (which means most natually in iteration). Sometimes it may not be obvious which form will be more natural until you try to write the code.<br />
</p>


<p>
If you're concerned with efficiency, there are two more issues to consider.<br />
</p>
<ol class="org-ol">
<li>Tail-recursion.<br /></li>
<li>The obvious <a href="#org7e3c89d">recursive</a> algorithm is not always the most efficient.<br /></li>
</ol>


<p>
The classic example is the Fibonacci function. It is defined recursively,<br />
</p>
<ol class="org-ol">
<li>\(\text{Fib}(0) = \text{Fib(1) = 1}\)<br /></li>
<li>\(\text{Fib}(n) = \text{Fib}(n-1) + \text{Fib}(n-2)\)<br /></li>
</ol>


<p>
but the literal translation of this definition,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun fib (n)
  (if (&lt;= n 1)
      1
      (+ (fib (- n 1))
         (fib (- n 2)))))
</pre>
</div>
<p>
is appalliying inefficient. The same computations are done over and over. If you ask for <code>(fib 10)</code>, the function computes <code>(fib 9)</code> and <code>(fib 8)</code>. But to compute <code>(fib 9)</code>, it has to compute <code>(fib 8)</code> again, and so on.<br />
</p>


<p>
How often does this kind of thing happen in practice? Very rarely — that's why all textbooks use the same example — but it is something one should be aware of.<br />
</p>
</div>
</div>
</div>


<div id="outline-container-org48b97a3" class="outline-2">
<h2 id="org48b97a3"><span class="section-number-2">8.</span> <span class="done DONE">DONE</span> Input and Output</h2>
<div class="outline-text-2" id="text-8">
<p>
Common Lisp has powerful I/O facilities. For input, along with the usual functions for reading <a href="#org9caef75">characters</a>, we get <code>read</code>, which includes a complete parser. For output, along with the usual functions for writing <a href="#org9caef75">characters</a>, we get <code>format</code>, which is almost a language in its own right. This chapter introduces all the basic concepts.<br />
</p>

<p>
There are two kinds of streams, <a href="#orga068246">character streams</a> and binary streams.<br />
</p>
</div>


<div id="outline-container-orge6406f2" class="outline-3">
<h3 id="orge6406f2"><span class="section-number-3">8.1.</span> <span class="done DONE">DONE</span> <a href="#orga068246">Character Streams</a></h3>
<div class="outline-text-3" id="text-8-1">
<p>
<b><a id="orga068246">Character streams</a></b> are Lisp objects representing sources and/or destinations of <a href="#org9caef75">characters</a>. To read from or write to a file, you open it as a stream. But streams are not identical with files. When you read or print at the <a href="#org4641b96">toplevel</a>, you also use a stream. You can even create streams that read from or write to <a href="#orgf8f4f91">strings</a>.<br />
</p>

<p>
By default, input is read from the stream <code>*standard-input*</code>. The default place for output is <code>*standard-output*</code>. Initially they will probably be the same place: a stream representing the <a href="#org4641b96">toplevel</a>.<br />
</p>



<p>
Already we have seen <code>read</code> and <code>format</code> used to read from and print to the <a href="#org4641b96">toplevel</a>. The former takes an optional argument, which should be a stream, and defaults to <code>*standard-input*</code>. The first argument to <code>format</code> can also be a stream, but when it is <code>t</code>, the output is sent to <code>*standard-output*</code>. So what we have been doing so far is using the defaults. We could do the same I/O operations on any stream.<br />
</p>


<p>
A <a id="orgd03595c">pathname</a> is a portable way of specifying a file. A <a href="#orgd03595c">pathname</a> has six components: host, device, directory, name, type, and version. You can make one by calling <code>make-pathname</code> with one or more of the corresponding keyword arguments. In the simplest case, you could just specify the name and let the rest of the <a href="#orgd03595c">pathname</a> default:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf path (make-pathname :name "myfile"))
#P"myfile"  
</pre>
</div>



<p>
The basic function for opening a file is <code>open</code>. It takes a <a href="#orgd03595c">pathname</a> (You can give a string instead of a <a href="#orgd03595c">pathname</a>, but this is not portable.) and a large number of optional keyword arguments, and if successful, returns a stream that points to the file.<br />
</p>

<p>
You specify how you intend to use a stream when you create it. The <code>:direction</code> argument signals whether you are going to write to the stream, read from it, or both. The three corresponding values are <code>:input</code>, <code>:output</code>, and <code>:io</code>. If thestream is used for output,the <code>:if-exists</code> argument says what to do if the destination file already exists; usually it should be <code>:supersede</code>. So to create a stream on which you can write to the file "myfile", you might say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf str (open path :direction :output
                              :if-exists :supersede))
#&lt;SB-SYS:FD-STREAM for "file /Users/mingmingli/info/information-technology/programming-languages/common-lisp/myfile" {1004512DC3}&gt;  
</pre>
</div>
<p>
The printed representation of streams is implementation-dependent.<br />
</p>



<p>
Now if we give this stream as the first argument to <code>format</code>, it will print to the stream instead of the <a href="#org4641b96">toplevel</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format str "Something~%")
NIL
</pre>
</div>
<p>
If we look at the file at this point, the output may or may not be there. Some implementations save up output to write in chunks (<a href="#org2e0b77e">SBCL</a>). It may not all appear until we close the stream:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (close str)
T  
</pre>
</div>
<p>
Always close a file when you finished using it; nothing is guaranteed about its contents until you do.<br />
</p>




<p>
If we just want to read from a file, we open a stream with <code>:direction :input</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf str (open path :direction :input))
#&lt;SB-SYS:FD-STREAM for "file /Users/mingmingli/info/information-technology/programming-languages/common-lisp/myfile" {100188CCC3}&gt;
CL-USER&gt; (read-line str)
"Something"
NIL
CL-USER&gt; (close str)
T
CL-USER&gt;   
</pre>
</div>


<p>
Much of the time one does not use <code>open</code> and <code>close</code> directly to do file I/O. The <code>with-open-file</code> macro is often more convenient. Its first argument should be a <a href="#org1a9ed34">list</a> containing a <a href="#orge9b5a96">variable</a> name followed by arguments you might give to <code>open</code>. After this it takes a body of code, which is evaluated with the <a href="#orge9b5a96">variable</a> bound to a stream created by passing the remaining arguments to <code>open</code>. Afterward the stream is automatically closed. So our entire file-writing operation could be expressed:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (with-open-file (str path :direction :output 
                                   :if-exists :supersede)
           (format str "Something~%"))
NIL  
</pre>
</div>


<p>
The <code>with-open-file</code> macro puts the close within an <code>unwind-protect</code>, so the file is guaranteed to get closed, even if an error interrupts the evaluation of the body.<br />
</p>
</div>
</div>




<div id="outline-container-org387c863" class="outline-3">
<h3 id="org387c863"><span class="section-number-3">8.2.</span> <span class="done DONE">DONE</span> Input</h3>
<div class="outline-text-3" id="text-8-2">
<p>
The two most popular input functions are <code>read-line</code> and <code>read</code>.<br />
</p>


<p>
<code>read-line</code> reads all the <a href="#org9caef75">characters</a> up to a newline, returning them in a string. It takes an optional stream argument; if the stream is omitted, it will default to <code>*standard-input*</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (progn
           (format t "Plase enter your name: ")
           (read-line))
Plase enter your name: Mingming Li
"Mingming Li"
NIL  
</pre>
</div>
<p>
This is the function to use if you want verbatim input. The second return value is true only if <code>read-line</code> ran out of input before encountering a newline.<br />
</p>



<p>
In the general case, <code>read-line</code> takes four optional arguments:<br />
</p>
<ol class="org-ol">
<li>a stream;<br /></li>
<li>an argument to tell whether or not to cause an error on encountering end-of-file;<br /></li>
<li>what to return instead if the previous argument is <code>nil</code>;<br /></li>
<li>a fourth argument that can usually be ignored.<br /></li>
</ol>


<p>
So to display the contents of a file at the <a href="#org4641b96">toplevel</a>, we might use the following function:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun pseudo (file)
  (with-open-file (str file :direction :input)
    (do ((line (read-line str nil 'eof) (read-line str nil 'eof)))
        ((eql line 'eof))
      (format t "~A~%" line))))  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (pseudo "myfile")
Something
NIL  
</pre>
</div>





<p>
If you want input parsed into Lisp objects, use <code>read</code>. This function reads exactly one expression, and stops at the end of it. So it could read less than a line or more than a line. And of course what it reads has to be valid Lisp syntax.<br />
</p>


<p>
If we use <code>read</code> at the <a href="#org4641b96">toplevel</a>, it will let us use as many newlines as we want within an expression:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (read)
(a
 b
 c)
(A B C)
</pre>
</div>

<p>
On the other hand, if we type several expressions on a single line, <code>read</code> will stop processing <a href="#org9caef75">characters</a> after the first, leaving the remaining <a href="#org9caef75">characters</a> to be picked up by whatever reads next from this stream. So if in response to the prompt printed by <code>ask-number</code> we type several expressions on a line, the following will happen:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun ask-number ()
  (format t "Please enter a number. ")
  (let ((val (read)))
    (if (numberp val)
        val
        (ask-number))))  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (ask-number)
Please enter a number. a b
Please enter a number. Please enter a number. 1
1  
</pre>
</div>
<p>
Two successive prompts are printed on the second line. The first call to read returns <code>a</code>, which is not a number, so the function asks again for a number. But the first read only read up to the end of <code>a</code>. So the next call to read returns <code>b</code>, causing another prompt.<br />
</p>



<p>
You may want to avoid using <code>read</code> directly to process user input. The preceding function would be better off if it used <code>read-line</code> to get what the user typed, then called <code>read-from-string</code> on the resulting string. This function takes a string and returns the first expression read from it:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (read-from-string "a b c")
A
2  
</pre>
</div>
<p>
It also returns a second value, a number indicating the position in the string at which it stopped reading.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">(read-from-string string &amp;optional eof-error-p eof-value &amp;key start end preserve-whitespace)  
</pre>
</div>
<dl class="org-dl">
<dt>string</dt><dd>the string to read from<br /></dd>
<dt>eof-error-p</dt><dd>whether an end-to-end should cause an error<br /></dd>
<dt>oef-value</dt><dd>if not, what to return instead<br /></dd>
<dt>start</dt><dd>the start position to read from<br /></dd>
<dt>end</dt><dd>the end position in reading<br /></dd>
</dl>





<p>
All these input functions are defined in terms of the primitive <code>read-char</code>, which reads a single character. It takes the same four optional arguments as <code>read</code> and <code>read-line</code>. Common Lisp also defines a function called <code>peek-char</code>, which is like <code>read-char</code> but does not remove the character from the stream.<br />
</p>
</div>
</div>



<div id="outline-container-orgfadeb3c" class="outline-3">
<h3 id="orgfadeb3c"><span class="section-number-3">8.3.</span> <span class="done DONE">DONE</span> Output</h3>
<div class="outline-text-3" id="text-8-3">
<p>
The three <b>simplest</b> output functions are <code>prin1</code>, <code>princ</code>, and <code>terpri</code>. For all three the last argument is an optional stream argument, which defaults to <code>*standard-output*</code>.<br />
</p>



<p>
The difference between <code>prin1</code> and <code>princ</code> is roughly that <code>prin1</code> generates output for programs, and <code>princ</code> generates output for people. So, for example, <code>prin1</code> prints the double-quotes around a string, and <code>princ</code> doesn't:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (prin1 "hello")
"hello"
"hello"
CL-USER&gt; (princ "hello")
hello
"hello"  
</pre>
</div>

<p>
The function <code>terpri</code> just prints a newline:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (terpri)

NIL  
</pre>
</div>


<p>
The most general output function is <code>format</code>. This function can be used for almost all output. It takes a stream, a format string, and zero or more additional arguments. The format string may contain <a id="org57f45c8">format directives</a>, which are preceded by a ~ (tilde). Some <a href="#org57f45c8">format directives</a> act as placeholders in the string. Their places will be taken by the representations of the arguments given after the format string.<br />
</p>

<p>
If we give <code>t</code> as the first argument, output is sent to <code>*standard-output*</code>. If we give <code>nil</code>, format returns as a string what it would have printed.<br />
</p>


<p>
Depending on one's point of view, format is either amazingly powerful or horribly complex. There are a large number of <a href="#org57f45c8">format directives</a>, only a few of which most programmers will ever use. Two of the most commonly used <a href="#org57f45c8">format directives</a> are <code>~A</code> and <code>~%</code>. (It doesn't matter whether you say <code>~a</code> or <code>~A</code>, but the latter form is more common because it makes the format directive stand out.) A <code>~A</code> is a placeholder for a value, which will be printed as if by <code>princ</code>. A <code>~%</code>, represents a newline.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format nil "hello, ~A,~% how are you doing?" "Mingming Li")
"hello, Mingming Li,
 how are you doing?"  
</pre>
</div>


<p>
The <code>~S</code> format directive is just like <code>~A</code>, but prints objects as if by <code>prin1</code> , rather than <code>princ</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format nil "~S  ~A" "M" "M")
"\"M\"  M"
CL-USER&gt; (format t "~S  ~A" "M" "M")
"M"  M
NIL  
</pre>
</div>



<p>
<a href="#org57f45c8">Format directives</a> can take arguments. <code>~F</code>, which is used for printing right-justified floating-point numbers, can take up to five:<br />
</p>
<ol class="org-ol">
<li>The total number of <a href="#org9caef75">characters</a> to be printed. Defaults to the exact length of the number.<br /></li>
<li>The number of digits to print after the decimal. Defaults to all of them.<br /></li>
<li>The number of digits to shift the decimal point to the left (thereby effectively multiplying the number by 10). Defaults to none.<br /></li>
<li>The character to print instead of the number if it is too long to fit in the space allowed by the first argument. If no character is specified, an over-long number will be printed using as much space as it needs.<br /></li>
<li>The character to print to the left before the digits start. Defaults to a blank.<br /></li>
</ol>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format nil "~10,2,0,'*,' F" 3.1415926)
"      3.14"  
</pre>
</div>
<p>
This is the original number rounded to 2 decimal places, with the decimal point shifted left 0 places, right-justified in a field of 10 <a href="#org9caef75">characters</a>, padded on the left by blanks. Notice that a character given as an argument is written as <code>'*</code>, not the usual <code>#\*</code> . Since the number fit in 10 <a href="#org9caef75">characters</a>, the fourth argument didn't have to be used.<br />
</p>


<p>
All these arguments are optional. To use the default you can simply omit the corresponding argument. If all we want to do is print a number rounded to two decimal places, we can say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format nil "~,2,,,F" 3.1415926)
"3.14"  
</pre>
</div>


<p>
You can also omit a series of trailing commas, so the more usual way to write the preceding directive would be:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (format nil "~,2F" 3.1415926)
"3.14"  
</pre>
</div>
</div>
</div>


<div id="outline-container-org800cd4b" class="outline-3">
<h3 id="org800cd4b"><span class="section-number-3">8.4.</span> <span class="done DONE">DONE</span> Macro <a href="#org9caef75">Characters</a></h3>
<div class="outline-text-3" id="text-8-4">
<p>
A <a id="org27bb92c">macro character</a> is a character that gets special treatemet from <code>read</code>. For example, a lowercase <code>a</code> is ordinarily handled just like a lowercase <code>a</code>, but a left parenthesis is something different: it tells Lisp to begin reading a <a href="#org1a9ed34">list</a>.<br />
</p>


<p>
A <a href="#org27bb92c">macro character</a> or combination of macro <a href="#org9caef75">characters</a> is also known as a <a id="org106d8cc">read-macro</a> (<a id="org0ab7536">read-macros</a>). Many of Common Lisp's predefined <a href="#org0ab7536">read-macros</a> are abbreviations. Quote, for example: as an expression like <code>'a</code> is read, it is expanded by the reader into a <a href="#org1a9ed34">list</a>, <code>(quote a)</code>. When you type quoted expressions into the <a href="#org4641b96">toplevel</a>, they are evaluated as soon as they are read, so ordinarily you never see this transformation. You can make it visible by invoking <code>read</code> explicitly:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; 'a
A
CL-USER&gt; (car (read-from-string "'a"))
QUOTE  
</pre>
</div>


<p>
Quote is unusual for a <a href="#org106d8cc">read-macro</a> in that it's expressed in a single-character. With a limited character set, you can only have so a few one-character <a href="#org0ab7536">read-macros</a>; most of the <a href="#org0ab7536">read-macros</a> in Common Lisp are expressed using two or more <a href="#org9caef75">characters</a>.<br />
</p>

<p>
Such <a href="#org0ab7536">read-macros</a> are called <a id="org5c7168b">dispatching</a> <a href="#org0ab7536">read-macros</a>, and the first character is called the <a id="org8ff1e1a">dispatching character</a>. <b>All</b> the predefined <a href="#org5c7168b">dispatching</a> <a href="#org0ab7536">read-macros</a> use the sharp sign, <code>#</code>, as the <a href="#org8ff1e1a">dispatching character</a>. For example, <code>#'</code> is an abbreviation for <code>(function ...)</code>.<br />
</p>



<p>
Other <a href="#org5c7168b">dispatching</a> <a href="#org0ab7536">read-macros</a> we've seen include <code>#(...)</code>, which yields a <a href="#org8f5f037">vector</a>; <code>#nA(...)</code> which yields an <a href="#orge488891">array</a>; <code>#\</code>, which yields a character; and <code>#S(n ... )</code> , which yields a <a href="#orge221c9c">structure</a>. When objects of each of these <a href="#orgcc779bc">types</a> are displayed by <code>prin1</code> or (<code>format</code> with <code>~S</code>), they are displayed using the corresponding <a href="#org0ab7536">read-macros</a>. This means that you can write such objects out and read them back in:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (vectorp (read-from-string (format nil "~S" #(1 2))))
T
CL-USER&gt; (arrayp (read-from-string (format nil "~S" #2((1 2) (3 4)))))
T
CL-USER&gt; (characterp (read-from-string (format nil "~S" #\a)))
T
CL-USER&gt; (defstruct point x y)
POINT
CL-USER&gt; (make-point)
#S(POINT :X NIL :Y NIL)
CL-USER&gt; (point-p (read-from-string (format nil "~S" #S(point :X nil :Y nil))))
T  
</pre>
</div>
<p>
Of course, what we get back is not the same objct, but a new one with the same elements.<br />
</p>



<p>
Not all objects are displayed in a distinct, readable form. Both functions and <a href="#org2df624c">hash tables</a>, for example, tend to be displayed as <code>#&lt;...&gt;</code>. In fact, <code>#&lt;</code> is also a <a href="#org106d8cc">read-macro</a>, but one that exists specifically to cause an error if it is encountered by <code>read</code>. Functions and <a href="#org2df624c">hash tables</a> can't be written out and read back in, and this <a href="#org106d8cc">read-macro</a> ensures that users will have no illusions on this  point. (Lisp couldn't just use sharp-quote to represent functions, because sharp-quote by itself offers no way to represent a <a href="#org2b27f68">closure</a>.)<br />
</p>




<p>
When you're defining your own representations for things (the print-functions of structures, for example), you should keep this principle in mind. Either use a representation that can be read back in, or use <code>#&lt;...&gt;</code>.<br />
</p>
</div>
</div>
</div>




<div id="outline-container-org48b576e" class="outline-2">
<h2 id="org48b576e"><span class="section-number-2">9.</span> <span class="done DONE">DONE</span> Symbols</h2>
<div class="outline-text-2" id="text-9">
</div>

<div id="outline-container-orgfefc506" class="outline-3">
<h3 id="orgfefc506"><span class="section-number-3">9.1.</span> <span class="done DONE">DONE</span> Symbol Names</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Chapter <a href="#org4fa68fd">3</a> described symbols as <a href="#orge9b5a96">variable</a> names existing as objects in their own right. But the range of possible Lisp symbols is broader than the range of <a href="#orge9b5a96">variable</a> names allowed in most languages. In fact, a symbol can have any string as its name. You can get the name of a symbol by calling <code>symbol-name</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (symbol-name 'abc)
"ABC"  
</pre>
</div>

<p>
Notice that the name of this symbol is all uppercase letters. By default Common Lisp converts all alphabetic <a href="#org9caef75">characters</a> in a symbol's name into uppercase as they are read. This means that, by default, Common Lisp is not case-sensitive:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (eql 'aBc 'Abc)
T
CL-USER&gt; (CaR '(a b c))
A  
</pre>
</div>




<p>
There is a special syntax for referring to symbols whose names contain whitespace or other things that might otherwise be significant to the reader. Any <a href="#orgfef3696">sequence</a> of <a href="#org9caef75">characters</a> between vertical bars is treated as a symbol. You can put anything in the name of a symbol this way:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (list '|Lisp 2.29| '|| '|abc| '|ABC|)
(|Lisp 2.29| || |abc| ABC)
</pre>
</div>
<p>
When the name of such a symbol is read, there is no case conversion, and macro <a href="#org9caef75">characters</a> are treated just like other <a href="#org9caef75">characters</a>.<br />
</p>


<p>
So which symbols can you refer to without using vertical bars? Essentially, any symbol whose name is neither a number nor contains <a href="#org9caef75">characters</a> significant to the reader. A quick way to find out if you could refer to a symbol without using vertical bars is to see how Lisp prints it. If Lisp represents a symbol without vertical bars, as it did the last symbol in the <a href="#org1a9ed34">list</a> above, then you can too.<br />
</p>


<p>
Remember that the vertical bars are a special syntax for denoting symbols. They are not part of the symbol's name:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (symbol-name '|a b c|)
"a b c"  
</pre>
</div>
<p>
If you want to use a vertical bar in the name of a symbol, you can do it by putting a backslash before the bar.<br />
</p>
</div>
</div>

<div id="outline-container-org1a0c817" class="outline-3">
<h3 id="org1a0c817"><span class="section-number-3">9.2.</span> <span class="done DONE">DONE</span> Property Lists</h3>
<div class="outline-text-3" id="text-9-2">
<p>
In Common Lisp every symbol has a <a id="orgf277d1e">property-list</a>, or <a id="orgb2cc148">plist</a>. The function <code>get</code> takes a symbol and a key of any type, and returns the value associated with that key in the symbol's property <a href="#org1a9ed34">list</a> (It uses <code>eql</code> to compare keys):<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (get 'rabbit 'color)
NIL
CL-USER&gt; (setf (get 'rabbit 'color) 'red)
RED
CL-USER&gt; (get 'rabbit 'color)
RED  
</pre>
</div>


<p>
The function symbol-<a href="#orgb2cc148">plist</a> returns the property <a href="#org1a9ed34">list</a> of a symbol:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf (get 'rabbit 'weight) '20kg)
20KG
CL-USER&gt; (symbol-plist 'rabbit)
(WEIGHT 20KG COLOR RED)  
</pre>
</div>
</div>
</div>



<div id="outline-container-org80d32df" class="outline-3">
<h3 id="org80d32df"><span class="section-number-3">9.3.</span> <span class="done DONE">DONE</span> Symbols Are Big</h3>
<div class="outline-text-3" id="text-9-3">
<p>
Symbols are created implicitly when we type their names, and when they are displayed the name is all we see. But there is more to symbols.<br />
</p>

<p>
In fact a symbol is a substantial object, more like the kind of <a href="#orge221c9c">structure</a> that might be defined by <code>defstruct</code>. A symbol can have a name, a home <a href="#org82bfe8d">package</a>, a value as a <a href="#orge9b5a96">variable</a>, a value as a function, and a property <a href="#org1a9ed34">list</a>. Figure <a href="#orgb295cae">2</a> shows how symbols are represented internally.<br />
</p>

<div id="orgb295cae" class="figure">
<p><img src="images/symbols.png" alt="symbols.png" /><br />
</p>
<p><span class="figure-number">Figure 2: </span><a href="#orge221c9c">Structure</a> of a symbol</p>
</div>




<p>
Few programs use so many symbols that it would be worth using something else to save space. But it is worth bearing in mind that symbols are real objects, and not just names.<br />
</p>
</div>
</div>

<div id="outline-container-orgae23d0a" class="outline-3">
<h3 id="orgae23d0a"><span class="section-number-3">9.4.</span> <span class="done DONE">DONE</span> Creating Symbols</h3>
<div class="outline-text-3" id="text-9-4">
<p>
Section <a href="#orgfefc506">9.1</a> showed how to get from symbols to their names. It's also possible to go in the other direction, from <a href="#orgf8f4f91">strings</a> to symbols. This gets a little more complicated, because we have to introduce the topic of <a href="#org1f75805">packages</a>.<br />
</p>


<p>
Conceptually, <a id="org1f75805">packages</a> are symbols-tabels, mapping names to symbols. Every ordinary symbol belongs to a paticular <a id="org82bfe8d">package</a>. A symbol that belongs to a <a href="#org82bfe8d">package</a> is said to be <b>interned</b> in that <a href="#org82bfe8d">package</a>. Functions and variables have symbols as their names. <a href="#org1f75805">Packages</a> enforce modularity by restricting which symbols are accessible, and thus, which functions and variables one can refer to.<br />
</p>


<p>
Most symbols are interned when they are read. The first time you type the name of a new symbol, Lisp will create a new symbol object and intern it in the current <a href="#org82bfe8d">package</a> (which by default will be <code>common-lisp-user</code>). But you can also intern a symbol by giving a string and an optional <a href="#org82bfe8d">package</a> argument to <code>intern</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (intern "RANDOM-SYMBOL")
RANDOM-SYMBOL
NIL  
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; *package*
#&lt;PACKAGE "COMMON-LISP-USER"&gt;  
</pre>
</div>

<p>
The <a href="#org82bfe8d">package</a> argument defaults to the current <a href="#org82bfe8d">package</a>, so the preceding expression returns the symbol in the current <a href="#org82bfe8d">package</a> whose name is the string "RANDOM-SYMBOL", creating such a symbol if it doesn't already exist. The second return value shows whether the symbol already existed; in this case, it didn't.<br />
</p>


<p>
Not all symbols are interned. It can sometimes be useful to have an uninterned symbol, for the same reason that it can be useful to have an unlisted phone number. Uninterned symbols are called <a id="orgd4ef74b">gensyms</a>.<br />
</p>
</div>
</div>


<div id="outline-container-org4dfc6da" class="outline-3">
<h3 id="org4dfc6da"><span class="section-number-3">9.5.</span> <span class="done DONE">DONE</span> Multiple <a href="#org1f75805">Packages</a></h3>
<div class="outline-text-3" id="text-9-5">
<p>
Larger programs are often divided up into multiple <a href="#org1f75805">packages</a>. If each part of a program is in its own <a href="#org82bfe8d">package</a>, then someone working on one part of the program will be able to use a symbol as the name of a function or <a href="#orge9b5a96">variable</a> without worrying that the name is already used elsewhere.<br />
</p>


<p>
In languages that don't provide a way to define multiple namespaces, the programmers working on a big project usually work out some convention to ensure that they don't use the same names. For example, the programmer writing the display code might only use names beginning with <code>disp_</code>, while the programmer writing the math code only used names beginning with <code>math_</code>. So if the math code included a function to do fast Fourier transforms, it might be called <code>math_fft</code>.<br />
</p>


<p>
<a href="#org1f75805">Packages</a> just provide a way to do this automatically. If you define your functions in a separate <a href="#org82bfe8d">package</a>, you can use whatever names you like. Only symbols that you explicitly export will be visible in other <a href="#org1f75805">packages</a>, and there they will usually have to be preceded (or qualified) by the name of the <a href="#org82bfe8d">package</a> that owns them.<br />
</p>


<p>
For example, suppose a program is divided into two <a href="#org1f75805">packages</a>, <code>math</code> and <code>disp</code>. If the symbol <code>fft</code> is exported by the math <a href="#org82bfe8d">package</a>, then code in the <code>disp</code> <a href="#org82bfe8d">package</a> will be able to refer to it as <code>math:fft</code>. Within the math <a href="#org82bfe8d">package</a>, it will be possible to refer to it as simply <code>fft</code>.<br />
</p>


<p>
Here is what you might put at the top of afilecontaining a distinct <a href="#org82bfe8d">package</a> of code:<br />
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>my-aplication.lisp</label><pre class="src src-lisp">(defpackage "MY-APPLICATION"
  (:use "COMMON-LISP" "MY-UTILITIES")
  (:nicknames "APP")
  (:export "WIN" "LOSE" "DRAW"))

(in-package my-application)
</pre>
</div>

<p>
The <code>defpackage</code> defines a new <a href="#org82bfe8d">package</a> called <code>my-application</code>. It uses two other <a href="#org1f75805">packages</a>, <code>common-lisp</code> and <code>my-utilities</code>, which means that symbols exported by these <a href="#org1f75805">packages</a> will be accessible without <a href="#org82bfe8d">package</a> qualifiers. Most <a href="#org1f75805">packages</a> will use <code>common-lisp</code> - you don't want to have to qualify the names of the built-in Lisp operators and variables.<br />
</p>


<p>
The <code>my-application</code> <a href="#org82bfe8d">package</a> itself exports just three symbols: <code>win</code>, <code>lose</code>, and <code>draw</code>. Since the call to <code>defpackage</code> gave <code>my-application</code> the nickname <code>app</code>, code in other <a href="#org1f75805">packages</a> will be able to refer to them as e.g. <code>app:win</code>.<br />
</p>


<p>
The <code>defpackage</code> if followed by an <code>in-package</code> that makes the current <a href="#org82bfe8d">package</a> be <code>my-application</code>. All the unqualified symbols in the rest of the file will be interned in <code>my-application</code> - unless there is another <code>in-package</code> later on. When a file has been loaded, the current <a href="#org82bfe8d">package</a> is always reset to the value it had before the load began.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; *package*
#&lt;PACKAGE "COMMON-LISP-USER"&gt;
CL-USER&gt; (load "/Users/mingmingli/info/information-technology/programming-languages/common-lisp/practice/my-application.lisp")
T
CL-USER&gt; *package*
#&lt;PACKAGE "COMMON-LISP-USER"&gt;  
</pre>
</div>
</div>
</div>


<div id="outline-container-orgadaea46" class="outline-3">
<h3 id="orgadaea46"><span class="section-number-3">9.6.</span> <span class="done DONE">DONE</span> <a href="#org88f010a">Keywords</a></h3>
<div class="outline-text-3" id="text-9-6">
<p>
Symbols in the <code>keyword</code> <a href="#org82bfe8d">package</a> (known as <b><a id="org88f010a">keywords</a></b>) have two unique properties: they always evaluate to themselves, and you can refer to them anywhere simply as <code>:x</code>, instead of <code>keyword:x</code>. When keyword parameters were first introduced in <a href="#org565058d">7.3</a>, it might have seemed more natural for the call to read <code>(member '(a) '((a) (z)) test: #' equal)</code> rather than <code>(member '(a) '((a) (z)) :test #'equal)</code>. Now we see why the unnatural-looking second form is actually the correct one. The colon prefixed to <code>test</code> is just to identify it as a keyword.<br />
</p>




<p>
Why use <a href="#org88f010a">keywords</a> instead of ordinary symbols? Because they are accessible anywhere. A function that takes symbols as arguments should usually be written to expect <a href="#org88f010a">keywords</a>. For example<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun noise (animal)
  (case animal
    (:dog :woof)
    (:cat :meow)
    (:pig :oink)))
</pre>
</div>
<p>
If it had been written to use ordinary symbols, it would only work when called from the <a href="#org82bfe8d">package</a> in which it was defined, unless the keys were exported as well.<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">(defpackage "MY-APPLICATION"
  (:use "COMMON-LISP")
  (:nicknames "APP")
  (:export "NOISE" "NOISE2"))

(in-package my-application)



(defun noise (animal)
  (case animal
    (:dog :woof)
    (:cat :meow)
    (:pig :oink)))

(defun noise2 (animal)
  (case animal
    ('dog 'woof)
    ('cat 'meow)
    ('pig 'oink)))

</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (my-application:noise :cat)
:MEOW
CL-USER&gt; (my-application:noise2 'cat)
NIL  
</pre>
</div>
</div>
</div>



<div id="outline-container-org904e3e3" class="outline-3">
<h3 id="org904e3e3"><span class="section-number-3">9.7.</span> <span class="done DONE">DONE</span> Symbols and Variables</h3>
<div class="outline-text-3" id="text-9-7">
<p>
One potentially confusing thing about Lisp is that symbols are related to variables in two very different ways.<br />
</p>


<p>
When a symbol is the name of a special <a href="#orge9b5a96">variable</a>, the value of the <a href="#orge9b5a96">variable</a> is stored in a field within the symbol (<a href="#orgb295cae">2</a>). The <code>symbol-value</code> function refers to that field, so we have a direct connection between a symbol and the value of the special <a href="#orge9b5a96">variable</a> it represents.<br />
</p>


<p>
With lexical variables, things are completely different. A symbol used as a <a href="#orgd47414e">lexical variable</a> is just a placeholder. The compiler will translate it into a reference to a register or a location in memory. In the eventual compiled code, there will be no trace of the symbol (unless it is retained somewhere for use by the debugger). So of course there is no connection between symbols and the values of the lexical variables they represent; by the time there is a value, the symbol is gone.<br />
</p>
</div>
</div>
</div>



<div id="outline-container-org0bb7a4e" class="outline-2">
<h2 id="org0bb7a4e"><span class="section-number-2">10.</span> <span class="done DONE">DONE</span> Numbers</h2>
<div class="outline-text-2" id="text-10">
<p>
Common Lisp has a rich set of numeric <a href="#orgcc779bc">types</a> and its features for manipulating numbers compare favorably with any language.<br />
</p>
</div>


<div id="outline-container-org3846853" class="outline-3">
<h3 id="org3846853"><span class="section-number-3">10.1.</span> <span class="done DONE">DONE</span> <a href="#orgcc779bc">Types</a></h3>
<div class="outline-text-3" id="text-10-1">
<p>
Common Lisp provides four distinct <a href="#orgcc779bc">types</a> of numbers: integer,floating-point numbers, ratios, and complex numbers. Most of the functions described in this chapter work on numbers of any type. A few, explicitly noted, accept all but complex numbers.<br />
</p>


<p>
An integer is written as a string of digits: <code>2001</code>. A floating-point number can be written as a string of digits containing a decimal point, <code>253.72</code>, or in scientific notation, <code>2.5372e2</code>. A ratio is written as a fraction of integers: <code>2/3</code>. And the complex number <code>a+bi</code> is written as <code>#c(a b)</code>, where <code>a</code> and <code>b</code> are any two real numbers of the same type.<br />
</p>


<p>
The predicates <code>integerp</code>, <code>floatp</code>, and <code>complexp</code> return true for numbers of the corresponding <a href="#orgcc779bc">types</a>.<br />
</p>

<p>
Figure <a href="#orgbfb587e">3</a> shows the hierarchy of numeric <a href="#orgcc779bc">types</a>.<br />
</p>

<div id="orgbfb587e" class="figure">
<p><img src="images/numeric-types.png" alt="numeric-types.png" width="50%" /><br />
</p>
<p><span class="figure-number">Figure 3: </span>Numeric <a href="#orgcc779bc">types</a></p>
</div>



<p>
Here are some general rules of thumb for determining what kind of number a computation will return:<br />
</p>
<ol class="org-ol">
<li>If a numeric function receives one or more floating-point numbers as arguments, the return value will be a floating-point number (or a complex number with floating-point components). So <code>(+ 1.0 2)</code> evaluates to <code>3.0</code>, and <code>(+ #c(0 1.0) 2)</code> evaluates to <code>#c(2.0 1.0)</code>.<br /></li>
<li>Ratios that divide evenly will be converted into integers. So <code>(/ 10 2)</code> will return <code>5</code>.<br /></li>
<li>Complex numbers whose imaginary part would be zero will be converted into reals. So <code>(+ #c(1 -1) #c(2 1))</code> evaluates to <code>3</code>.<br /></li>
</ol>


<p>
Rules 2 and 3 apply to arguments as soon as they are read, so:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (list (ratiop 2/2) (complexp #c(1 0)))
(NIL NIL)  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(defun ratiop (x)
  (and (typep x 'rational)
       (&gt; (denominator x) 1)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org9e676bb" class="outline-3">
<h3 id="org9e676bb"><span class="section-number-3">10.2.</span> <span class="done DONE">DONE</span> Conversion and Extraction</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Common Lisp provides functions for converting and extracting components of the four kinds of numbers.<br />
</p>

<p>
The function <code>float</code> converts any real number to a floating-point numbers:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (mapcar #'float '(1 2/3 .5))
(1.0 0.6666667 0.5)
</pre>
</div>

<p>
Reducing numbers to integers is not necessarily conversion, because it can involve some loss of information. The function <code>truncate</code> returns the integer component of any real number:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (truncate 1.3)
1
0.29999995
</pre>
</div>
<p>
The second return value is the original argument minus thefirstreturn value. The difference of <code>.00000005</code> is due to the inherent inexactitude of floating-point computation.<br />
</p>


<p>
The functions <code>floor</code>, <code>ceiling</code> and <code>round</code> also derive integers from there arguments. The function <code>round</code> returns the nearest integer to its argument. When the argument is equidistant from two integers, Common Lisp, like many programming languages, does not round up. Instead it rounds to the nearest even digit.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (floor 1.5)
1
0.5
CL-USER&gt; (ceiling 1.5)
2
-0.5
CL-USER&gt; (mapcar #'round '(-2.5 -1.5 1.5 2.5))
(-2 -2 2 2)
CL-USER&gt; (round 1.5)
2
-0.5
</pre>
</div>


<p>
The function <code>mod</code> returns the modulus and <code>rem</code> returns the remainder.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (mod 13 4)
1
CL-USER&gt; (rem 13 4)
1
CL-USER&gt; (mod -13 4)
3
CL-USER&gt; (rem -13 4)
-1  
</pre>
</div>


<p>
The function <code>signum</code> returns either 1, 0, or -1, depending on whether its argument is positive, zero, or negative.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (mapcar #'signum '(-2 -0.0 0.0 0 .5 3))
(-1 -0.0 0.0 0 1.0 1)  
</pre>
</div>
<p>
In some implementations <code>-0.0</code> may exist in its own right, as above. Functionally it makes little difference whether it does or not, because in numeric code <code>-0.0</code> behaves exactly like <code>0.0</code>.<br />
</p>


<p>
The function <code>abs</code> returns the absolute value of its argument.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (abs 1)
1
CL-USER&gt; (abs -1)
1  
</pre>
</div>



<p>
Ratios and complex numbers are conceptually two-part structures. The functions <code>numerator</code> and <code>denominator</code> return the corresponding components of a ratio or integer. (If the number is an integer, the former returns the number itself and the latter returns 1.) The functions <code>realpart</code> and <code>imagpart</code> return the real and imaginary components of any number. (If the number isn't complex, the former returns the number itself and the latter returns zero.)<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (numerator 1/3)
1
CL-USER&gt; (denominator 1/3)
3
CL-USER&gt; (numerator 10)
10
CL-USER&gt; (denominator 10)
1
CL-USER&gt; (realpart #c(2 3))
2
CL-USER&gt; (imagpart #c(2 3))
3
CL-USER&gt; (realpart 5)
5
CL-USER&gt; (imagpart 5)
0  
</pre>
</div>


<p>
The function <code>random</code> takes an integer or floating-point number. An expression of the form <code>(random n)</code> returns a number greater than or equal to zero and less than <code>n</code>, and of the same type as <code>n</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (random 10)
6
CL-USER&gt; (random 10)
9
CL-USER&gt; (random 10)
5
CL-USER&gt; (random 10.0)
2.6471841
CL-USER&gt; (random 10.0)
6.1633406
CL-USER&gt; (random 10.0)
1.9508076  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgccb80a7" class="outline-3">
<h3 id="orgccb80a7"><span class="section-number-3">10.3.</span> <span class="done DONE">DONE</span> Comparison</h3>
<div class="outline-text-3" id="text-10-3">
<p>
The predicate = returns true when its arguments are numerically equal — when the difference between them is zero. It is less strict than <code>eql</code>, which also requires its arguments to be of the same type.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (= 1 1.0)
T
CL-USER&gt; (eql 1 1.0)
NIL
</pre>
</div>



<p>
The predicates for comparing numbers are &lt; (less than) , &lt;= (less than or equal), = (equal), &gt;= (greater than or equal), &gt; (greater than), and /= (different). All of them take one or more arguments. With one argument they all return <code>t</code>. For all except /=, a call with three or more arguments,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(&lt;= w x y z)
</pre>
</div>
<p>
is equivalent to the conjunction of a binary opeator applied to successive pairs of arguments:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(and (&lt;= w x) (&lt;= x y) (&lt;= y z))
</pre>
</div>


<p>
Since /= returns true if no two of its arguments are =, the expresssion<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(/= w x y z)
</pre>
</div>
<p>
is equivalent to<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(and (/= w x)
     (/= w y)
     (/= w z)
     (/= x y)
     (/= x z)
     (/= y z))
</pre>
</div>

<p>
The <a href="#org36bef2b">specialized</a> predicates <code>zerop</code>, <code>plusp</code> and <code>minusp</code> take one argument and return true if it is =, &gt; and &lt; zero, respectively. These functions do not overlap. Although is preceded by a negative sign, it is = to 0,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (list (minusp -0.0) (zerop -0.0))
(NIL T)  
</pre>
</div>



<p>
The predicates <code>oddp</code> and <code>evenp</code> apply only to integers. The former is true only of odd integers, and the latter only of even ones.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (list (oddp 1) (oddp 2) (evenp 1) (evenp 2))
(T NIL NIL T)  
</pre>
</div>


<p>
Of the predicates described in this section, only <code>=</code>, <code>/=</code>, and <code>zerop</code> apply to complex numbers.<br />
</p>


<p>
The functions max and min return, respectively, the maximum and minimum of their arguments. Both require at least one:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (max 1 2 3 4 5)
5
CL-USER&gt; (min 1 2 3 4 5)
1  
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ba4ee1" class="outline-3">
<h3 id="org3ba4ee1"><span class="section-number-3">10.4.</span> <span class="done DONE">DONE</span> Arithmetic</h3>
<div class="outline-text-3" id="text-10-4">
<p>
The functions for addition and subtraction are + and -. Both can take any number of arguments, including none, in which case they return 0. An expression of the form <code>(- n)</code> returns <code>—n</code>. An expression of the form<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(- x y z)
</pre>
</div>
<p>
is equivalent to<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(- (- x y) z)
</pre>
</div>

<p>
There are also two functions <code>1+</code> and <code>1-</code>, which return their argument plus 1 and minus 1 respectively. The name <code>1-</code> is a bit misleading, because <code>(1- x)</code> returns <code>x - 1</code>, not <code>1 - x</code>.<br />
</p>


<p>
The <a href="#orge6ba26a">macros</a> <code>incf</code> and <code>decf</code> increment and decrement their argument, respectively. An expression of the form <code>(incf x n)</code> is similar in effect to <code>(setf x (+ x n))</code>, and <code>(decf x n)</code> to <code>(setf x (- x n))</code>. In both cases the second argument is optional and defaults to 1.<br />
</p>


<p>
The function for multiplication is <code>*</code>. It takes any number of arguments. When given no arguments it returns 1. Otherwise it returns the product of its arguments.<br />
</p>


<p>
The division function, / , expects at least one argument. A call of the form <code>(/ n)</code> is equivalent to <code>(/ 1 n)</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (/ 3)
1/3
</pre>
</div>
<p>
while a call of form<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(/ x y z)
</pre>
</div>
<p>
is equivalent to<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(/ (/ x y) z)
</pre>
</div>


<p>
When given two integers, / will return a ratio if the first is not a multiple of the second:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (/ 22 21)
22/21
CL-USER&gt; (float 22/21)
1.0476191
</pre>
</div>
</div>
</div>


<div id="outline-container-orgf6e3a6b" class="outline-3">
<h3 id="orgf6e3a6b"><span class="section-number-3">10.5.</span> <span class="done DONE">DONE</span> Exponentiation</h3>
<div class="outline-text-3" id="text-10-5">
<p>
To find \(x^n\) we call <code>(expt x n)</code> and to find \(log_n x\) we call <code>(log x n)</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (expt 2 10)
1024
CL-USER&gt; (log 1024 2)
10.0
</pre>
</div>


<p>
To find <code>e^x</code> there is a distinct function <code>exp</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (exp 2)
7.389056
</pre>
</div>



<p>
To find a natural logarithm you can just you <code>log</code>, because the second argument defaults to <code>e</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (log 7.389056)
2.0  
</pre>
</div>


<p>
To find roots you can tell <code>expt</code> with a ratio as the second argument:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (expt 27 1/3)
3.0  
</pre>
</div>
<p>
but for finding square roots the function <code>sqrt</code> should be faster:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (sqrt 9)
3.0  
</pre>
</div>
</div>
</div>



<div id="outline-container-org18ef93a" class="outline-3">
<h3 id="org18ef93a"><span class="section-number-3">10.6.</span> <span class="done DONE">DONE</span> Trigonometric Functions</h3>
<div class="outline-text-3" id="text-10-6">
<p>
The constant <code>pi</code> is a floating-point representation of &pi;. Its precision is implementation-dependent. The functions <code>sin</code>, <code>cos</code>, and <code>tan</code> find the sine, cosine, and tangent, respectively, of angles expressed in radians:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x (/ pi 4)))
           (list (sin x) (cos x) (tan x)))
(0.7071067811865475d0 0.7071067811865476d0 0.9999999999999999d0)  
</pre>
</div>
<p>
These functions all take negative and complex arguments.<br />
</p>


<p>
The functions <code>asin</code>, <code>acos</code> and <code>atan</code> implement the inverse of sine, cosine, and tangent.<br />
</p>


<p>
Hyperbolic sine, cosine, and tangent are implemented by <code>sinh</code>, <code>cosh</code>, and <code>tanh</code>, respectively. Their inverses are likewise <code>asinh</code>, <code>acosh</code>, and <code>atanh</code>.<br />
</p>
</div>
</div>


<div id="outline-container-org7f1e0be" class="outline-3">
<h3 id="org7f1e0be"><span class="section-number-3">10.7.</span> <span class="done DONE">DONE</span> Representation</h3>
<div class="outline-text-3" id="text-10-7">
<p>
Common Lisp imposes no limit on the size of integers. Small integers fit in one word of memory and are called <code>fixnum</code>. When a computation produces an integer too large to fit in one memory word, Lisp switches to a representation (a <code>bignum</code>) that uses multiple words of memory. So the effective limit on the size of an integer is imposed by physical memory, not by the language.<br />
</p>



<p>
The constants <code>most-positive-fixnum</code> and <code>most-negative-fixnum</code> indicate the largest magnitudes an implementation can represent without having to use bignums.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; most-positive-fixnum
4611686018427387903
CL-USER&gt; most-negative-fixnum
-4611686018427387904  
</pre>
</div>



<p>
The predicate <code>typep</code> takes an argument and a type name and returns true if the argument is of the specified type. So,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (typep 1 'fixnum)
T
CL-USER&gt; (typep (1+ most-positive-fixnum) 'bignum)
T  
</pre>
</div>


<p>
The limits on the values of floating-point numbers are implementation-dependent. Common Lisp provides up to four <a href="#orgcc779bc">types</a> of floating-point numbers: <code>short-float</code>, <code>single-float</code>, <code>double-float</code>, and <code>long-float</code>. Implementations are not required to use distinct formats for all four <a href="#orgcc779bc">types</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; most-positive-short-float
3.4028235e38
CL-USER&gt; most-positive-single-float
3.4028235e38
CL-USER&gt; most-positive-double-float
1.7976931348623157d308
CL-USER&gt; most-positive-long-float
1.7976931348623157d308  
</pre>
</div>

<p>
The general idea is that a short float is supposed to fit in a single word, that single and double floats are supposed to provide the usual idea of single- and double-precision floating-point numbers, and that long floats can be something really big, if desired. But an implementation could perfectly well implement all four the same way.<br />
</p>


<p>
You can specify what format you want a floating-point number to be by substituting the letters <code>s, f, d, or l</code> for the <code>e</code> when a number is represented in scientific notation. (You can use uppercase too, and this is a good idea for long floats, because l looks so much like 1.) So to make the largest representation of 1.0 you would write 1L0.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; 1S0
1.0
CL-USER&gt; 1F0
1.0
CL-USER&gt; 1D0
1.0d0
CL-USER&gt; 1L0
1.0d0  
</pre>
</div>


<p>
Sixteen global constant mark the limits of each format in a given implementation. Their names are of the format <code>m-s-f</code> where <code>m</code> is <code>most</code> or <code>least</code>, <code>s</code> is <code>positive</code> or <code>negative</code>, and <code>f</code> is one of the four type of float.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; most-positive-long-float
1.7976931348623157d308  
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org98e5e98" class="outline-2">
<h2 id="org98e5e98"><span class="section-number-2">11.</span> <span class="done DONE">DONE</span> <a href="#orge6ba26a">Macros</a></h2>
<div class="outline-text-2" id="text-11">
<p>
Lisp code is expressed as lists, which are Lisp objects. This made it possible to write programs that would write programs. This chapter shows how to cross the line from expressions to code.<br />
</p>
</div>


<div id="outline-container-orgd54d945" class="outline-3">
<h3 id="orgd54d945"><span class="section-number-3">11.1.</span> <span class="done DONE">DONE</span> Eval</h3>
<div class="outline-text-3" id="text-11-1">
<p>
The function <code>eval</code> takes an expression, evaluates it, and returns its value:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (eval '(+ 1 2 3))
6
CL-USER&gt; (eval '(format t "Hello"))
Hello
NIL
</pre>
</div>


<p>
The following function implements something very like the <a href="#org4641b96">toplevel</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-toplevel ()
  (do ()
      (nil)
    (format t "~%&gt; ")
    (print (eval (read)))))
</pre>
</div>
<p>
For this reason the <a href="#org4641b96">toplevel</a> is also known as a read-eval-print loop (REPL).<br />
</p>


<p>
Calling <code>eval</code> is one way to cross the line between lists and code. However it is not a very good way:<br />
</p>
<ol class="org-ol">
<li>It's inefficient. <code>eval</code> is handed a raw <a href="#org1a9ed34">list</a>, and either has to compile it on the spot, or evaluate it in an interpreter. Either way is much slower than running compiled code.<br /></li>
<li>The expression is evaluated with no <a href="#org305427e">lexical context</a>. If you call <code>eval</code> within a <code>let</code>, for example, the expressions passed to <code>eval</code> cannot refer to variables established by the <code>let</code>.<br /></li>
</ol>



<p>
There are much better ways to take advantage of the possibility of generating code. Indeed, one of the only places where it is legitimate to use <code>eval</code> is in something like a <a href="#org4641b96">toplevel</a> loop.<br />
</p>



<p>
For programmers the main value of <code>eval</code> is probably as a conceptual model for Lisp. We can imagine it defined as a big <code>cond</code> expression:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(def our-eval (expr env)
  (cond ...
        ((eql (car expr) 'quote) (cadr expr))
        ...
        (t (apply (symbol-function (car expr))
                  (mapcar #'(lambda (x)
                              (our-eval x env))
                          (cdr exprt))))))
</pre>
</div>
<p>
Most expressions are handled by the default clause, which says to get the function referred to in the <code>car</code>, evaluate all the arguments in the <code>cdr</code>, and return the result of applying the former to the latter.<br />
</p>


<p>
However, we can't do this for an expression like <code>(quote x)</code>, since the whole point of <code>quote</code> is to preserve its argument from evaluation. So we have to have a distinct clause just for <code>quote</code>. That's what a <a href="#org31c3e37">special operator</a> is, essentially: an operator that has to be implemented as a special case in <code>eval</code>.<br />
</p>



<p>
The function <code>coerce</code> and <code>compile</code> provide a similar bridge from lists to code. You can <code>coerce</code> a lambda expression into a function:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (coerce '(lambda (x) x) 'function)   ; type conversion
#&lt;FUNCTION (LAMBDA (X)) {54B4288B}&gt;  
</pre>
</div>
<p>
and if you give <code>nil</code> as the first argument to <code>compile</code>, it will compile a lambda expression given as the second argument:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (compile nil '(lambda (x) (+ x 2)))
#&lt;FUNCTION (LAMBDA (X)) {54B2743B}&gt;
NIL
NIL
CL-USER&gt; (compile '2+ '(lambda (x) (+ x 2)))
2+
NIL
NIL
CL-USER&gt; (2+ 3)
5
</pre>
</div>
<p>
Since <code>coerce</code> and <code>compile</code> can take lists as arguments, a program could build new functions on the fly. However, this is a drastic measure, comparable to calling <code>eval</code>, and should be viewed with the same suspicion.<br />
</p>


<p>
The trouble with <code>eval</code>, <code>coerce</code>, and <code>compile</code> is not that they cross the line between lists and code, but that they do it at run-time. Crossing the line is expensive. Doing it at compile-time is good enough in most cases, and costs nothing when your program runs. The next section shows how to do this.<br />
</p>
</div>
</div>



<div id="outline-container-orgd995a5b" class="outline-3">
<h3 id="orgd995a5b"><span class="section-number-3">11.2.</span> <span class="done DONE">DONE</span> <a href="#orge6ba26a">Macros</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="important">important</span></span></h3>
<div class="outline-text-3" id="text-11-2">
<p>
The most common way to write programs that write programs is by defining <a href="#orge6ba26a">macros</a>. <a id="orge6ba26a">Macros</a> are operators that are implemented by transformation. You define a macro by saying how a call to it should be translated. This translation, called <a id="org3c2d7cd">macro-expansion</a>, is done automatically by the compiler. So the code generated by your <a href="#orge6ba26a">macros</a> becomes an integral part of your program, just as if you had typed it in yourself.<br />
</p>

<p>
<a href="#orge6ba26a">Macros</a> are usually defined by calling <code>defmacro</code>. A <code>defmacro</code> looks a lot like a <code>defun</code>, but instead of defining the value a call should produce, it defines how a call should be translated. For example, a macro to set its argument to <code>nil</code> might be defined as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro nil! (x)
  (list 'setf x nil))
</pre>
</div>
<p>
This defines a new operator call <code>nil!</code>, which will take one argument. A call of the form <code>(nil! a)</code> will be translated into <code>(setf a nil)</code> before being compiled or evaluated. So if we type <code>(nil! x)</code> into the <a href="#org4641b96">toplevel</a>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (nil! x)
NIL
CL-USER&gt; x
NIL
</pre>
</div>
<p>
it is exactly equivalent to typing the expansion, <code>(setf x nil)</code>.<br />
</p>



<p>
To test a function, we call it, but to test a macro, we look at its expansion. The function <code>macroexpand-1</code> takes a macro call and generates its expansion:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (macroexpand-1 '(nil! x))
(SETF X NIL)
T  
</pre>
</div>
<p>
A macro call can expand into another macro call. When the compiler (or the <a href="#org4641b96">toplevel</a>) encounters a macro call, it simply keeps expanding it until it is no longer one.<br />
</p>


<p>
The secret to understanding <a href="#orge6ba26a">macros</a> is to understand how they are implemented. Underneath, they're just functions that transform expressions. For example, if you pass an expression of the form <code>(nil! a)</code> to this function<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(lambda (expr)
  (apply #'(lambda (x)
             (list 'setf x nil))
         (cdr expr)))  
</pre>
</div>
<p>
it will return <code>(setf a nil)</code> . When you use <code>defmacro</code>, you're defining a function much like this one. All <code>macroexpand-1</code> does, when it sees an expression whose car is known to be the name of a macro, is pass the expression to the corresponding function.<br />
</p>
</div>
</div>




<div id="outline-container-orga8a8fb4" class="outline-3">
<h3 id="orga8a8fb4"><span class="section-number-3">11.3.</span> <span class="done DONE">DONE</span> Backquote</h3>
<div class="outline-text-3" id="text-11-3">
<p>
The backquote <a href="#org106d8cc">read-macro</a> makes it possible to build lists from templates. Backquote is used extensively in macro definitions. While a regular quote is a close-quote (apostrophe) on the keyboard, a backquote is an open-quote. It's called "backquote" because it looks like a normal quote tilted backwards.<br />
</p>


<p>
Used by itself, a backquote is equivalent to a regular quote:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; `(a b c)
(A B C)  
</pre>
</div>
<p>
Like a regular quote, a backquote alone protects its argument from evaluation.<br />
</p>

<p>
The advantage of backquote is that, within a backquoted expression, you can use , (comma) and ,@ (comma-at) to turn evaluation back on. If you prefix a comma to something within a backquoted expression, it will be evaluated. Thus we can use backquote and comma together to build <a href="#org1a9ed34">list</a> templates:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf a 1 b 2)
2
CL-USER&gt; `(a is ,a and b is ,b)
(A IS 1 AND B IS 2)  
</pre>
</div>

<p>
By using backquote instead of a call to <code>list</code>, we can write macro definitions that look like the expansions they will produce. For example, <code>nil!</code> could be defined as:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro nil! (x)
  `(setf ,x nil))
</pre>
</div>


<p>
Comma-at is like comma, but splices its argument (which should be a <a href="#org1a9ed34">list</a>). Instead of the <a href="#org1a9ed34">list</a> itself, its elements are inserted in the template:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst '(a b c))
(A B C)
CL-USER&gt; `(lst is ,lst)
(LST IS (A B C))
CL-USER&gt; `(its elements are ,@lst)
(ITS ELEMENTS ARE A B C)  
</pre>
</div>

<p>
Comma-at is useful in <a href="#orge6ba26a">macros</a> that have rest parameters representing, for example, a body of code. Suppose we want a <code>while</code> macro that will evaluate its body so long as an initial test expression remains true:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 0))
           (while (&lt; x 10)
                  (princ x)
                  (incf x)))
0123456789
NIL  
</pre>
</div>


<p>
We can define such a macro by using a <a href="#org2450710">rest parameter</a> to collect a <a href="#org1a9ed34">list</a> of the expressions in the body, then using comma-at to splice this <a href="#org1a9ed34">list</a> into the expansion:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro while (test &amp;rest body)
  `(do ()
       ((not ,test))
     ,@body))
</pre>
</div>
</div>
</div>



<div id="outline-container-org8877f83" class="outline-3">
<h3 id="org8877f83"><span class="section-number-3">11.4.</span> <span class="done DONE">DONE</span> Macro Design</h3>
<div class="outline-text-3" id="text-11-4">
<p>
Writing <a href="#orge6ba26a">macros</a> is a distinct kind of programming, with its own unique aims and problems. Being able to change what the compiler sees is almost like being able to rewrite it. So when you start writing <a href="#orge6ba26a">macros</a>, you have to start thinking like a language designer.<br />
</p>


<p>
This section gives a quick overview of the problems involved, and the techniques used to solve them. As an example, we will define a macro called<br />
<code>ntimes</code>, which takes a number <code>n</code> and evaluates its body <code>n</code> times:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">&gt;  (ntimes 10
           (princ "."))
..........
NIL
</pre>
</div>

<p>
Here is an incorrect definition of <code>ntimes</code> that illustrates dome issues in macro design:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro ntimes (n &amp;rest body)		; wrong
  `(do ((x 0 (+ x 1)))
       ((&gt;= x ,n))
     ,@body))
</pre>
</div>
<p>
This definition may look ok at first sight. In the case above it would work as intended. But in fact it is broken in two ways.<br />
</p>

<p>
One of the problems that macro designer have to think about is inadvertent <a href="#orge9b5a96">variable</a> captures. This happens when a <a href="#orge9b5a96">variable</a> used in macro expansion happens to have the same name as a <a href="#orge9b5a96">variable</a> existing in the context where the expansion is inserted. The incorrect definition of <code>ntimes</code> creates a <a href="#orge9b5a96">variable</a> <code>x</code>. So if the macro is called in a place where there is already a <a href="#orge9b5a96">variable</a> with that name, it may not do what we expected:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 10))
           (ntimes 5
                   (setf x (+ x 1)))
           x)
10  
</pre>
</div>
<p>
If <code>ntimes</code> did what it was supposed to, this expression should increment <code>x</code> five times, and finally return 15. But because the macro expansion happens to use <code>x</code> as its iteration <a href="#orge9b5a96">variable</a>, the <code>setf</code> expression increments the value of that <code>x</code>, not the one that we meant to increment. Once the macro call is expanded, the preceding expression becomes:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x 10))
           (do ((x 0 (+ x 1)))
               ((&gt;= x 5))
             (setf x (+ x 1)))
           x)
10
</pre>
</div>
<p>
The most general solution is not to use ordinary symbols anywhere they might be captured. Instead we can use <a href="#orgd4ef74b">gensyms</a>. Because <code>read</code> interns every symbol it sees, there is no way a gensym could <code>eql</code> to any symbol occurring in a program text. If we rewrite the definition of <code>ntimes</code> to use a gensym instead of <code>x</code>, it will at least be safe from <a href="#orge9b5a96">variable</a> capture:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro ntimes (n &amp;rest body)		; wrong
  (let ((g (gensym)))
    `(do ((,g 0 (+ ,g 1)))
         ((&gt;= ,g ,n))
       ,@body)))	
</pre>
</div>

<p>
However, this macro is still susceptible to another problem: multiple evaluation. Because the first argument is inserted directly into the <code>do</code>, it will be evaluated on each iteration. This mistake shows most clearly when the first argument is an expression with side-effects:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((v 10))
           (ntimes (setf v (- v 1))
                   (princ ".")))
.....
NIL  
</pre>
</div>
<p>
Since <code>v</code> is initially 10 and <code>setf</code> returns the value of its second argument, this should print nine periods. In fact it prints only five.<br />
</p>


<p>
We see why if we look at the expression with the macro call expanded:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((v 10))
  (do ((#:g1 0 (+ #:g1 1)))
      ((&gt;= #:g1 (setf v (- v 1))))
    (princ ".")))
</pre>
</div>
<p>
On each iteration we compare the iteration <a href="#orge9b5a96">variable</a> (<a href="#orgd4ef74b">gensyms</a> usually print as symbols preceded by #:) not against 9, but against an expression that decreases each time it is evaluated. It is as if the horizon gets closer each time we look at it.<br />
</p>


<p>
The way to avoid unintended multiple evaluations is to set a <a href="#orge9b5a96">variable</a> to the value of the expression in question before any iteration. This usually involves another gensym:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro ntimes (n &amp;rest body)
  (let ((g (gensym))
        (h (gensym)))
    `(let ((,h ,n))
       (do ((,g 0 (+ ,g 1)))
           ((&gt;= ,g ,h))
         ,@body))))
</pre>
</div>
<p>
Here, finally, is a correct definition of ntimes.<br />
</p>




<p>
<b>Unintended <a href="#orge9b5a96">variable</a> capture</b> and <b>multiple evaluation</b> are the major problems that can afflict <a href="#orge6ba26a">macros</a>, but they are not the only ones. With experience it is no more difficult to avoid such errors than it is to avoid more familiar errors, like dividing by zero. But because <a href="#orge6ba26a">macros</a> give us a new kind of power, the kind of problems we have to worry about are also new.<br />
</p>





<p>
Your Common Lisp implementation is a good place to learn more about macro design. By expanding calls to the built-in <a href="#orge6ba26a">macros</a>, you can usually understand how they were written.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (pprint (macroexpand-1 '(cond 
                                  (a b)
                                  (c d e)
                                  (t f))))

(IF A
    B
    (IF C
        (PROGN D E)
        (THE T F)))
; No value
</pre>
</div>

<p>
The function <code>pprint</code> (pretty print), which prints expressions indented like code, is especially useful when looking at macro expansions.<br />
</p>
</div>
</div>



<div id="outline-container-org5b09bd9" class="outline-3">
<h3 id="org5b09bd9"><span class="section-number-3">11.5.</span> <span class="done DONE">DONE</span> Generalized Reference</h3>
<div class="outline-text-3" id="text-11-5">
<p>
Since a macro call is expanded right into the code where it appears, any macro call whose expansion could be the first argument to <code>setf</code> can itself be the first argument to <code>setf</code>. For example, if we defined a synonym for <code>car</code>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro cah (lst)
  `(car ,lst))
</pre>
</div>
<p>
then because a call to <code>car</code> can be the first argument to <code>setf</code>, so could a call to <code>cah</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x (list 'a 'b 'c)))
           (setf (cah x) 44)
           x)
(44 B C)  
</pre>
</div>

<p>
Writing a macro that expands into a <code>setf</code> is another question, and a more difficult one than it might seem at first. It might seem that you could implement <code>incf</code> simply as:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmacro my-incf (x &amp;optional (y 1))	; wrong
  `(setf ,x (+ ,x ,y)))
</pre>
</div>
<p>
But this would not work. These two expressions are not equivalent.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf (car (push 1 lst)) (+ (car (push 1 lst)) 1))
(incf (car (push 1 lst)))
</pre>
</div>
<p>
If <code>lst</code> is initially <code>nil</code>, the second expression will set it to <code>(2)</code>, but the first expression would set it to <code>(1 2)</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst nil)
NIL
CL-USER&gt; (my-incf (car (push 1 lst)))
2
CL-USER&gt; lst
(1 2)
CL-USER&gt; (setf lst nil)
NIL
CL-USER&gt; (incf (car (push 1 lst)))
2
CL-USER&gt; lst
(2)
</pre>
</div>



<p>
Common Lisp provides <code>define-modify-macro</code> as a way of writing a restricted class of <a href="#orge6ba26a">macros</a> on <code>setf</code>. It takes three arguments: the name of the macro, its additional parameters (the place is implicitly the first), and the name of a function that yields the new value of the place. So we could define <code>incf</code> as<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(define-modify-macro our-incf (&amp;optional (y 1)) +)
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (pprint (macroexpand-1 '(our-incf (car (push 1 lst)) 2)))

(LET* ((#:G264 (PUSH 1 LST)))
  (SB-KERNEL:%RPLACA #:G264 (+ (CAR #:G264) 2)))
; No value  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(define-modify-macro append1f (val) (lambda (lst val)
                                      (append lst (list val))))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((lst '(a b c)))
           (append1f lst 'd)
           lst)
(A B C D)
CL-USER&gt; (pprint (macroexpand-1 '(append1f lst val)))

(LET* ((#:VAL VAL))
  (SETQ LST ((LAMBDA (LST VAL) (APPEND LST (LIST VAL))) LST #:VAL)))
; No value
</pre>
</div>

<p>
Incidently, neither <code>push</code> nor <code>pop</code> can be defined as modify-<a href="#orge6ba26a">macros</a>, the former because the place is not its first argument, and the latter because its return value is not the modified object.<br />
</p>
</div>
</div>




<div id="outline-container-org47ed6dc" class="outline-3">
<h3 id="org47ed6dc"><span class="section-number-3">11.6.</span> <span class="done DONE">DONE</span> On Lisp</h3>
<div class="outline-text-3" id="text-11-6">
<p>
Is it worth writing a macro just to save typing? Very much so. Saving typing is what programming languages are all about; the purpose of a compiler is to save you from typing your program in machine language. And <a href="#orge6ba26a">macros</a> allow you to bring to your specific applications the same kinds of advantages that high-level languages bring to programming in general. By the careful use of <a href="#orge6ba26a">macros</a>, you may be able to make your programs significantly shorter than they would be otherwise, and proportionately easier to read, write, and maintain.<br />
</p>


<p>
If you doubt this, consider what your programs would look like if you didn't use any of the built-in <a href="#orge6ba26a">macros</a>. All the expansions those <a href="#orge6ba26a">macros</a> generate, you would have to generate by hand. You can use this question in the other direction as well. As you're writing a program, ask yourself, am I writing macroexpansions? If so, the <a href="#orge6ba26a">macros</a> that generate those expansions are the ones you need to write.<br />
</p>



<p>
Most of the Common Lisp operators that aren't functions are <a href="#orge6ba26a">macros</a>, and they are all written in Lisp. Only 25 of Common Lisp's built-in operators are special operators.<br />
</p>


<p>
John Foderaro has called Lisp "a programmable programming language." By writing your own functions and <a href="#orge6ba26a">macros</a>, you can turn Lisp into just about any language you want. Whatever turns out to be the right form for your program, you can be assured that you will be able to shape Lisp to suit it.<br />
</p>


<p>
<a href="#orge6ba26a">Macros</a> are one of the key ingredients in this flexibility. They allow you to transform Lisp almost beyond recognition, and yet to do so in a principled, efficient way. It's clear already that one can do amazing things with them, but more certainly remain to be discovered. By you, if you want. Lisp has always put its evolution in the hands of the programmer. That's why it survives.<br />
</p>
</div>
</div>
</div>



<div id="outline-container-org9952b68" class="outline-2">
<h2 id="org9952b68"><span class="section-number-2">12.</span> <span class="done DONE">DONE</span> <a href="#org8fbb694">CLOS</a></h2>
<div class="outline-text-2" id="text-12">
<p>
The Common Lisp Ojbect System, or <a id="org8fbb694">CLOS</a>, is a set of operators for doing object-oriented programming. Technically, they are in no way distinguished from the rest of Common Lisp: <code>defmethod</code> is just as much (and just as little) as integral part of the language as <code>defun</code>.<br />
</p>
</div>


<div id="outline-container-org67a23bd" class="outline-3">
<h3 id="org67a23bd"><span class="section-number-3">12.1.</span> <span class="done DONE">DONE</span> Object-Oriented Programming</h3>
<div class="outline-text-3" id="text-12-1">
<p>
Object-oriented programming means a change in the way programs are organized. Instead of having a single program that operates on an inert mass of data, the data itself it told how to behave, and the program is implicit in the interactions of these new data "objects".<br />
</p>


<p>
For example, suppose we want to write a program to find the areas of two-dimensional shapes. One way to do this would be to write a single function that looked at the type of its argument and behaved accordingly,<br />
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Area with structures and a function.</label><pre class="src src-lisp" id="orga5d4368">(defstruct rectangle
  height width)

(defstruct circle
  radius)

(defun area (x)
  (cond ((rectangle-p x)
         (* (rectangle-height x) (rectangle-width x)))
        ((circle-p x)
         (* pi (expt (circle-radius x) 2)))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((r (make-rectangle)))
           (setf (rectangle-height r) 2)
           (setf (rectangle-width r) 3)
           (area r))
6  
</pre>
</div>


<p>
Using <a href="#org8fbb694">CLOS</a> we might write an equivalent program:<br />
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Area with classes and methods.</label><pre class="src src-lisp" id="org1e5f245">(defclass rectangle ()
  (height width))

(defclass circle ()
  (radius))

(defmethod area ((x rectangle))
  (* (slot-value x 'height) (slot-value x 'width)))

(defmethod area ((x circle))
  (* pi (expt (slot-value x 'radius) 2)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((r (make-instance 'rectangle)))
           (setf (slot-value r 'height) 2
                 (slot-value r 'width) 3)
           (area r))
6  
</pre>
</div>

<p>
In the object-oriented model, the program gets broken up into several distinct <b>methods</b>, each one intended for certain kinds of arguments. The two methods in Program <a href="#orga5d4368">2</a> implicitly define an <code>area</code> function that works just like the one in Program <a href="#org1e5f245">3</a>. When we call <code>area</code>, Lisp looks at the type of the argument and invokes the corresponding method.<br />
</p>


<p>
Together with this way of breaking up functions into distinct methods, object-oriented programming implies <b><a id="orgdbc3478">inheritance</a></b> - both of slots and methods. The empty <a href="#org1a9ed34">list</a> given as the second argument in the two <code>defclasses</code> in Program <a href="#org1e5f245">3</a> is a <a href="#org1a9ed34">list</a> of superclasses. Suppose we define a new class of colored objects, and then a class of colored circles that has both <code>colored</code> and <code>circle</code> as superclasses:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass colored ()
  (color))

(defclass colored-circle (circle colored)
  ())
</pre>
</div>

<p>
When we make instance of <code>colored-circle</code>, we will see two kinnds of <a href="#orgdbc3478">inheritance</a>:<br />
</p>
<ol class="org-ol">
<li>Instances of <code>colored-circle</code> will have two slots: <code>radius</code>, which is inherited from the <code>circle</code> class, and <code>color</code>, which is inherited from the <code>colored</code> class.<br /></li>
<li>Because there is no area method defined explicitly for instances of <code>colored-circle</code>, if we call <code>area</code> on an instance of <code>colored-circle</code>, we will get the method defined for the <code>circle</code> class.<br /></li>
</ol>



<p>
In practical terms, object-oriented programming means organizing a program in terms of methods, classes, instances, and <a href="#orgdbc3478">inheritance</a>. Why would you want to organize programs this way? One of the claims of the object-oriented approach is that it makes programs easier to <b>change</b>. If we want to change the way objects of class <code>ob</code> are displayed, we just change the <code>display</code> method of the <code>ob</code> class. If we want to make a new class of objects like <code>obs</code> but different in a few respects, we can create a subclass of <code>ob</code>; in the subclass, we change the properties we want, and all the rest will be inherited by default from the <code>ob</code> class. And if we just want to make a single <code>ob</code> that behaves differently from the rest, we can create a new child of <code>ob</code> and modify the child's properties directly. If the program was written carefully to begin with, we can make all these <a href="#orgcc779bc">types</a> of modifications without even looking at the rest of the code.<br />
</p>
</div>
</div>





<div id="outline-container-org5f08a6c" class="outline-3">
<h3 id="org5f08a6c"><span class="section-number-3">12.2.</span> <span class="done DONE">DONE</span> Classes and Instances</h3>
<div class="outline-text-3" id="text-12-2">
<p>
In Section <a href="#org8c2276b">5.4</a> we went through two steps to create structures: we called <code>defstruct</code> to lay out the form of a <a href="#orge221c9c">structure</a>, and a specific function like <code>make-point</code> to make them. Creating instances requires two analogous steps. First we define a class, using <code>defclass</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass circle ()
  (radius center))
</pre>
</div>

<p>
To make instances of this class, instead of calling a specific function, we call the general <code>make-instance</code> with the class name as the first argument:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf c (make-instance 'circle))
#&lt;CIRCLE {1004E39A23}&gt;
</pre>
</div>

<p>
To set the slots in this in this instance, we can use <code>setf</code> with <code>slot-value</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf (slot-value c 'radius) 1)
1  
</pre>
</div>
<p>
The values of unitialized slots are undefined.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (slot-value c 'center)
; Evaluation aborted on #&lt;UNBOUND-SLOT CENTER {1005442393}&gt;.  
</pre>
</div>
</div>
</div>



<div id="outline-container-org1d458d4" class="outline-3">
<h3 id="org1d458d4"><span class="section-number-3">12.3.</span> <span class="done DONE">DONE</span> Slot Properties</h3>
<div class="outline-text-3" id="text-12-3">
<p>
The third argument to <code>defclass</code> must be a <a href="#org1a9ed34">list</a> of slot definitions. The simplest slot definition is a symbol representing its name. In the general case, a slot definition can be a <a href="#org1a9ed34">list</a> of name followed by one or more perperties. Properties are specified like keyword arguments.<br />
</p>


<p>
By defining an <code>:accessor</code> for a slot, we implicitly define a function that refers to the slot, making it unnecessary to call <code>slot-value</code>. If we update our difinition of the <code>circle</code> class as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass circle ()
  ((radius :accessor circle-radius)
   (center :accessor circle-center)))
</pre>
</div>
<p>
then we will be able to refer to the slots as <code>circle-radius</code> and <code>circle-center</code> respectively:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf c (make-instance 'circle))
#&lt;CIRCLE {10017B5E53}&gt;
CL-USER&gt; (setf (circle-radius c) 1)
1
CL-USER&gt; (circle-radius c)
1  
</pre>
</div>
<p>
By specifying a <code>:writer</code> or a <code>:reader</code> instead of an <code>:accessor</code>, we could get just the first half of this behavior or just the second.<br />
</p>




<p>
To specify a default value for a slot, we have to give an <code>:initform</code> argument. If we want to be able to initialize the slot in the call to <code>make-instance</code>, we define a <a href="#org44ae6ab">parameter</a> name as an <code>:initarg</code> (Initarg names are usually <a href="#org88f010a">keywords</a>, but they don't have to be.). With both added, our class definition might become:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass circle ()
  ((radius :accessor circle-radius
           :initarg :radius
           :initform 1)
   (center :accessor circle-center
           :initarg :center
           :initform (cons 0 0))))
</pre>
</div>
<p>
Now when we make an instance of a <code>circle</code> we can either pass a value for a slot using the <a href="#orgce97b1c">keyword parameter</a> defined as the slot's <code>:initarg</code>, or let the value default to that of the slot's <code>:initform</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf c (make-instance 'circle :radius 3))
#&lt;CIRCLE {10027AAFE3}&gt;
CL-USER&gt; (circle-radius c)
3
CL-USER&gt; (circle-center c)
(0 . 0)  
</pre>
</div>


<p>
We can specify that some slots are to be shared — that is, their value is the same for every instance. We do this by declaring the slot to have <code>:allocation :class</code>. (The alternative is for a slot to have <code>:allocation :instance</code>, but since this is the default there is no need to say so explicitly.) When we change the value of such a slot in one instance, that slot will get the same value in every other instance. So we would want to use shared slots to contain properties that all the instances would have in common.<br />
</p>



<p>
For example, suppose we wanted to simulate the behavior of a flock of tabloids. In our simulation we want to be able to represent the fact that when one tabloid takes up a subject, they all do. We can do this by making all the instances share a slot. If the <code>tabloid</code> class is defined as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass tabloid ()
  ((top-story :accessor tabloid-story
              :allocation :class)))  
</pre>
</div>
<p>
then if we make two instances of tabloids, whatever becomes front-age news to one instantly becomes front-page news to the other:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf daily-blab (make-instance 'tabloid)
               unsolicited-mail (make-instance 'tabloid))
#&lt;TABLOID {1003BBAD13}&gt;
CL-USER&gt; (setf (tabloid-story daily-blab) 'adultery-of-senator)
ADULTERY-OF-SENATOR
CL-USER&gt; (tabloid-story unsolicited-mail)
ADULTERY-OF-SENATOR  
</pre>
</div>



<p>
The <code>:documentation</code> property, if given, should be a string to serve as the slot's documentation. By specifying a <code>:type</code>, you are promising that the slot will only contain elements of that type.<br />
</p>
</div>
</div>


<div id="outline-container-org047ccc3" class="outline-3">
<h3 id="org047ccc3"><span class="section-number-3">12.4.</span> <span class="done DONE">DONE</span> Superclasses</h3>
<div class="outline-text-3" id="text-12-4">
<p>
The second argument to <code>defclass</code> is a <a href="#org1a9ed34">list</a> of superclasses. A class inherits the union of the slots of its superclasses.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass circle ()
  ((radius :accessor circle-radius
           :initarg :radius
           :initform 1)
   (center :accessor circle-center
           :initarg :center
           :initform (cons 0 0))))


(defclass graphic ()
  ((color :accessor graphic-color
          :initarg :color)
   (visible :accessor graphic-visible
            :initarg :visible
            :initform t)))


(defclass screen-circle (circle graphic)
  ())  
</pre>
</div>
<p>
then instances of <code>screen-circle</code> will have four slots, two inherited from each superclass. A class does not have to create any new slots of its own; <code>screen-circle</code> exists just to provide something instantiable that inherits from both <code>circle</code> and <code>graphic</code>.<br />
</p>


<p>
The accessors and initargs work for instances of screen-circle just as they would for instances of circle or graphic:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (graphic-color (make-instance 'screen-circle
                                       :color 'red
                                       :radius 3))
RED  
</pre>
</div>
<p>
We can add or change the properties to the slots. For example we can cause every <code>screen-circle</code> to have some default initial <code>color</code> by specifying an initform this slot in the <code>defclass</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass screen-circle (circle graphic)
  ((color :initform 'purple)))  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (graphic-color (make-instance 'screen-circle))
PURPLE  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(defclass screen-circle (circle graphic)
  ((color :initform 'purple)
   (radius :initform 3)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (circle-radius (make-instance 'screen-circle))
3  
</pre>
</div>
</div>
</div>


<div id="outline-container-org05326de" class="outline-3">
<h3 id="org05326de"><span class="section-number-3">12.5.</span> <span class="done DONE">DONE</span> <a href="#org904d9fe">Precedence</a></h3>
<div class="outline-text-3" id="text-12-5">
<p>
When there are methods defined for several of the classes to which an instance belongs, Lisp needs some way to decide which one to use. The point of <a id="org904d9fe">precedence</a> is to ensure that this happpens in an intuitive way.<br />
</p>


<p>
For every class there is a <a id="org444ac42">precedence list</a>: an ordering of itself and its superclasses from most specific to least specific.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass sculpture () (height width depth))

(defclass status (sculpture) (subject))

(defclass metalwork () (metal-type))

(defclass casting (metalwork) ())

(defclass cast-status (status casting) ())
</pre>
</div>

<p>
Figure <a href="#org9f9e1b1">4</a> contains a newwork representing <code>cast-status</code> and its superclass.<br />
</p>

<div id="org9f9e1b1" class="figure">
<p><img src="images/class-hierarchy.png" alt="class-hierarchy.png" /><br />
</p>
<p><span class="figure-number">Figure 4: </span>Class hierarchy</p>
</div>



<p>
To build such a network for a class, start at the bottom with a node representing that class. Draw links upward to nodes representing each of its immediate superclasses, laid out from left to right as they appeared in the calls to <code>defclass</code>. Repeat the process for each of those nodes,and soon,until you reach classes whose only immediate superclass is <code>standard-object</code> - that is, classes for which the second argument to <code>defclass</code> was <code>()</code>. Create links from those classes up to a node representing <code>standard-object</code>, and one from that node up to another node representing the class <code>t</code> . The result will be a network that comes to a point at both top and bottom, as in Figure <a href="#org9f9e1b1">4</a>.<br />
</p>


<p>
The <a href="#org444ac42">precedence list</a> for a class can be computed by traversing the corresponding networks as follows:<br />
</p>
<ol class="org-ol">
<li>Start at the bottom of the network.<br /></li>
<li>Walk upward, always taking the leftmost unexplored branch.<br /></li>
<li>If you are about to enter a node and you notice another path entering the same node from the right, then instead of entering the node, retrace your steps until you get to a node with an unexplored path leading upward. Go back to step 2.<br /></li>
<li>When you get to the node representing <code>t</code>, you're done. The order in which you first entered each node determines its place in the <a href="#org444ac42">precedence list</a>.<br /></li>
</ol>


<p>
One of the consequences of this definition (in fact, of rule 3) is that no class appears in the <a href="#org444ac42">precedence list</a> before one of its subclasses.<br />
</p>


<p>
The arrows in Figure <a href="#org9f9e1b1">4</a> show how it would be traversed. The <a href="#org444ac42">precedence list</a> determined by this graph is: <code>cast-statue, statue, sculpture, casting, metalwork, standard-object, t</code>. Sometimes the word specific is used as shorthand to refer to the position of a class in a given <a href="#org444ac42">precedence list</a>. The preceding <a href="#org1a9ed34">list</a> runs from most specific to least specific.<br />
</p>



<p>
The main point of <a href="#org904d9fe">precedence</a> is to decide what method gets used when a <a href="#orga4156ff">generic function</a> is invoked. The other time <a href="#org904d9fe">precedence</a> matters is when a slot with a given name is inherited from several superclasses.<br />
</p>
</div>
</div>




<div id="outline-container-orgad2d2fc" class="outline-3">
<h3 id="orgad2d2fc"><span class="section-number-3">12.6.</span> <span class="done DONE">DONE</span> Generic Functions</h3>
<div class="outline-text-3" id="text-12-6">
<p>
A <a id="orga4156ff">generic function</a> is a function made up of one or more methods. Methods are defined with <code>defmethod</code>, which is similar in form to <code>defun</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmethod combine (x y)
  (list x y))
</pre>
</div>

<p>
Now <code>combine</code> has one method. If we call <code>combine</code> at this point, we will get the two arguments in <a href="#org73b017c">alist</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (combine 'a 'b)
(A B)  
</pre>
</div>


<p>
So far we haven't done anything we could not have done with a normal function. The unusual thing about a <a href="#orga4156ff">generic function</a> is that we can continue to add new methods for it.<br />
</p>


<p>
First, we define some classes for the new methods to refer to:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass stuff ()
  ((name :accessor name
         :initarg :name)))

(defclass ice-cream (stuff) ())

(defclass topping (stuff) ())
</pre>
</div>


<p>
Now here is a second method for <code>combine</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmethod combine ((ic ice-cream) (top topping))
  (format nil "~A ice-cream with ~A topping."
          (name ic)
          (name top)))
</pre>
</div>

<p>
In this call to <code>defmethod</code> the parameters are <a id="org36bef2b">specialized</a>: each one appears in a <a href="#org1a9ed34">list</a> with the name of a class. The <a id="org7765cbc">specialization</a> of a method indicate the kinds of arguments to which it applies. The method just defined will only be used if the arguments to <code>combine</code> are instances of <code>ice-cream</code> and <code>topping</code> respectively.<br />
</p>



<p>
How does Lisp decide which method to use when a <a href="#orga4156ff">generic function</a> is called? It will use the most specific method for which the classes of the arguments match the specializations of the parameters. Which means that if we call <code>combine</code> with an instance of <code>ice-cream</code> and an instance of <code>topping</code>, we'll get the method we just defined:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (combine (make-instance 'ice-cream :name 'fig)
                  (make-instance 'topping :name 'treacle))
"FIG ice-cream with TREACLE topping."  
</pre>
</div>


<p>
But with any other arguments, we'll get the first method we defined:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (combine 123 'cheese)
(123 CHEESE)  
</pre>
</div>

<p>
Because neither of the parameters of the first method is <a href="#org36bef2b">specialized</a>, it will always get last priority, yet will always get called if no other method does. An unspecialized method acts as a safety net, like an <code>otherwise</code> clause in a <code>case</code> expression.<br />
</p>


<p>
Any combination of the parameters in a method can be <a href="#org36bef2b">specialized</a>. In this method only the first argument is:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmethod combine ((ic ice-cream) x)
  (format nil "~A ice-cream with ~A."
          (name ic)
          x))
</pre>
</div>


<p>
If we call <code>combine</code> with an instance of <code>ice-cream</code> and an instance of <code>topping</code>, we'll still get the method that's looking for both, because it's more specific:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (combine (make-instance 'ice-cream :name 'grape)
                  (make-instance 'topping :name 'marshmallow))
"GRAPE ice-cream with MARSHMALLOW topping."  
</pre>
</div>



<p>
However, if the first argument is <code>ice-cream</code> and the second argument is anything but <code>topping</code>, we'll get the method we just defined above:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (combine (make-instance 'ice-cream :name 'clam)
                  'reluctance)
"CLAM ice-cream with RELUCTANCE."  
</pre>
</div>




<p>
When a <a href="#orga4156ff">generic function</a> is called, the arguments determine a set of one or more <a id="org82d813e">applicable methods</a>. A method is applicable if the arguments in the call come within the specializations of all its parameters.<br />
</p>


<p>
If there are no <a href="#org82d813e">applicable methods</a> we get an error. If there is just one, it is called. If there is more than one, the most specific gets called. The most specific applicable method is determined based on the class <a href="#org904d9fe">precedence</a> for the arguments in the call. The arguments are examined left to right. If the first <a href="#org44ae6ab">parameter</a> of one of the <a href="#org82d813e">applicable methods</a> is <a href="#org36bef2b">specialized</a> on a more specific class than the first parameters of the other methods, then it is the most specific method. Ties are broken by looking at the second argument, and so on. We can't go through all the arguments and still have a tie, because then we would have two methods with exactly the same specializations. That's impossible because the definition of the second would overwrite the first.<br />
</p>



<p>
Methods don't have to be <a href="#org36bef2b">specialized</a> on classes defined by <code>defclass</code>. They can also be <a href="#org36bef2b">specialized</a> on <a href="#orgcc779bc">types</a> (or more precisely, the classes that mirror <a href="#orgcc779bc">types</a>). Here is a method for combine that's <a href="#org36bef2b">specialized</a> on numbers:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmethod combine ((x number) (y number))
  (+ x y))
</pre>
</div>


<p>
Methods can even be <a href="#org36bef2b">specialized</a> on individual objects, as determined by <code>eql</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmethod combine ((x (eql 'powder)) (y (eql 'spark)))
  'boom)
</pre>
</div>
<p>
Specializations on individual objects take <a href="#org904d9fe">precedence</a> over class specializations.<br />
</p>



<p>
Methods can have <a href="#org44ae6ab">parameter</a> lists as complex as ordinary Common Lisp functions, but the <a href="#org44ae6ab">parameter</a> lists of all the methods that compose a <a href="#orga4156ff">generic function</a> must be congruent. They must have the same number of <a href="#org5c23343">required parameters</a>, the same number of <a href="#org953b219">optional parameters</a> (if any), and must either all use <code>&amp;rest</code> or <code>&amp;key</code>, or all not use them. The following pairs of <a href="#org44ae6ab">parameter</a> lists are all congruent,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(x)  (a)
(x &amp;optional y)  (a &amp;optional b)
(x y &amp;rest z)  (a b &amp;key c)
(x y &amp;key z)  (a b &amp;key c d)
</pre>
</div>
<p>
and the following pairs are not:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(x)  (a b)
(x &amp;optional y)  (a &amp;optional b c)
(x &amp;optional y)  (a &amp;rest b)
(x &amp;key x y)  (a)
</pre>
</div>


<p>
Only <a href="#org5c23343">required parameters</a> can be <a href="#org36bef2b">specialized</a>. Thus each method is uniquely identified by its name and the specializations of its <a href="#org5c23343">required parameters</a>. If we define another method with the same qualifiers and specializations, it overwrites the original one. So by saying<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmethod combine ((x (eql 'powder)) (y (eql 'spark)))
  'kaboom)
</pre>
</div>
<p>
we redefine what combine does when its arguments are <code>powder</code> and <code>spark</code>.<br />
</p>
</div>
</div>


<div id="outline-container-orgdd5716b" class="outline-3">
<h3 id="orgdd5716b"><span class="section-number-3">12.7.</span> <span class="done DONE">DONE</span> <a href="#org738553c">Auxiliary Methods</a></h3>
<div class="outline-text-3" id="text-12-7">
<p>
Methods can be augmented by <b><a id="org738553c">auxiliary methods</a></b>, including before-, after-, and <a href="#org5c63fdf">around-methods</a>. <a id="org723e6ec">Before-methods</a> allow us to say, "But first, do this." They are called, most specific first, as a prelude to the rest of the method call. <a id="org8f9a2b7">After-methods</a> allow us to say, "P.S. Do this too." They are called, most specific last, as an epilogue to the method call. Between them, we run what has till now been considered just the method, but is more precisely known as the <b><a id="org028995f">primary method</a></b>. The value of this call is the one returned, even if <a href="#org8f9a2b7">after-methods</a> are called later.<br />
</p>



<p>
Before- and <a href="#org8f9a2b7">after-methods</a> allow us to wrap new behavior around the call to the <a href="#org028995f">primary method</a>. <a id="org5c63fdf">Around-methods</a> provide a more drastic way of doing the same thing. If an <a id="orgcea48ad">around-method</a> exists, it will be called instead of the <a href="#org028995f">primary method</a>. Then, at its own discretion, the <a href="#orgcea48ad">around-method</a> may itself invoke the <a href="#org028995f">primary method</a> (via the function <code>call-next-method</code>, which is provided just for this purpose).<br />
</p>



<p>
This is called <a id="org3c741fa">standard method combination</a>. In <a href="#org3c741fa">standard method combination</a>, calling a <a href="#orga4156ff">generic function</a> invokes<br />
</p>
<ol class="org-ol">
<li>The most specific <a href="#orgcea48ad">around-method</a>, if there is one.<br /></li>
<li>Otherwise, in order,<br />
a) All <a href="#org723e6ec">before-methods</a>, from most specific to least specific.<br />
b) The most specific <a href="#org028995f">primary method</a>.<br />
c) All <a href="#org8f9a2b7">after-methods</a>, from least specific to most specific.<br /></li>
</ol>


<p>
The value returned is the value of the <a href="#orgcea48ad">around-method</a> (in case 1) or the value of the most specific <a href="#org028995f">primary method</a> (in case 2).<br />
</p>



<p>
<a href="#org738553c">Auxiliary methods</a> are defined by putting a quilifiying keyword after the method name in the call to <code>defmethod</code>. If we define a primary <code>speak</code> method for the <code>speaker</code> class as:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass speaker () ())

(defmethod speak ((s speaker) string)
  (format t "~A" string))
</pre>
</div>
<p>
then calling <code>speak</code> with an instance of <code>speaker</code> just prints the second argument:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (speak (make-instance 'speaker) "I'm hungry")
I'm hungry
NIL  
</pre>
</div>

<p>
By defining a subclass <code>intellectual</code>, which wraps before- and after-methos around the primary <code>speak</code> method:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass intellectual (speaker) ())

(defmethod speak :before ((i intellectual) string)
  (princ "Perhaps "))

(defmethod speak :after ((i intellectual) string)
  (princ " in some sense."))
</pre>
</div>
<p>
we can create a subclass of speakers that always have the last and the first word:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (speak (make-instance 'intellectual)
                "I'm hungry")
Perhaps I'm hungry in some sense.
NIL  
</pre>
</div>



<p>
As the preceding outline of <a href="#org3c741fa">standard method combination</a> noted, all before- and <a href="#org8f9a2b7">after-methods</a> get called. So if we define before- or <a href="#org8f9a2b7">after-methods</a> for the speaker superclass:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defmethod speak :before ((s speaker) string)
  (princ "I think "))
</pre>
</div>
<p>
they will get called in the middle of the sandwich:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (speak (make-instance 'intellectual)
                "I'm hungry")
Perhaps I think I'm hungry in some sense.
NIL  
</pre>
</div>

<p>
Regardless of what before- or <a href="#org8f9a2b7">after-methods</a> get called, the value returned by the <a href="#orga4156ff">generic function</a> is the value of the most specific <a href="#org028995f">primary method</a> — in this case, the <code>nil</code> returned by <code>format</code>.<br />
</p>


<p>
This changes if there are <a href="#org5c63fdf">around-methods</a>. If there is an <a href="#orgcea48ad">around-method</a> <a href="#org36bef2b">specialized</a> for the arguments passed to the <a href="#orga4156ff">generic function</a>, the <a href="#orgcea48ad">around-method</a> will get called first, and the rest of the methods will only run if the <a href="#orgcea48ad">around-method</a> decides to let them. An around- or <a href="#org028995f">primary method</a> can invoke the next method by calling <code>call-next-method</code>. Before doing so, it can use <code>next-method-p</code> to test whether there is a next method to call.<br />
</p>



<p>
With <a href="#org5c63fdf">around-methods</a> we can define another, more cautious, subclass of <code>speaker</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass courtier (speaker) ())

(defmethod speak :around ((c courtier) string)
  (format t "Does the King believe that ~A? " string)
  (if (eql (read) 'yes)
      (if (next-method-p) (call-next-method))
      (format t "Indeed, it is a preposterous idea.~%"))
  'bow)
</pre>
</div>

<p>
When the first argument to <code>speak</code> is an instance of the <code>courtier</code> class, the courtier's tongue is now guarded by the <a href="#orgcea48ad">around-method</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (speak (make-instance 'courtier) "kings will last")
Does the King believe that kings will last? yes
I think kings will last
BOW
CL-USER&gt; (speak (make-instance 'courtier) "the world is round")
Does the King believe that the world is round? no
Indeed, it is a preposterous idea.
BOW
</pre>
</div>


<p>
Unlike before- and <a href="#org8f9a2b7">after-methods</a>, the value returned by the around- method is returned as the value of the <a href="#orga4156ff">generic function</a>.<br />
</p>
</div>
</div>



<div id="outline-container-orga6672b7" class="outline-3">
<h3 id="orga6672b7"><span class="section-number-3">12.8.</span> <span class="done DONE">DONE</span> Method Combination</h3>
<div class="outline-text-3" id="text-12-8">
<p>
In <a href="#org3c741fa">standard method combination</a> the only <a href="#org028995f">primary method</a> that gets called is the most specific (though it can call others vis <code>call-next-method</code>). Instead we might like to be ale to combine the results of all applicable primary methods.<br />
</p>


<p>
It's possible to define methods the are combined in other ways - for example, for a <a href="#orga4156ff">generic function</a> to return the sum of all the applicable primary methods. <a id="org520d9bc">Operator method combination</a> can be understood as if it resulted in the evaluation of a Lisp expression whose first element was some operators, and whose arguments were called to the applicable primary methods, in order of specificity. If we defined the <code>price</code> <a href="#orga4156ff">generic function</a> to combine values with +, and there were no applicable <a href="#org5c63fdf">around-methods</a>, it would behave as though it were defined:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun price (&amp;rest args)
  (+ (apply (most-specific-primary-method) args)
     ...
     (apply (least-specific-primary-method) args)))
</pre>
</div>

<p>
If there are applicable <a href="#org5c63fdf">around-methods</a>, they take <a href="#org904d9fe">precedence</a>, just as in <a href="#org3c741fa">standard method combination</a>. Under <a href="#org520d9bc">operator method combination</a>, an <a href="#orgcea48ad">around-method</a> can still call the next method via <code>call-next-method</code>. However, primary methods can no longer use <code>call-next-method</code>.<br />
</p>


<p>
We can specify the type of method combination to be used by a <a href="#orga4156ff">generic function</a> with a <code>:method-combination</code> clause in a call to <code>defgeneric</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defgeneric price (x)
  (:method-combination +))
</pre>
</div>

<p>
Now the <code>price</code> method will use + method combination; any <code>defmethod</code> for <code>price</code> must have + as the second argument. If we defind some classes with prices:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defclass jacket () ())

(defclass trousers () ())

(defclass suit (jacket trousers) ())

(defmethod price + ((jk jacket))
  350)

(defmethod price + ((tr trousers))
  200)
</pre>
</div>
<p>
then when we ask for the price of an instance of suit, we get the sum of the applicable <code>price</code> methods:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (price (make-instance 'suit))
550  
</pre>
</div>



<p>
The following symbols can be used as the second argument to <code>defmethod</code> or in the <code>:method-combination</code> option to <code>defgeneric</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">+  and  append  list  max  min  nconc  or  progn
</pre>
</div>
<p>
You can also use <code>standard</code>, which yields <a href="#org3c741fa">standard method combination</a>.<br />
</p>



<p>
Once you specify the method combination a <a href="#orga4156ff">generic function</a> should use, all methods for that function must use the same kind. Now it would cause an error if we tried to use another operator (or <code>:before</code> or <code>:after</code>) as the second argument in a <code>defmethod</code> for <code>price</code>.<br />
</p>
<pre class="example" id="orgfc07fab">
invalid method error for
  #1=#&lt;STANDARD-METHOD COMMON-LISP-USER::PRICE :BEFORE (SUIT) {1004CD7633}&gt;
method:
  The method #1# on
  #&lt;STANDARD-GENERIC-FUNCTION COMMON-LISP-USER::PRICE (3)&gt;
  has an invalid qualifier.

  The method combination type + was defined with the short form
  of DEFINE-METHOD-COMBINATION and so requires all methods have
  either the single qualifier + or the single qualifier :AROUND.
   [Condition of type SIMPLE-ERROR]
</pre>

<p>
If we want to change the method combination of <code>price</code>, we must remove the whole <a href="#orga4156ff">generic function</a> by calling <code>fmakunboud</code>.<br />
</p>
</div>
</div>




<div id="outline-container-orga6bddc3" class="outline-3">
<h3 id="orga6bddc3"><span class="section-number-3">12.9.</span> <span class="done DONE">DONE</span> <a href="#org3111573">Encapsulation</a></h3>
<div class="outline-text-3" id="text-12-9">
<p>
object-oriented languages often provide some way of distinguishing between the actual representation of objects and the interface they present to the world. Hiding implementation details brings two advantages: you can change the implementation without affecting the object's outward appearance, and you prevent objects from being modified in potentially dangerous ways. Hidden details are sometimes said to be <b><a id="orgd31adc9">encapsulated</a></b>.<br />
</p>


<p>
Although <a id="org3111573">encapsulation</a> is often associated with object-oriented programming, the two ideas are really seprate. You can have either one without the other. For example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(let ((counter 0))
  (defun our-reset ()
    (setf counter 0))
  (defun our-stamp ()
    (setf counter (+ counter 1))))  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (list (our-stamp) (our-stamp) (our-reset) (our-stamp))
(1 2 0 1) 
</pre>
</div>
<p>
The function <code>our-stamp</code> and <code>our-reset</code> work by sharing a counter, but calling code does not need to know about this counter, nor can it modify it directly.<br />
</p>



<p>
In Common Lisp, <a href="#org1f75805">packages</a> are the standard way to distinguish between public and private information. To restrict access to something, we put it in a separate <a href="#org82bfe8d">package</a>, and only export the names that are part of the external interface.<br />
</p>


<p>
We can encapsulate a slot by exporting the name of the methods that can modify it, but not the name of the slot itself. For example, we could define a <code>counter</code> class and associated <code>increment</code> and <code>clear</code> methods as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defpackage "CTR"
  (:use "COMMON-LISP")
  (:export "COUNTER" "INCREMENT" "CLEAR"))

(in-package ctr)

(defclass counter ()
  ((state :initform 0)))

(defmethod increment ((c counter))
  (incf (slot-value c 'state)))

(defmethod clear ((c counter))
  (setf (slot-value c 'state) 0))
</pre>
</div>
<p>
Under this definition, code outside the <a href="#org82bfe8d">package</a> would be able to make instances of <code>counter</code> and call <code>increment</code> and <code>clear</code>, but would not have legitimate access to the name <code>state</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (import 'ctr)
T
CL-USER&gt; (setf c (make-instance 'ctr:counter))
#&lt;CTR:COUNTER {1002753AD3}&gt;
CL-USER&gt; (slot-value c 'state)
; Evaluation aborted on #&lt;SIMPLE-ERROR "~@&lt;When attempting to ~A,
; the slot ~S is missing from the object ~S.~@[~a~]~@:&gt;" {1002754993}&gt;.  
</pre>
</div>


<p>
If you want to do more than just distinguish between the internal and external interface to a class, and actually make it impossible to reach the value stored in a slot, you can do that too. Simply <code>unintern</code> its name after you've defined the code that needs to refer to it:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(unintern 'state)
</pre>
</div>
<p>
Then there is no way, legitimate or otherwise, to refer to the slot from any <a href="#org82bfe8d">package</a>.<br />
</p>
</div>
</div>
</div>




<div id="outline-container-org7769f2a" class="outline-2">
<h2 id="org7769f2a"><span class="section-number-2">13.</span> <span class="done DONE">DONE</span> <a href="#orge221c9c">Structure</a></h2>
<div class="outline-text-2" id="text-13">
<p>
Section <a href="#orgbde7013">4.3</a> explained how Lisp's use of pointers allows us to put any value anywhere. This statement is full of possibilities, not all of them good. For example, an object can be an element of itself. Whether this is good or bad depends on whether it's done on purpose or by accident.<br />
</p>
</div>


<div id="outline-container-orgbab37f3" class="outline-3">
<h3 id="orgbab37f3"><span class="section-number-3">13.1.</span> <span class="done DONE">DONE</span> <a id="orgaa3e38d">Shared Structure</a></h3>
<div class="outline-text-3" id="text-13-1">
<p>
Lists can share conses in common. In the simplest case, one <a href="#org1a9ed34">list</a> might be part of another.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf part (list 'b 'c))
(B C)
CL-USER&gt; (setf whole (cons 'a part))
(A B C)
</pre>
</div>
<p>
The first <a href="#org11893e9">cons</a> is part of (in face, is the cdr of) the second. In situations like this, we say that the two lists <b><a id="orgbb18861">share structure</a>**</b>. The underlying <a href="#orge221c9c">structure</a> of the two lists is represented in Figure <a href="#orgfeae772">5</a>.<br />
</p>


<div id="orgfeae772" class="figure">
<p><img src="images/shared-structure.png" alt="shared-structure.png" /><br />
</p>
<p><span class="figure-number">Figure 5: </span><a href="#orgaa3e38d">Shared structure</a></p>
</div>


<p>
The predicate <code>tailp</code> detects this situation. It takes two lists and returns true if the first would be encountered on traversing the second:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (tailp part whole)
T  
</pre>
</div>


<p>
We could imagine it written as:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defune our-tailp (x y)
  (or (eql x y)
      (and (consp y)
           (our-tailp x (cdr y)))))
</pre>
</div>
<p>
As the definition suggests, every <a href="#org1a9ed34">list</a> is a stail of itself, and <code>nil</code> is a tail of every <a href="#orgd400c6b">proper list</a>.<br />
</p>



<p>
In the more complex case, two lists can <a href="#orgbb18861">share structure</a> without either one being a tail of the other. This happens when they share a tail in common, as in Figure <a href="#org8e16850">6</a>. We can create this situation as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf part (list 'b 'c)
      whole1 (cons 1 part)
      whole2 (cons 2 part))
</pre>
</div>


<div id="org8e16850" class="figure">
<p><img src="images/shared-tail.png" alt="shared-tail.png" /><br />
</p>
<p><span class="figure-number">Figure 6: </span>A shared tail</p>
</div>


<p>
Now <code>whole1</code> and <code>whole2</code> <a href="#orgbb18861">share structure</a> without either <a href="#org1a9ed34">list</a> being part of the other.<br />
</p>


<p>
When we have nested lists, it's important to distinguish between the lists <a id="org1180850">sharing structure</a>, and their elements <a href="#org1180850">sharing structure</a>. <b><a id="orga8c7dc3">Top-level list structure</a></b> refers to the conses that make up a <a href="#org1a9ed34">list</a>, not including any conses that make up its elements. Figure <a href="#org8841643">7</a> shows the <a href="#orga8c7dc3">top-level list structure</a> of a nested <a href="#org1a9ed34">list</a>.<br />
</p>

<div id="org8841643" class="figure">
<p><img src="images/top-level-list-structure.png" alt="top-level-list-structure.png" /><br />
</p>
<p><span class="figure-number">Figure 7: </span><a href="#orga8c7dc3">Top-level list structure</a></p>
</div>




<p>
Whether two conses <a href="#orgbb18861">share structure</a> depends on whether we are considering them as lists or as <a href="#orga9b0a3a">trees</a>. Two nested lists may <a href="#orgbb18861">share structure</a> as <a href="#orga9b0a3a">trees</a>, without <a href="#org1180850">sharing structure</a> as lists. The following code creates the situation shown in Figure <a href="#orge9665bb">8</a>, in which two lists contain the same <a href="#org1a9ed34">list</a> as an element:<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf element (list 'a 'b)
      holds1 (list 1 element 2)
      holds2 (list element 3))
</pre>
</div>


<div id="orge9665bb" class="figure">
<p><img src="images/shared-subtree.png" alt="shared-subtree.png" /><br />
</p>
<p><span class="figure-number">Figure 8: </span>Shared subtree</p>
</div>


<p>
Although the second element of <code>holds1</code> shares <a href="#orge221c9c">structure</a> with (in fact, is identical) to the first element of <code>holds2</code>, <code>holds1</code> and <code>holds2</code> do not <a href="#org306b3dc">share structure as lists</a>. Two lists only <a id="org306b3dc">share structure as lists</a> if they share <a href="#orga8c7dc3">top-level list structure</a>, which <code>holds1</code> and <code>holds2</code> do not.<br />
</p>



<p>
If we want to avoid <a href="#org1180850">sharing structure</a>, we can do it by copying. The function <code>copy-list</code>, which could be defined as<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-copy-list (lst)
  (if (null lst)
      nil
      (cons (car lst) (our-copy-list (cdr lst)))))
</pre>
</div>
<p>
will return a <a href="#org1a9ed34">list</a> that doesn't share <a href="#orga8c7dc3">top-level list structure</a> with the original <a href="#org1a9ed34">list</a>.<br />
</p>


<p>
The function <code>copy-tree</code>, which might be defined as<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-copy-tree (tr)
  (if (atom tr)
      tr
      (cons (our-copy-tree (car tr))
            (our-copy-tree (cdr tr)))))
</pre>
</div>
<p>
will return a <a href="#org1a9ed34">list</a> that doesn't even share tree <a href="#orge221c9c">structure</a> with original <a href="#org1a9ed34">list</a>. Figure shows the different between calling <code>copy-list</code> and <code>copy-tree</code> on a nested <a href="#org1a9ed34">list</a>.<br />
</p>



<div id="orgeeb0730" class="figure">
<p><img src="images/two-kinds-of-copying.png" alt="two-kinds-of-copying.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgdc31a67" class="outline-3">
<h3 id="orgdc31a67"><span class="section-number-3">13.2.</span> <span class="done DONE">DONE</span> Modification</h3>
<div class="outline-text-3" id="text-13-2">
<p>
Why would we want to avoid <a href="#org1180850">sharing structure</a>? Up to this point, the issue of <a href="#orgaa3e38d">shared structure</a> has been just an intellectual exercise. It would not have made any difference to any program we've written so far. It is when we modify objects that <a href="#orgaa3e38d">shared structure</a> becomes an issue. If two lists <a href="#orgbb18861">share structure</a>, and we modify one, then we may inadvertently be modifying the other.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf whole (list 'a 'b 'c)
               tail (cdr whole))
(B C)
CL-USER&gt; (setf (second tail) 'e)
E
CL-USER&gt; tail
(B E)
CL-USER&gt; whole
(A B E)  
</pre>
</div>

<p>
It's not always an error to modify two things at once. Sometimes it might be what you want. But when it happens inadvertently, modifying <a href="#orgaa3e38d">shared structure</a> can cause some very subtle bugs. Lisp programmers learn to be aware of <a href="#orgaa3e38d">shared structure</a>, and to suspect it immediately in certain kinds of errors. When a <a href="#org1a9ed34">list</a> mysteriously changes for no apparent reason, it is probably because you changed something else that <a href="#orgaa3e38d">shared structure</a> with it.<br />
</p>


<p>
It is not the <a href="#orgaa3e38d">shared structure</a> that's dangerous, but the changing. To be on the safe side, simply avoid using <code>setf</code> (or related operators like <code>pop</code>, <code>rplaca</code>, etc.) on <a href="#org1a9ed34">list</a> <a href="#orge221c9c">structure</a>, and you won't run into any problems. If some application absolutely requires you to modify <a href="#org1a9ed34">list</a> <a href="#orge221c9c">structure</a>, find out where the lists come from to make sure that they don't <a href="#orgbb18861">share structure</a> with anything that shouldn't be changed. If they do, or if you can't predict where the lists will come from, make the changes to a <code>copy</code>.<br />
</p>





<p>
You have to be doubly careful when you are calling a function written by someone else. Until you know otherwise, consider the possibility that anything you pass to the function<br />
</p>
<ol class="org-ol">
<li>could have destructive operations done to it, and/or<br /></li>
<li>could be saved somewhere, so that if you later modified the object, you would also be modifying part of something that the other code was maintaining for its own use.<br /></li>
</ol>

<p>
In both cases, the solution is to pass a copy.<br />
</p>



<p>
In Common Lisp, a function called in the course of travering <a href="#org1a9ed34">list</a> structrue (e.g. an argument to <code>mapcar</code> or <code>remove-if</code>) is not allowed to modify the <a href="#orge221c9c">structure</a> being traversed. The consequence of evaluating such code are undefined.<br />
</p>
</div>
</div>


<div id="outline-container-org3eb41df" class="outline-3">
<h3 id="org3eb41df"><span class="section-number-3">13.3.</span> <span class="done DONE">DONE</span> Destructive Functions</h3>
<div class="outline-text-3" id="text-13-3">
<p>
Common Lisp includes several function that are allowed to modify <a href="#org1a9ed34">list</a> <a href="#orge221c9c">structure</a>. This functions are destructive for reason of efficiency. Though they may recycle conses passed to them as arguments, they are not meant to be called for their side-effects.<br />
</p>


<p>
For example, <code>delete</code> is a destructive version of <code>remove</code>. While it is allowed to trash the <a href="#org1a9ed34">list</a> passed to it as an argument, it doesn't promise to do anything. This is what happens in most implementations:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst '(a r a b i a))
(A R A B I A)
CL-USER&gt; (delete 'a lst)
(R B I)
CL-USER&gt; lst
(A R B I)  
</pre>
</div>

<p>
As with <code>remove</code>, if you want side-effects, you should use <code>setf</code> with the return value:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf lst (delete 'a lst))
</pre>
</div>


<p>
As an example of how destructive functions recycle the lists passed to them, consider <code>nconc</code> (The <code>n</code> originally stood for "non-<a href="#org256e883">consing</a>." Several destructive functions have names beginning with <code>n</code>.), the destructive version of <code>append</code>. This two-argument version shows clearly how two existing lists are sewn together:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun nconc2 (x y)
  (if (consp x)
      (progn
        (setf (cdr (last x)) y)
        x)
      y))
</pre>
</div>
<p>
We go the last <a href="#org11893e9">cons</a> cell in the first <a href="#org1a9ed34">list</a>, and set its cdr to point to the second <a href="#org1a9ed34">list</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst1 '(a b c))
(A B C)
CL-USER&gt; (setf lst2 '(1 2 3))
(1 2 3)
CL-USER&gt; (append lst1 lst2)
(A B C 1 2 3)
CL-USER&gt; lst1
(A B C)
CL-USER&gt; lst2
(1 2 3)
CL-USER&gt; (nconc lst1 lst2)
(A B C 1 2 3)
CL-USER&gt; lst1
(A B C 1 2 3)
CL-USER&gt; lst2
(1 2 3)  
</pre>
</div>



<p>
The function <code>mapcan</code> is like <code>mapcar</code>, but splices together the values returned by the function (which must be lists) using <code>nconc</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf lst1 '(a b c))
(A B C)
CL-USER&gt; (setf lst2 '(1 2 3 4))
(1 2 3 4)
CL-USER&gt; (mapcar #'list lst1 lst2)
((A 1) (B 2) (C 3))
CL-USER&gt; lst1
(A B C)
CL-USER&gt; lst2
(1 2 3 4)  
CL-USER&gt; (mapcan #'list lst1 lst2)
(A 1 B 2 C 3)
CL-USER&gt; lst1
(A B C)
CL-USER&gt; lst2
(1 2 3 4)
</pre>
</div>

<p>
This function might be defined as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-mapcan (fn &amp;rest lsts)
  (apply #'nconc (apply #'mapcar fn lsts)))
</pre>
</div>
<p>
Use <code>mapcan</code> with caution, because it is destructive. It splices together the returned lists with <code>nconc</code>, so they had better not be needed elsewhere.<br />
</p>



<p>
This kind of function is particularly useful in problems that can be understood as collecting all the nodes at one level of some tree. For example, if <code>children</code> returns a <a href="#org1a9ed34">list</a> of someone's children, then we could define a function to return a <a href="#org1a9ed34">list</a> of someone's grandchildren as follows:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun grandchildren (x)
  (mapcan #'(lambda (c)
              (copy-list (children c)))
          (children x)))
</pre>
</div>
<p>
This function calls <code>copy-list</code> on the assumption that <code>children</code> returns a <a href="#org1a9ed34">list</a> that's stored somewhere, instead of making a fresh one.<br />
</p>


<p>
A nondestructive variant of <code>mapcan</code> might be defined:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun mappend (fn &amp;rest lsts)
  (apply #'append (apply #'mapcar fn lsts)))
</pre>
</div>

<p>
If we used <code>mappend</code>, we could leave out the <code>copy-list</code> in the definition of <code>grandchildren</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun grandchildren (x)
  (mappend #'children (children x)))
</pre>
</div>
</div>
</div>


<div id="outline-container-org85dc6f5" class="outline-3">
<h3 id="org85dc6f5"><span class="section-number-3">13.4.</span> <span class="done DONE">DONE</span> Circular <a href="#orge221c9c">Structure</a></h3>
<div class="outline-text-3" id="text-13-4">
<p>
There are two kinds of circular lists. The most useful are those whose <a href="#orga8c7dc3">top-level list structure</a> is a loop. Such lists are called *<a id="orga2e485a">cdr-circular</a> because the loop passes through the cdr part of a <a href="#org11893e9">cons</a>.<br />
</p>



<p>
To make a <a href="#orga2e485a">cdr-circular</a> <a href="#org1a9ed34">list</a> with one element, you set the cdr of a <a href="#org1a9ed34">list</a> to be the <a href="#org1a9ed34">list</a> itself:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf x '(a))
(A)
CL-USER&gt; (progn (setf (cdr x) x) nil)
NIL  
</pre>
</div>


<p>
If Lisp tries to print the <a href="#org1a9ed34">list</a> we just create, it would usually display <code>(a a a , ad infininum)</code> (or stucked). But if we set the global <code>*print-circle*</code> to <code>t</code>, objects will be displayed in a way that can represent circular <a href="#orge221c9c">structure</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf *print-circle* t)
T
CL-USER&gt; x
#1=(A . #1#)  
</pre>
</div>
<p>
If you need to, you can use the #n= and #n# <a href="#org106d8cc">read-macro</a> to represent <a href="#orgaa3e38d">shared structure</a> youself.<br />
</p>



<p>
<a href="#orga2e485a">cdr-circular</a> lists could be useful - to represent buffers or pools, for example. The following function would take any non-<a href="#orga2e485a">cdr-circular</a>, nonempty <a href="#org1a9ed34">list</a> and convert it into  <a href="#orga2e485a">cdr-circular</a> <a href="#org1a9ed34">list</a> with the same elements:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun circular (lst)
  (setf (cdr (last lst)) lst))
</pre>
</div>


<p>
The other kind of circular lists are *<a id="org633b1b0">car-circular</a> lists. A <a href="#org633b1b0">car-circular</a> <a href="#org1a9ed34">list</a> is a tree that has itself as a subtree. They are so called because the loop passes through the car of some <a href="#org11893e9">cons</a>. Here we create a <a href="#org633b1b0">car-circular</a> <a href="#org1a9ed34">list</a> whose second element is itself:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((y (list 'a)))
           (setf (car y) y)
           y)
#1=(#1#)  
</pre>
</div>


<p>
Figure <a href="#org5d80af4">9</a> shows the resulting <a href="#orge221c9c">structure</a>. Though <a href="#org633b1b0">car-circular</a>, this <a href="#org1a9ed34">list</a> is a <a href="#orgd400c6b">proper list</a>. <a href="#orga2e485a">Cdr-circular</a> lists are never proper lists, but <a href="#org633b1b0">car-circular</a> lists can be, unless they are disqualified for some other reason.<br />
</p>

<div id="org5d80af4" class="figure">
<p><img src="images/circualr-lists.png" alt="circualr-lists.png" /><br />
</p>
<p><span class="figure-number">Figure 9: </span>Circular lists</p>
</div>


<p>
A <a href="#org1a9ed34">list</a> could be both <a href="#org633b1b0">car-circular</a> and <a href="#orga2e485a">cdr-circular</a>. The car and the cdr of this <a href="#org11893e9">cons</a> will be the <a href="#org11893e9">cons</a> itself:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((c (cons 1 1)))
           (setf (car c) c
                 (cdr c) c)
           c)
#1=(#1# . #1#)  
</pre>
</div>
<p>
It's hard to imagine what the use of such an object would be. Indeed, the main reason to know about circular lists may be to avoid creating them by accident, because most functions that traverse <a href="#org1a9ed34">list</a> <a href="#orge221c9c">structure</a> will go into an infinite loop if they are given a <a href="#org1a9ed34">list</a> that's circular in the dimension they traverse.<br />
</p>




<p>
Circular <a href="#orge221c9c">structure</a> can be an issue for other kinds of objects besides lists. For example, an <a href="#orge488891">array</a> can contain itself as an element:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf *print-array* t)
T
CL-USER&gt; (let ((a (make-array 1)))
           (setf (aref a 0) a)
           a)
#1=#(#1#)  
</pre>
</div>
<p>
Indeed, just about anything that can have elements can have itself as an element.<br />
</p>



<p>
It's quite common to have circularities involving structures created by <code>defstruct</code>. For example, a <a href="#orge221c9c">structure</a> <code>c</code> representing an element in a tree might have a <code>parent</code> field that contained another <a href="#orge221c9c">structure</a> <code>p</code> whose <code>child</code> field in turn contained <code>c</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (progn
           (setf *print-circle* t)
           (defstruct my-elt
             (parent nil)
             (child nil))
           (let ((c (make-my-elt))
                 (p (make-my-elt)))
             (setf (my-elt-parent c) p
                   (my-elt-child p) c)
             c))
#1=#S(MY-ELT :PARENT #S(MY-ELT :PARENT NIL :CHILD #1#) :CHILD NIL)  
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org92a99b0" class="outline-2">
<h2 id="org92a99b0"><span class="section-number-2">14.</span> <span class="done DONE">DONE</span> Speed</h2>
<div class="outline-text-2" id="text-14">
<p>
Lisp is really two languages: a language for writting fast programs and a language for writting programs fast. In the early stages of a program you can trade speed for convenience. Then once the <a href="#orge221c9c">structure</a> of your program begins to crystallize, you can refine critical portions to make them faster.<br />
</p>



<p>
It's difficult to give general advice about optimization, because of the variation between Common Lisp implementations. A change that made your program faster in one implementation might make it slower in another. This is something that comes with the territory. The more powerful the language, the further you are from the machine, and the further you are from the machine, the greater the chance that different implementations will take different paths toward it. So while there are some techniques that are almost certain to make your programs faster, the aim of this chapter will be to suggest rather than to prescribe.<br />
</p>
</div>



<div id="outline-container-orga9f92b2" class="outline-3">
<h3 id="orga9f92b2"><span class="section-number-3">14.1.</span> <span class="done DONE">DONE</span> The <a id="org5e3a214">Bottleneck Rule</a></h3>
<div class="outline-text-3" id="text-14-1">
<p>
Three points can be made about optimization, regardless of the implementation:<br />
</p>
<ol class="org-ol">
<li>It should be focused on bottlenecks.<br /></li>
<li>It should not begin too early.<br /></li>
<li>It should begin with algorithms.<br /></li>
</ol>


<p>
Probably the most important thing to understand about optimization is that programs tend to have a few bottlenecks that account for a great part of the execution time. According to Knuth, "most of the running time in non-IO-bound programs is concentrated in about 3% of the source text." Optimizing these parts of the program will make it run noticeably faster; optimizing the rest of the program will be a waste of time in comparison.<br />
</p>




<p>
So the crucial <b>first</b> step in optimizing any program is to find the bottlenecks. Many Lisp implementations come with <a id="orgd3522fc">profilers</a> that can watch a program as it's running and report the amount of time spent in each part. A profiler is a valuable tool — perhaps even a necessity — in producing the most efficient code.<br />
</p>


<p>
A corollary of the <a href="#org5e3a214">bottleneck rule</a> is that one should not put too much effort into optimization early in a program's life. Knuth puts the point even more strongly: "Premature optimization is the root of all evil (or at least most of it) in programming." It's hard to see where the real bottlenecks will be when you've just started writing a program, so there's more chance you'll be wasting your time. Optimizations also tend to make a program harder to change.<br />
</p>




<p>
You end up with better programs if each task can be emphasized at the appropriate time. One of the benefits of Lisp is that it lets you work at a range of different speeds: you can write slow code fast or fast code slow. In the early stages of a program you tend to work in the former mode, then as optimization takes <a href="#org904d9fe">precedence</a> you switch into the latter. As the <a href="#org5e3a214">bottleneck rule</a> suggests, this is a more effective use of your time. In a very low-level language, like assembler, you are essentially optimizing every line of the program. Most of this effort is wasted, because the bottlenecks only make up a small part of it. A more abstract language allows you to spend a greater proportion of your time on the bottlenecks, and so get most of the gains with a fraction of the effort.<br />
</p>



<p>
When you do turn to optimization, begin at the top. That is, make sure that you're using the most efficient algorithm before you resort to low-level coding tricks. The potential gains are greater — perhaps great enough that you won't have to resort to coding tricks after all. This rule has to be balanced against the preceding one, though. Sometimes decisions about algorithms have to be made early.<br />
</p>
</div>
</div>


<div id="outline-container-org7693b3c" class="outline-3">
<h3 id="org7693b3c"><span class="section-number-3">14.2.</span> <span class="done DONE">DONE</span> Compilation</h3>
<div class="outline-text-3" id="text-14-2">
<p>
Five parameters control the way your code is compiled:<br />
</p>
<dl class="org-dl">
<dt>speed</dt><dd>refers to the speed of the code produced by the compiler;<br /></dd>
<dt>compilation-speed</dt><dd>refers to the speed at which your program will be compiled;<br /></dd>
<dt>safety</dt><dd>refers to the amount of error-checking done in the object code;<br /></dd>
<dt>space</dt><dd>refers to the size and memory needs of the object code;<br /></dd>
<dt>debug</dt><dd>refers to the amount of information retained for debugging.<br /></dd>
</dl>




<p>
The compilation parameters are not real variables. They are assigned weights from 0 (unimportant) to 3 (most important) in declarations. If a major bottleneck occurred in the inner loop of some function, we might add a declaration like the following:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun bottleneck (...)
  (do (...)
      (...)
    (do (...)
        (...)
      (declare (optimize (speed 3) (safety 0)))
     ...)))
</pre>
</div>
<p>
Generally you would not want to add such declarations until the code was finished and tested.<br />
</p>



<p>
To ask globally for the fastest possible code, regardless of the consequences, you could say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(declaim (optimize (speed 3)
                   (compilation-speed 0)
                   (safety 0)
                   (debug 0)))
</pre>
</div>
<p>
This would be a drastic step, and probably not even necessary, given the <a href="#org5e3a214">bottleneck rule</a>.<br />
</p>



<p>
One particularly important kind of optimization done by Lisp compilers is the optimization of tail calls. Giving <code>speed</code> the maximum weight will ensure <a href="#org2e53af1">tail call</a> optimization by any compiler capable of it.<br />
</p>

<p>
A call is a <a id="org2e53af1">tail call</a> if nothing remians to be done after it returns. The following function returns the length of a <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun length/r (lst)
  (if (null lst)
      0
      (1+ (length/r (cdr lst)))))
</pre>
</div>

<p>
The <a href="#org7e3c89d">recursive</a> call is not a <a href="#org2e53af1">tail call</a>, because after it returns, its value has to be passed to <code>1+</code>. However, this version is tail-<a href="#org7e3c89d">recursive</a>,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun length/tr (lst)
  (labels ((len (lst acc)
             (if (null lst)
                 acc
                 (len (cdr lst) (1+ acccc)))))
    (len lst 0)))
</pre>
</div>
<p>
or more precisely, the local function <code>len</code> is, because nothing more has to happen after the <a href="#org7e3c89d">recursive</a> call returns. Instead of building its return value on the way back up the recursion, like <code>length/r</code>, it accumulates the return value in the additional <a href="#org44ae6ab">parameter</a> <code>acc</code> on the way down.<br />
</p>


<p>
A good compiler can compile a <a href="#org2e53af1">tail call</a> into a goto, and so can compile a tail-<a href="#org7e3c89d">recursive</a> function into a loop. In typical machine language code, when control arrives for the first time at the segment of instructions representing <code>len</code>, there is information on the stack saying what to do upon returning. Because nothing remains to be done after the <a href="#org7e3c89d">recursive</a> call, this information remains valid for the second invocation as well: what we are supposed to do on returning from the second invocation is simply to return from the first invocation. So after setting the parameters to their new values, we can just jump back to the beginning of the function and act as if this were the second invocation. There is no need to do a real function call.<br />
</p>


<p>
Another way to have the abstraction of function calls without the cost is to have functions compiled inline. This is valuable mainly for small functions, where the machinery of calling the function could entail more work than the function itself performs. For example, the following function tells whether something is a <a href="#org1a9ed34">list</a> of a single element:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(declaim (inline single?))

(defun single? (lst)
  (and (consp lsp)
       (null (cdr lst))))
</pre>
</div>
<p>
Because this function is globally decalred inline, a reference to <code>single?</code> within a compiled function should no longer require a real function call. If we define a function that calls it,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun foo (x)
  (single? (bar x)))
</pre>
</div>
<p>
then when <code>fool</code> is compiled, the code for <code>single?</code> should be compiled right into it, just as if we had written<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun foo (x)
  (let ((lst (bar x)))
    (and (consp lst)
         (null (cdr lst)))))
</pre>
</div>
<p>
in the first place.<br />
</p>


<p>
There are two limitations on inline compilation. <a href="#org7e3c89d">Recursive</a> functions can't be inlined. And if an inlined function is redefined, we have to recompile any function that calls it, or the calling function will still reflect the old definition.<br />
</p>


<p>
Different Lisp compilers do varying amounts of optimiztion. If you want to see the code your compiler produce for a function, try calling <code>disassemble</code>. This function takes a function or function name and displays its compiled form.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (defun foo (x)
           x)
FOO
CL-USER&gt; (disassemble 'foo)
; disassembly for FOO
; Size: 16 bytes. Origin: #x2277EF0D                          ; FOO
; 0D:       498B4510         MOV RAX, [R13+16]                ; thread.binding-stack-pointer
; 11:       488945F8         MOV [RBP-8], RAX
; 15:       488BE5           MOV RSP, RBP
; 18:       F8               CLC
; 19:       5D               POP RBP
; 1A:       C3               RET
; 1B:       CC10             INT3 16                          ; Invalid argument count trap
NIL  
</pre>
</div>
<p>
Even if what you see is completely incomprehensible, you can still use <code>disassemble</code> to determine whether declarations are being used: compile two version of the function, one with the declaration and one without, and see if the code displayed by <code>disassemble</code> differs between the two. You can use a similar technique to see if functions are being compiled inline. In either case, be sure to set the compilation parameters beforehand to get the fatest code.<br />
</p>
</div>
</div>


<div id="outline-container-org97c3aa6" class="outline-3">
<h3 id="org97c3aa6"><span class="section-number-3">14.3.</span> <span class="done DONE">DONE</span> <a href="#org8dffea0">Type Declarations</a></h3>
<div class="outline-text-3" id="text-14-3">
<p>
In most languages, you have to declare the type of each <a href="#orge9b5a96">variable</a>, and the <a href="#orge9b5a96">variable</a> can only hold values of that type. Such a language is said to be <b><a id="org6e8cbc7">strong typed</a></b>. As well as being a lot of work for the programmer, this approach imposes restrictions on what you can do. In such a language it's hard to write functions that work for different kinds of arguments, or to have data <a href="#orge221c9c">structure</a> that contain different kinds of elements. The advantage of this approach is that whenever the compiler sees an addition, for example, it knows beforehand what kind of addition is involved. If both arguments are integers, it can hard-wire an integer addition in the object code.<br />
</p>


<p>
Common Lisp uses a more flexible approach called <a href="#org2cf8994">manifest typing</a> (There are two ways to describe Lisp's approach to typing: by where the type information is kept, and by when it is used. <a href="#org2cf8994">Manifest typing</a> means that the type information is attached to the data objects, and <a id="org9ebad24">run-time typing</a> means that type information is used at run-time. In practice they mean the same thing.). Values have <a href="#orgcc779bc">types</a>, not variables. Variables can hold objects of any type.<br />
</p>


<p>
If we left it at that, we would have to pay for this flexibility in speed. Because it can take several different <a href="#orgcc779bc">types</a> of numbers, + would have to look at the <a href="#orgcc779bc">types</a> of each of its arguments, and decide what kind of addition to do at run-time.<br />
</p>




<p>
If we just want an integer addition after all, this is an inefficient way to get it. So Common Lisp's approach is: tell me as much as you know. If we know ahead of time that both of the arguments in some addition will be fixnums, then we can declare them to be such, and the compiler will hard-wire an integer addition just as in C.<br />
</p>



<p>
So the difference between the two approaches to typing need not entail any difference in speed. It's just that <a href="#org6e8cbc7">strong typed</a> approach makes <a id="org8dffea0">type declarations</a> mandatory, and <a href="#org2cf8994">manifest typing</a> doesn't. In Common Lisp, <a href="#org8dffea0">type declarations</a> are completely optional. They may make a program faster, but (unless incorrect) they will not change its behavior.<br />
</p>



<p>
<a id="orgef3a3cc">Global declarations</a> are made with <code>declaim</code>, which should be followed by one or more declaration forms. A type declaration is a <a href="#org1a9ed34">list</a> containing the symbol <code>type</code>, followed by a type name and the name of one or more variables. So to declare the type of a <a href="#org402c5bb">global variable</a>, one could say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(declaim (type fixnum *count*))
</pre>
</div>
<p>
In ANSI Common Lisp you can omit the <code>type</code> and say simply:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(declaim (fixnum *count*))
</pre>
</div>



<p>
<a id="org02dbd1f">Local declarations</a> are made with <code>declare</code>, which takes the same arguments as <code>declaim</code>. Declarations can begin any body of code where variables have just been created: in <code>defun</code>, <code>let</code>, <code>do</code>, and so on. To declare a functions's parameters to be <code>fixnum</code>, we would say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun ploy (a b x)
  (declare (fixnum a b c))
  (+ (* a (expt x 2)) (* b x)))
</pre>
</div>
<p>
A <a href="#orge9b5a96">variable</a> name in a type declaration refers to the <a href="#orge9b5a96">variable</a> with that name in the context where the declaration occurs.<br />
</p>


<p>
You can also declare that the value of ean expression will be of a certain type, by using <code>the</code>. If we know beforehand that <code>a, b</code> and <code>x</code> will not only be fixnums, but that they will be small enough fixnums that all the intermediate results will be fixnums, we can say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun ploy (a b x)
  (declare (fixnum a b x))
  (the fixnum (+ (the fixnum (* a (the fixnum (expt x 2))))
                 (the fixnum (* b x)))))
</pre>
</div>
<p>
This looks awkward. Fortunately, there are two reasons that you rarely have to clutter up your numeric code with <code>the</code> in this way. One is that it's easy to use <a href="#orge6ba26a">macros</a> to insert such declarations for you. The other is that some implementations use special tricks to make fixnum arithmetic fast without declarations.<br />
</p>




<p>
There are a great many <a href="#orgcc779bc">types</a> in Common Lisp — a potentially unlimited number, considering that you can define new <a href="#orgcc779bc">types</a> yourself. However, declarations only matter for a few. When does it pay to make <a href="#org8dffea0">type declarations</a>? There are two general rules:<br />
</p>

<ol class="org-ol">
<li>It pays to declare the <a href="#orgcc779bc">types</a> of arguments to functions that work for arguments of several different <a href="#orgcc779bc">types</a> (but not all <a href="#orgcc779bc">types</a>). If you knew that the arguments in a call to + would always be fixnums, or that the first argument in a call to <code>aref</code> would always be a particular kind of <a href="#orge488891">array</a>, it could pay to make a type declaration.<br /></li>
<li>It is usually only worthwhile to make declarations for <a href="#orgcc779bc">types</a> near the bottom of the type hierarchy: declaring something to be of type <code>fixnum</code> or <code>simple-array</code> might be useful, but declaring something to be of type <code>integer</code> or <code>sequence</code> probably would not.<br /></li>
</ol>



<p>
<a href="#org8dffea0">Type declarations</a> are particularly important for the contents of complex objects, including arrays, structures, and instances. Such declarations can improve efficiency in two ways: as well as allowing the compiler to determine the <a href="#orgcc779bc">types</a> of arguments to functions, they make it possible to represent these objects more efficiently in memory.<br />
</p>


<p>
If nothing is known about the type of elements an <a href="#orge488891">array</a> will contain, it has to be represented in memory as a block of pointers. But if it is known that the <a href="#orge488891">array</a> will only contain, say, double-floats, then the <a href="#orge488891">array</a> can be represented as a block of actual double-floats. This way the <a href="#orge488891">array</a> will take less space, because we no longer need a pointer to point to each of the double-floats, and access will be faster, because we don't have to follow pointers to read and write elements.<br />
</p>


<p>
You can specify the kind of values that an <a href="#orge488891">array</a> will contain by giving the <code>:element-type</code> argument to <code>make-array</code>. Such an an <a href="#orge488891">array</a> is called a <a href="#org36bef2b">specialized</a> <a href="#orge488891">array</a>. Figure <a href="#orge8c6ef3">10</a> shows what would happen, in most implementations, as a result of evaluating the following code:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf x (vector 1.234d0 2.345d0 3.456d0)
      y (make-array 3 :element-type 'double-float)
      (aref y 0) 1.234d0
      (aref y 1) 2.345d0
      (aref y 2) 3.456d0)
</pre>
</div>

<div id="orge8c6ef3" class="figure">
<p><img src="images/effect-of-specifying-element-type.png" alt="effect-of-specifying-element-type.png" /><br />
</p>
<p><span class="figure-number">Figure 10: </span>Effect of specifying element type</p>
</div>

<p>
Each rectangle in Figure <a href="#orge8c6ef3">10</a> represents a word of memory. The two arrays each consist of a header of unspecified length, followed by some representation of the tree elements. In <code>x</code>, each element is represented by a pointer. All three pointers happen to point to double-floats at the moment, but we could store objects of any type in this <a href="#org8f5f037">vector</a>. In <code>y</code>, each element is an actual double-float. This is fater and takes less space, but it means that the <a href="#org8f5f037">vector</a> can only hold double-floats. Note that we use aref to refer to the elements of y. A <a href="#org36bef2b">specialized</a> <a href="#org8f5f037">vector</a> is no longer a simple <a href="#org8f5f037">vector</a>, so we can no longer use svref to refer to its elements.<br />
</p>


<p>
As well as specifying the element type of an <a href="#orge488891">array</a> when you create it, you should declare the dimensions and element type of an <a href="#orge488891">array</a> in code that uses it. A full <a href="#org8f5f037">vector</a> declaration would look like:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(declare (type (vector fixnum 20) v))
</pre>
</div>
<p>
This declare <code>v</code> to be a <a href="#org8f5f037">vector</a> of length 20, <a href="#org36bef2b">specialized</a> for fixnums.<br />
</p>


<p>
The most general form of <a href="#orge488891">array</a> declaration consists of the <a href="#orge488891">array</a> type followed by the element type and a <a href="#org1a9ed34">list</a> of dimensions:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(declare (type (simple-array fixnum (4 4)) arr))
</pre>
</div>
<p>
This declare that <code>arr</code> will be \(4\times 4\) simple <a href="#orge488891">array</a> <a href="#org36bef2b">specialized</a> for fixnums.<br />
</p>




<p>
The following code shows how to create a \(1000 \times 1000\) <a href="#orge488891">array</a> of single-floats, and how to write a function to sum the elements of such an <a href="#orge488891">array</a>. Arrays are<br />
stored in row-major order and should be traversed that way when possible.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf a (make-array '(1000 1000)
                    :element-type 'single-float
                    :initial-element 1.0s0))


(defun sum-elts (a)
  (declare (type (simple-array single-float (1000 1000)) a))
  (let ((sum 0.0s0))
    (declare (type single-float sum))
    (dotimes (r 1000)
      (dotimes (c 1000)
        (incf sum (aref a r c))))
    sum))

</pre>
</div>


<p>
We use <code>time</code> to compare the performance of <code>sum-elts</code> with and without declarations. The <code>time</code> macro displays some (implementation-dependent) measure of how long it takes to evaluate an expression. It's only meaningful to time compiled functions.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (time (sum-elts a))
Evaluation took:
  0.001 seconds of real time
  0.001061 seconds of total run time (0.001060 user, 0.000001 system)
  100.00% CPU
  2,870,804 processor cycles
  0 bytes consed

1000000.0  
</pre>
</div>

<p>
If we take the <a href="#org8dffea0">type declarations</a> out of <code>sum-elts</code> and recompile it, the same computation takes more time:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (time (sum-elts a))
Evaluation took:
  0.008 seconds of real time
  0.008579 seconds of total run time (0.008564 user, 0.000015 system)
  112.50% CPU
  23,358,101 processor cycles
  0 bytes consed

1000000.0
</pre>
</div>


<p>
The importance of <a href="#org8dffea0">type declarations</a>, especially for arrays and numbers, cannot be overemphasized.<br />
</p>
</div>
</div>


<div id="outline-container-org3e32324" class="outline-3">
<h3 id="org3e32324"><span class="section-number-3">14.4.</span> <span class="done DONE">DONE</span> <a href="#org78c2eb2">Garbage</a> Avoidance</h3>
<div class="outline-text-3" id="text-14-4">
<p>
As Lisp allows you to delay thinking about the <a href="#orgcc779bc">types</a> of variables, it also allows you to delay thinking about memory allocation. In the early stages of a program it frees your imagination not to have to think about (or deal with bugs involving) memory allocation. As a program matures, it can rely less on dynamic allocation and so become faster.<br />
</p>


<p>
However, <a href="#org256e883">consing</a> less does not always make a program faster. In Lisp implementations with bad <a href="#org78c2eb2">garbage</a> collectors, programs that <a href="#org11893e9">cons</a> a lot tend to run slowly. Until recently, most Lisp implementations have had bad <a href="#org78c2eb2">garbage</a> collectors, and so it has become a tradition that efficient programs should <a href="#org11893e9">cons</a> as little as possible. Recent developments have turned this conventional wisdom on its head. Some implementations now have such sophisticated <a href="#org78c2eb2">garbage</a> collectors that it is faster to <a href="#org11893e9">cons</a> up new objects and throw them away than it is to recycle them.<br />
</p>


<p>
This section introduces some ways to make programs <a href="#org11893e9">cons</a> less. Whether <a href="#org256e883">consing</a> less will make your programs run faster depends on the implementation. Again, the best advice is to try it and see.<br />
</p>




<p>
There are a lot of things you can do to reduce <a href="#org256e883">consing</a>. Some of them won't affect the shape of your program at all. For example, one of the easiest steps you can take is to use destructive functions. The following table lists some commonly used functions and their destructive counterparts.<br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">SAFE</th>
<th scope="col" class="org-left">DESTRUCTIVE</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">append</td>
<td class="org-left">nconc</td>
</tr>

<tr>
<td class="org-left">reverse</td>
<td class="org-left">nreverse</td>
</tr>

<tr>
<td class="org-left">remove</td>
<td class="org-left">delete</td>
</tr>

<tr>
<td class="org-left">remove-if</td>
<td class="org-left">delete-if</td>
</tr>

<tr>
<td class="org-left">remove-duplicates</td>
<td class="org-left">delete-duplicates</td>
</tr>

<tr>
<td class="org-left">subst</td>
<td class="org-left">nsubst</td>
</tr>

<tr>
<td class="org-left">subst-if</td>
<td class="org-left">nsubst-if</td>
</tr>

<tr>
<td class="org-left">union</td>
<td class="org-left">nunion</td>
</tr>

<tr>
<td class="org-left">intersection</td>
<td class="org-left">nintersection</td>
</tr>

<tr>
<td class="org-left">set-difference</td>
<td class="org-left">nset-difference</td>
</tr>
</tbody>
</table>
<p>
When you know it's safe to modify a <a href="#org1a9ed34">list</a>, you can use <code>delete</code> instead of <code>remove</code>, <code>nreverse</code> instead of <code>reverse</code>, and so on.<br />
</p>


<p>
If you want to eliminate <a href="#org256e883">consing</a> entirely, you don't have to give up the possibility of creating things on the fly. What you have to avoid is allocating space for them on the fly, and reclaiming it by <a href="#orge333f43">garbage collection</a>. The general solution is to allocate <a href="#orgb7e4be1">blocks</a> of memory beforehand, and explicitly recycle used <a href="#orgb7e4be1">blocks</a> yourself. Beforehand could mean at compile-time, or in some initialization routine. When spped begins to matter depends on the application.<br />
</p>




<p>
For example, when circumstances allow us to impose a limit on the size of a stack, we could have the stack grow and shrink along a pre-allocated <a href="#org8f5f037">vector</a>, instead of building it out of conses. Common Lisp has built-in support for using vectors as <a href="#orgee5744c">stacks</a>. If we give the optional <code>fill-pointer</code> argument to <code>make-array</code>, we will get a <a href="#org8f5f037">vector</a> that seems to be expandable. The first argument to <code>make-array</code> specifies the amount of storage to be allocated for the <a href="#org8f5f037">vector</a>, but the <code>fill-pointer</code>, when given, specifies the initial effective length:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf *print-array* t)
T
CL-USER&gt; (setf vec (make-array 10 :fill-pointer 2
                                  :initial-element nil))
#(NIL NIL)  
</pre>
</div>
<p>
The <a href="#org8f5f037">vector</a> we just made will seem to <a href="#orgfef3696">sequence</a> functions as if it had only two elements,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (length vec)
2  
</pre>
</div>
<p>
but it will be able to grow until it has up to ten. Because <code>vec</code> has a fill pointer, we can use the functions <code>vector-push</code> and <code>vector-pop</code> to push and pop elements as if it where a <a href="#org1a9ed34">list</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (vector-push 'a vec)
2
CL-USER&gt; vec
#(NIL NIL A)
CL-USER&gt; (vector-pop vec)
A
CL-USER&gt; vec
#(NIL NIL)  
</pre>
</div>
<p>
When we called <code>vector-push</code>, it incremented the fill pointer and returned its old value. As long as the fill pointer is less than the initial argument to <code>make-array</code>, we can push new elements onto the <a href="#org8f5f037">vector</a>; when it runs out of space, <code>vector-push</code> will return <code>nil</code>. We could push up to eight more elements onto <code>vec</code> at this point.<br />
</p>


<p>
One disadvantage of vectors with fill pointers is that they are no longer simple vectors. We have to use <code>aref</code> instead of <code>svref</code> to refer to elements. This cost has to be balanced against the potential gains.<br />
</p>



<p>
In applications that involve very long sequences, you may want to use <code>map-into</code> instead of <code>map</code>. Instead of a <a href="#orgfef3696">sequence</a> type, <code>map-into</code> takes as its first argument an actual <a href="#orgfef3696">sequence</a> to hold the result. This <a href="#orgfef3696">sequence</a> can be one of those from which the arguments to the function are taken. So, for example, if you want to increment each element of a <a href="#org8f5f037">vector</a> <code>v</code>, you might write:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf v (map-into v #'1+ v))
</pre>
</div>


<p>
Another way to avoid <a href="#orge333f43">garbage collection</a> is to encourage the compiler to allocate objects on the stack instead of the <a href="#org177347b">heap</a>. When you know that you will only need something temporarily, you may be able to avoid allocating space for it on the <a href="#org177347b">heap</a> by declaring it to have <a id="org2c77109">dynamic extent</a>.<br />
</p>


<p>
By giving a <a href="#org2c77109">dynamic extent</a> declaration for a <a href="#orge9b5a96">variable</a>, you're saying that the <a href="#orge9b5a96">variable</a>'s value need not last any longer than the <a href="#orge9b5a96">variable</a> does. When could the value last longer than the <a href="#orge9b5a96">variable</a>? Here's an example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-reverse (lst)
  (let ((rev nil))
    (dolist (x lst)
      (push x rev))
    rev))
</pre>
</div>
<p>
In <code>our-reverse</code>, the <a href="#org1a9ed34">list</a> passed as an argument will be accumulated in reverse order in <code>rev</code>. When the function returns, the <a href="#orge9b5a96">variable</a> <code>rev</code> will go away. However, the <a href="#org1a9ed34">list</a> that is its value will persist: it is sent back to the calling function, where who knows what fate awaits it.<br />
</p>



<p>
In contrast, consider the following implementation of <code>adjoin</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-adjoin (obj lst &amp;rest args)
  (if (apply #'member obj lst args)
      lst
      (cons obj lst)))
</pre>
</div>
<p>
In this case, we can see from the definition of the function that the <a href="#org1a9ed34">list</a> in <code>args</code> is going nowhere. It need not last longer than the <a href="#orge9b5a96">variable</a> itself. This is the kind of situation where it would make sense to make a <a href="#org2c77109">dynamic extent</a> declaration. If we add such a declaration,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun our-adjoin (obj lst &amp;rest args)
  (declare (dynamic-extent args))
  (if (apply #'member obj lst args)
      lst
      (cons obj lst)))
</pre>
</div>
<p>
then the compiler is free (but not required) to allocate space for <code>args</code> on the stack, where it will be automatically discarded on return from <code>our-adjoin</code>.<br />
</p>
</div>
</div>



<div id="outline-container-org8b4dce5" class="outline-3">
<h3 id="org8b4dce5"><span class="section-number-3">14.5.</span> <span class="done DONE">DONE</span> Fast Operators</h3>
<div class="outline-text-3" id="text-14-5">
<p>
The beginning of this chapter described Lisp as two different languages. In one sense this is literally true. If you look closely at the design of Common Lisp, you can see that some features are intended mainly for speed, and others mainly for convenience.<br />
</p>



<p>
For example, there are three functions you could use to retrieve the element at a given position in a <a href="#org8f5f037">vector</a>: <code>elt</code>, <code>aref</code>, and <code>svref</code>. Such variety exists to allow you to squeeze as much performance out of a program as possible. So if you can use <code>svref</code>, do. Conversely, a part of a program where speed is important probably should not be calling <code>elt</code> , which works for both arrays and lists.<br />
</p>


<p>
Instead of calling <code>elt</code> on a <a href="#org1a9ed34">list</a>, you can call <code>nth</code>, which is specifically for lists. Yet there is only a single function, <code>length</code>, for finding the length of any <a href="#orgfef3696">sequence</a>. Why doesn't Common Lisp provide a separate version for lists? Because if your program is finding the lengths of lists, it's already lost, as far as speed is concerned. In this case, as in many others, the design of the language suggests what is fast and what isn't.<br />
</p>


<p>
Another pair of similar functions are <code>eql</code> and <code>eq</code>. The former is the default predicate for testing identity, but the latter is faster if you know that the arguments won't be <a href="#org9caef75">characters</a> or numbers. Two objects are <code>eq</code> when they have the same location in memory. Numbers and <a href="#org9caef75">characters</a> may not be associated with any particular memory location, so <code>eq</code> does not apply to them (though in most implementations it does work for fixnums). For arguments of any other kind, <code>eq</code> will return the same value as <code>eql</code>.<br />
</p>


<p>
It's always fastest to compare objects using <code>eq</code>, because all Lisp has to do is compare the pointers to them. In an <code>eq</code> hash table, <code>gethash</code> can just hash on pointers, without even looking at what they point to. Access is not the only thing to consider, however; <code>eq</code> and <code>eql</code> <a href="#org2df624c">hash tables</a> incur extra costs under copying <a href="#orge333f43">garbage collection</a> algorithms because they have to be rehashed after a GC. If this becomes a problem, the best solution may be to use an <code>eql</code> hash table with fixnums as keys.<br />
</p>



<p>
Calling <code>reduce</code> can be a more efficient alternative to <code>apply</code> when the function in question has a <a href="#org2450710">rest parameter</a>. For example, instead of something like<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(apply #'+ '(1 2 3))
</pre>
</div>
<p>
it can be more efficient to say:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(reduce #'+ ' (1 2 3))  
</pre>
</div>


<p>
Not only does it help to call the right functions, it helps to call them the right way. Rest, optional, and keyword parameters are expensive. With ordinary parameters, the arguments in a function call are simply left by the caller where the callee knows to look for them. But other kinds of parameters involve processing at run-time. Keyword parameters are the worst. For built-in functions, good compilers take special measures to compile calls with keyword arguments into fast code. But in your own functions it is just as well to avoid using them in speed-critical parts of a program. It is also wise not to push large numbers of arguments into rest parameters, if this can be avoided.<br />
</p>


<p>
Individual compilers sometimes perform their own particular optimizations. For example, some compilers can optimize <code>case</code> statements where the keys are integers in a narrow range. Check your user's manual for hints about such implementation-specific optimizations.<br />
</p>
</div>
</div>



<div id="outline-container-orgcfb6765" class="outline-3">
<h3 id="orgcfb6765"><span class="section-number-3">14.6.</span> <span class="done DONE">DONE</span> Two-Phase Development</h3>
<div class="outline-text-3" id="text-14-6">
<p>
In applications where speed is paramount, you may want to rewrite part of a Lisp program in a lower-level language like C or assembler. You can use this technique with programs written in any language — critical parts of C programs are often rewritten in assembler — but the more abstract the language, the greater the benefits of developing programs in two phases.<br />
</p>


<p>
Common Lisp does not prescribe a way of integrating code written in other languages. This is left up to the implementation, but almost all implementations provide some way to do it.<br />
</p>


<p>
It may seem wasteful to write a program in one language and then to rewrite part of it in another. In fact, experience has shown this to be a good way to develop software. It can be easier to aim for functionality first, and then for speed, than to try to achieve both at the same time.<br />
</p>



<p>
If programming were an entirely mechanical process — a matter of simply translating specifications into code — it would be reasonable to do everything in a single step. But programming is never like that. No matter how precise the specifications, programming always involves a certain amount of exploration — usually a lot more than anyone had anticipated.<br />
</p>

<p>
It might seem that if the specifications were good, programming would simply be a matter of translating them into code. This is a widespread misconception. Programming necessarily involves exploration, because specifications are necessarily vague. If they weren't vague, they wouldn't be specifications.<br />
</p>



<p>
In other fields, it may be desirable for specifications to be as precise as possible. If you're asking for a piece of metal to be cut to a certain shape, it's probably best to say exactly what you want. But this rule does not extend to software, because programs and specifications are made out of the same thing: text. You can't write specifications that say exactly what you want. If the specifications were that precise, then they would be the program.<br />
</p>


<p>
In applications that involve a substantial amount of exploration, it can pay to separate implementation into two phases. And the medium you use in the first phase need not be the final one. It can be better to write a program in Lisp, and then rewrite it in C, than to try to write it in C from the start.<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org9e814f2" class="outline-2">
<h2 id="org9e814f2"><span class="section-number-2">15.</span> Advanced Topics</h2>
<div class="outline-text-2" id="text-15">
<p>
Common Lisp is like an iceberg: a great part of its functionality is invisible to most users, who never need it. You may never need to define <a href="#org1f75805">packages</a> or <a href="#org0ab7536">read-macros</a> of your own, but when you do, it is helpful to have examples to work from.<br />
</p>
</div>



<div id="outline-container-org1ac0d18" class="outline-3">
<h3 id="org1ac0d18"><span class="section-number-3">15.1.</span> Type Specifiers</h3>
<div class="outline-text-3" id="text-15-1">
<p>
<a href="#orgcc779bc">Types</a> are not objects in Common Lisp. There is no object that corresponds to the type <code>integer</code>, for example. What we get from a function like <code>type-of</code>, and give as an argument to function like <code>typep</code>, is not a type, but a <a href="#org3d0cae7">type specifier</a>.<br />
</p>


<p>
A <a id="org3d0cae7">type specifier</a> is the name of a type. The simplest type specifiers are symbols like <code>integer</code>. These form a hierarchy in Common Lisp. At the top of the hierarchy is the type <code>t</code> - all objects are of type <code>t</code>. The hierarchy is a tree. There are two paths from <code>nil</code> to the top, for example: one through <code>atom</code>, and the other through <code>list</code> and <code>sequence</code>.<br />
</p>


<p>
A type is really just a set of objects. Which means that there are as many <a href="#orgcc779bc">types</a> as there are <a href="#orgc8b66b2">sets</a> of objects: an ifinite number. We can denote some of these <a href="#orgc8b66b2">sets</a> with <a id="orgd4f0e58">atomic type specifiers</a>: <code>integer</code> denotes the set of all the integers. But we can also construct <a id="orgbbf2fcd">compound type specifiers</a> that refer to any set of objects.<br />
</p>


<p>
For example, if <code>a</code> and <code>b</code> are two type specifiers, the <code>(or a b)</code> denotes the union of the type denoted by <code>a</code> and that denoted by <code>b</code>.That is, an object is of type <code>(or a b)</code> if it is of type <code>a</code> or type <code>b</code>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (mapcar #'(lambda (x)
                 (typep x '(or integer string)))
                 '(1 "hello"))
(T T)  
</pre>
</div>



<p>
Some of the <a href="#orgd4f0e58">atomic type specifiers</a> can also appear in <a href="#orgbbf2fcd">compound type specifiers</a>. To denote the set of integers between 1 and 100 inclusive, we could use:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(integer 1 100)
</pre>
</div>
<p>
Such a <a href="#org3d0cae7">type specifier</a> is said to denote a <a id="orgf3afe79">finite type</a>.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (typep 3 '(integer 1 100))
T  
</pre>
</div>

<p>
In a compound <a href="#org3d0cae7">type specifier</a>, you can leave some information unspecifed by using * in place of an argument. So<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(simple-array fixnum (* *))
</pre>
</div>
<p>
describes the set of two-dimensional simple arrays <a href="#org36bef2b">specialized</a> for fixnums, and<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(simple-array fixnum *)
</pre>
</div>
<p>
describes the set (a supertype of the first) of simple arrays <a href="#org36bef2b">specialized</a> for fixnums. Trailing asterisks can be dropped, so in the latter case we could have said:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(simple-array fixnum)
</pre>
</div>
<p>
If no argument are given to a compound <a href="#org3d0cae7">type specifier</a>, you can use an atom. So <code>simple-array</code> describes the set of all simple arrays.<br />
</p>



<p>
If there is some <a href="#orgbbf2fcd">compound type specifiers</a> that you'd like to use repreatedly, you can define an abbreviation for it with <code>deftype</code>. This macro is jsut like <code>defmacro</code>, but expands into a <a href="#org3d0cae7">type specifier</a> instead of an expression. By saying,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(deftype integer-or-string ()
  `(or integer string))
</pre>
</div>
<p>
we define <code>proseq</code> as a new atomic <a href="#org3d0cae7">type specifier</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (typep 1 'integer-or-string)
T
CL-USER&gt; (typep "hello" 'integer-or-string)
T
</pre>
</div>


<p>
If you define a <a href="#org3d0cae7">type specifier</a> to take arguments, the arguments are treated as forms (that is, not evaluated), just as with def macro. So<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (deftype multiple-of (n)
    (let ((my-predicate (gensym)))
      (setf (symbol-function my-predicate)
            #'(lambda (x)
                (zerop (mod x n))))
      `(and integer (satisfies ,my-predicate))))

;  (deftype multiple-of (n)
;    `(and integer (satisfies (lambda (x)
;			       (zerop (mod x ,n))))))
</pre>
</div>
<p>
defines <code>(multiple-of n)</code> as a specifier for all multiples of <code>n</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (typep 12 '(multiple-of 4))
T
CL-USER&gt; (typep 12 '(multiple-of 3))
T
CL-USER&gt; (typep 12 '(multiple-of 5))
NIL  
</pre>
</div>


<p>
Type specifiers are interpreted, and therefore slow, so you would generally be better off defining a function to make this kind of test.<br />
</p>
</div>
</div>


<div id="outline-container-orgb83aa84" class="outline-3">
<h3 id="orgb83aa84"><span class="section-number-3">15.2.</span> Binary Streams</h3>
<div class="outline-text-3" id="text-15-2">
<p>
A <a id="org85ccbdc">binary stream</a> is a source and/or destination of integers. You create a <a href="#org85ccbdc">binary stream</a> by specifying a subtype of <code>integer</code> — most often <code>unsigned-byte</code> — as the <code>:element-type</code> when you open the stream.<br />
</p>

<p>
There are only two functions for I/O on binary streams, <code>read-byte</code> and <code>write-byte</code>. So here is how you might define a function to copy a file:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun copy-file (from to)
  (with-open-file (in from :direction :input
                           :element-type 'unsigned-byte)
    (with-open-file (out to :direction :output
                            :element-type 'unsigned-byte)
      (do ((i (read-byte in nil -1) (read-byte in nil -1)))
          ((minusp i))
        (declare (fixnum i))
        (write-tye i out)))))  
</pre>
</div>



<p>
By specifying just <code>unsigned-byte</code> as the <code>:element-type</code>, you let the operating system choose the length of a byte. If you specifically wanted to read or write 7-bit integers, for example, you would use<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(unsigned-byte 7)
</pre>
</div>
<p>
as the <code>:element-type</code> instead.<br />
</p>
</div>
</div>



<div id="outline-container-org10d9b72" class="outline-3">
<h3 id="org10d9b72"><span class="section-number-3">15.3.</span> <a href="#org0ab7536">Read-Macros</a></h3>
<div class="outline-text-3" id="text-15-3">
<p>
A <a href="#org27bb92c">macro character</a> has a special meaning to <code>read</code>. Each such character has a function associated with it that tells <code>read</code> what to do when the character is encountered. You can change the function associated with an existing <a href="#org27bb92c">macro character</a>, or define new <a href="#org0ab7536">read-macros</a> of your own.<br />
</p>


<p>
The function <code>set-macro-character</code> provides one way to define <a href="#org0ab7536">read-macros</a>. It takes a character and a function, and thereafter when <code>read</code> encounter the character, it returns the result of calling the function.<br />
</p>

<p>
One of the oldest <a href="#org0ab7536">read-macros</a> in Lisp is ', the quote. We could define ti as:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(set-macro-character #\'
                     #'(lambda (stream char)
                         (list (quote quote)
                               (read stream t nil t))))  
</pre>
</div>
<p>
When <code>read</code> encounters an instance of ' in normal text, it will return the result of calling this function on the current stream and character. (The function ignores this second <a href="#org44ae6ab">parameter</a>, which will always be the quote character.) So when <code>read</code> see <code>'a</code>, it will return <code>(quote a)</code>.<br />
</p>

<p>
Now we see the point of the last argument to <code>read</code>. It says whether the call to <code>read</code> occurs within a call to <code>read</code>. The arguments to <code>read</code> will be the same in nearly all <a href="#org0ab7536">read-macros</a>: the stream; the second argument, <code>t</code>, which says that <code>read</code> should signal an error if the next thing it sees is the end-of-file; the third argument, which says what to return instead of generating an error is therefore irrelevant; and the fourth argument, <code>t</code>, which says that the call to <code>read</code> is a <a href="#org7e3c89d">recursive</a> one.<br />
</p>


<p>
You can (with <code>make-dispatch-macro-character</code>) define your own <a href="#org5c7168b">dispatching</a> macro <a href="#org9caef75">characters</a>, but since # is alreadly define as one, you may as well use it. Six combinations beginning with # are explicitly reserved for your use: <code>#!, #? #[, #], #{</code> and <code>#}</code>.<br />
</p>



<p>
You can define new <a href="#org5c7168b">dispatching</a> <a href="#org27bb92c">macro character</a> combinations by calling <code>set-dispatch-macro-character</code>, which is like <code>set-macro-character</code> except that it takes two character arguments. This code defines <code>#?</code> as a <a href="#org106d8cc">read-macro</a> that returns a <a href="#org1a9ed34">list</a> of integers.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(set-dispatch-macro-character #\# #\?
                              #'(lambda (stream char1 char2)
                                  (list 'quote
                                        (let ((lst nil))
                                          (dotimes (i (+ (read stream t nil t) 1))
                                            (push i lst))
                                          (nreverse lst)))))
</pre>
</div>

<p>
Now <code>#?n</code> will be read as a <a href="#org1a9ed34">list</a> of all the integers from 0 to n. For example:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; #?7
(0 1 2 3 4 5 6 7)
</pre>
</div>



<p>
After simple macro <a href="#org9caef75">characters</a>, the most commonly defined macro <a href="#org9caef75">characters</a> are <a href="#org1a9ed34">list</a> delimiters. Another character combination reserved for the user is <code>#{</code>. Here we define it as a more elaborate kind of left parenthesis:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(set-macro-character #\}
                     (get-macro-character #\)))


(set-dispatch-macro-character #\# #\{
                              #'(lambda (stream char1 char2)
                                  (let ((accum nil)
                                        (pair (read-delimited-list #\} stream t)))
                                    (do ((i (car pair) (+ i 1)))
                                        ((&gt; i (cadr pair))
                                         (list 'quote (nreverse accum)))
                                      (push i accum)))))  
</pre>
</div>

<p>
This defines an expression of the form <code>#{x y}</code> to read as a <a href="#org1a9ed34">list</a> of all the integers between x and y, inclusive:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; #{2 9}
(2 3 4 5 6 7 8 9)  
</pre>
</div>

<p>
The function <code>read-delimited-list</code> is provided just for such <a href="#org0ab7536">read-macros</a>. Its first argument is the character to treat as the end of the <a href="#org1a9ed34">list</a>. For <code>}</code> to be recognized as a delimiter, it must first be given this role, hence the preliminary call to <code>set-macro-character</code>.<br />
</p>




<p>
If you want to use a <a href="#org106d8cc">read-macro</a> in the file in which it is defined, the definition should be wrapped in an <code>eval-when</code> expression, to ensure that it is evaluated at compile time. Otherwise the definition will be compiled, but not evaluated until the compiled file is loaded.<br />
</p>
</div>
</div>



<div id="outline-container-orged2694e" class="outline-3">
<h3 id="orged2694e"><span class="section-number-3">15.4.</span> <a href="#org1f75805">Packages</a></h3>
<div class="outline-text-3" id="text-15-4">
<p>
A <a href="#org82bfe8d">package</a> is a Lisp object that maps names to symbols. The current <a href="#org82bfe8d">package</a> is always stored in the <a href="#org402c5bb">global variable</a> <code>*package*</code>. When Common Lisp starts up, the current <a href="#org82bfe8d">package</a> will be <code>common-lisp-user</code>, informally known as the user <a href="#org82bfe8d">package</a>. The function <code>package-name</code> returns the name of a <a href="#org82bfe8d">package</a>, and <code>find-package</code> returns the <a href="#org82bfe8d">package</a> with a given name:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (package-name *package*)
"COMMON-LISP-USER"
CL-USER&gt; (find-package "COMMON-LISP-USER")
#&lt;PACKAGE "COMMON-LISP-USER"&gt;  
</pre>
</div>


<p>
Usually a symbol is interned in the <a href="#org82bfe8d">package</a> that was current at the time it was read. The function <code>symbol-package</code> takes a symbol and returns the <a href="#org82bfe8d">package</a> in which it is interned.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (symbol-package 'sym)
#&lt;PACKAGE "COMMON-LISP-USER"&gt;
</pre>
</div>

<p>
Interestingly, this expression returns the value it does because the expression had to be read before it could be evaluated, and reading the expression caused <code>sym</code> to be interned.<br />
</p>



<p>
For future use, let's give <code>sym</code> a value:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf sym 99)
99
</pre>
</div>


<p>
Now we will create and switch to a new <a href="#org82bfe8d">package</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (setf *package* (make-package 'mine
                                       :use '(common-lisp)))
#&lt;PACKAGE "MINE"&gt;  
</pre>
</div>



<p>
At this point there should be eerie music, because we are in a different world: <code>sym</code> here is not what it used to be.<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; sym
;The variable SYM is unbound.
;   [Condition of type UNBOUND-VARIABLE]
; Evaluation aborted on #&lt;UNBOUND-VARIABLE SYM {1001CD0463}&gt;.  
</pre>
</div>


<p>
Why did this happen? Because the <code>sym</code> we set to 99 above is a distinct symbol from <code>sym</code> here in <code>mine</code>. To refer to the original <code>sym</code> from outside the user <a href="#org82bfe8d">package</a>, we must prefix the <a href="#org82bfe8d">package</a> name and two colons:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">MINE&gt; common-lisp-user::sym
99  
</pre>
</div>



<p>
So different symbols with the same print-name can coexist in different <a href="#org1f75805">packages</a>. There can be one <code>sym</code> in <a href="#org82bfe8d">package</a> <code>common-lisp-user</code> and another <code>sym</code> in <a href="#org82bfe8d">package</a> <code>mine</code>, and they will be distinct symbols. That's the point of <a href="#org1f75805">packages</a>. If you're writing your program in a separate <a href="#org82bfe8d">package</a>, you can choose names for your functions and variables without worrying that someone will use the same name for something else. Even if they use the same name, it won't be the same symbol.<br />
</p>



<p>
It's usually bad style to use <a href="#org82bfe8d">package</a> prefixes with double colons. By doing so you are violating the modularity that <a href="#org1f75805">packages</a> are supposed to provide. If you have to use a double colon to refer to a symbol, it's because someone didn't want you to.<br />
</p>


<p>
Usually one should only refer to symbols that have been exported. If we go back to the user <a href="#org82bfe8d">package</a> and export a symbol interned there,<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">MINE&gt; (in-package common-lisp-user)
#&lt;PACKAGE "COMMON-LISP-USER"&gt;
CL-USER&gt; (export 'bar)
T
CL-USER&gt; (setf bar 5)
5  
</pre>
</div>
<p>
we cause it to be visible to other <a href="#org1f75805">packages</a>. Now when we return to <code>mine</code>, we can refer to <code>bar</code> with only a single colon, because it is a publicly available name:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (in-package mine)
#&lt;PACKAGE "MINE"&gt;
MINE&gt; common-lisp-user:bar
5  
</pre>
</div>


<p>
By importing <code>bar</code> into <code>mine</code>, we can go one step further and make <code>mine</code> actually share the symbol <code>bar</code> with the user <a href="#org82bfe8d">package</a>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">MINE&gt; (import 'common-lisp-user:bar)
T
MINE&gt; bar
5  
</pre>
</div>


<p>
After importing <code>bar</code> we can refer to it without any <a href="#org82bfe8d">package</a> qualifier at all. The two <a href="#org1f75805">packages</a> now share the same symbol; there can't be a distinct mine: bar.<br />
</p>


<p>
What if there already was one? In that case, the call to <code>import</code> would have caused an error, as we see if we try to import <code>sym</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">MINE&gt; (import 'common-lisp-user::sym)
; IMPORT COMMON-LISP-USER::SYM causes name-conflicts in
; #&lt;PACKAGE "MINE"&gt; between the following symbols:
;   COMMON-LISP-USER::SYM, MINE::SYM
;    [Condition of type SB-EXT:NAME-CONFLICT]
; See also:
;   Common Lisp Hyperspec, 11.1.1.2.5 [:section]

; Evaluation aborted on #&lt;NAME-CONFLICT {1002B83C83}&gt;.    
</pre>
</div>



<p>
Before, when we tried unsuccessfully to evaluate <code>sym</code> in <code>mine</code>, we thereby caused a symbol <code>sym</code> to be interned there. It had no value and therefore generated an error, but the interning happened simply as a consequence of typing its name. So now when we try to import <code>sym</code> into <code>mine</code>, there is already a symbol there with the same name.<br />
</p>



<p>
Another way to get access to symbols from another <a href="#org82bfe8d">package</a> is to use it:<br />
</p>

<div class="org-src-container">
<pre class="src src-lisp">MINE&gt; (use-package common-lisp-user)
T
</pre>
</div>

<p>
Now all symbols exported by the user <a href="#org82bfe8d">package</a> can be used without any qualifier in mine. (If sym had been exported by the user <a href="#org82bfe8d">package</a>, this call would also have generated an error.)<br />
</p>




<p>
The <a href="#org82bfe8d">package</a> containing the names of built-in operators and variables is called <code>common-lisp</code>. Since we gave the name of this <a href="#org82bfe8d">package</a> in the <code>:use</code> argument of the <code>make-package</code> that created <code>mine</code>, all of Common Lisp's names will be visible here:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">MINE&gt; #'cons
#&lt;FUNCTION CONS&gt;  
</pre>
</div>


<p>
Operations on <a href="#org1f75805">packages</a> are not usually done at the <a href="#org4641b96">toplevel</a> like this. More often the calls are contained in source files. Generally it will suffice to begin a file with a <code>defpackage</code> and an <code>in-package</code>.<br />
</p>
</div>
</div>






<div id="outline-container-org57f435a" class="outline-3">
<h3 id="org57f435a"><span class="section-number-3">15.5.</span> <a href="#org36dd4bd">Conditions</a></h3>
<div class="outline-text-3" id="text-15-5">
<p>
In Common Lisp, <a id="org36dd4bd">conditions</a> include errors and other situations that can arise at run-time. When a condition is signalled, the corresponding handler is invoked. The default handler for error <a href="#org36dd4bd">conditions</a> usually invokes a break-loop. But Common Lisp provides a variety of operators for signalling and handling <a href="#org36dd4bd">conditions</a>. It's possible to override the default handlers, oven wrtie new handlers of your own.<br />
</p>



<p>
Most programmers will not deal with <a href="#org36dd4bd">conditions</a> directly. However, there are several layers of more abstract operators that use <a href="#org36dd4bd">conditions</a>, and to understand these operators it helps to know about the underlying mechanism.<br />
</p>



<p>
Common Lisp has several operators for signalling errors. The most basic is <code>error</code>. One way to call it is to give it the same arguments that you might pass to <code>format</code>:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (error "Your report uses ~A as a verb." 'status)
; Evaluation aborted on #&lt;SIMPLE-ERROR "Your report uses ~A as a verb." {1001B241D3}&gt;.

Your report uses STATUS as a verb.
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [RETRY] Retry SLIME REPL evaluation request.
 1: [*ABORT] Return to SLIME's top level.
 2: [ABORT] abort thread (#&lt;THREAD "new-repl-thread" RUNNING {10043D0503}&gt;)

Backtrace:
  0: (SB-INT:SIMPLE-EVAL-IN-LEXENV (ERROR "Your report uses ~A as a verb." (QUOTE STATUS)) #&lt;NULL-LEXENV&gt;)
  1: (EVAL (ERROR "Your report uses ~A as a verb." (QUOTE STATUS)))
 --more--

</pre>
</div>
<p>
Unless such a condition is handled, execution will be interrupted, as above.<br />
</p>




<p>
More abstract operators for signalling errors include <code>ecase</code>, <code>check-type</code> and <code>assert</code>.<br />
</p>


<p>
<code>ecase</code> is like <code>case</code>, but signals an error if none of the keys match:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (ecase 1 (2 3) (4 5))
; Evaluation aborted on #&lt;SB-KERNEL:CASE-FAILURE expected-type: (MEMBER 2 4) datum: 1&gt;.

1 fell through ECASE expression. Wanted one of (2 4).
   [Condition of type SB-KERNEL:CASE-FAILURE]

Restarts:
 0: [RETRY] Retry SLIME REPL evaluation request.
 1: [*ABORT] Return to SLIME's top level.
 2: [ABORT] abort thread (#&lt;THREAD "new-repl-thread" RUNNING {1001CD8743}&gt;)

Backtrace:
  0: ((LAMBDA ()))
  1: (SB-INT:SIMPLE-EVAL-IN-LEXENV (ECASE 1 (2 3) (4 5)) #&lt;NULL-LEXENV&gt;)
  2: (EVAL (ECASE 1 (2 3) (4 5)))
 --more--

</pre>
</div>

<p>
The regular <code>case</code> will return <code>nil</code> if no key matches, but since it's bad style to take advantage of this return value, you might as well use <code>ecase</code> whenever you don't have an <code>otherwise</code> clause.<br />
</p>



<p>
The <code>check-type</code> macro takes a place, a type name, and an optional string, and signals a <a id="orgfa72dc9">correctable error</a> if the value of the place is not of the designated type. The handler for a <a href="#orgfa72dc9">correctable error</a> will give us the option of providing a new value:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((x '(a b c)))
           (check-type (car x) integer "an integer")
           x)
Enter a form to be evaluated: 99


The value of (CAR X) is A, which is not an integer.
   [Condition of type SIMPLE-TYPE-ERROR]

Restarts:
 0: [STORE-VALUE] Supply a new value for (CAR X).
 1: [RETRY] Retry SLIME REPL evaluation request.
 2: [*ABORT] Return to SLIME's top level.
 3: [ABORT] abort thread (#&lt;THREAD "new-repl-thread" RUNNING {1003140AC3}&gt;)

Backtrace:
  0: (SB-KERNEL:CHECK-TYPE-ERROR (CAR X) A INTEGER "an integer")
  1: ((LAMBDA ()))
  2: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((X #)) (CHECK-TYPE (CAR X) INTEGER "an integer") X) #&lt;NULL-LEXENV&gt;)
  3: (EVAL (LET ((X #)) (CHECK-TYPE (CAR X) INTEGER "an integer") X))
 --more--

</pre>
</div>

<p>
In this example, <code>(car x)</code> was set to the new value that we supplied, and the execution resumed, returning what it would have returned if <code>(car x)</code> had originally contained the value we supplied.<br />
</p>



<p>
<code>check-type</code> is defined in terms of the more general <code>assert</code>, which takes a test expression and a <a href="#org1a9ed34">list</a> of one or more places, followed by the arguments you might give to error:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (let ((sandwich '(ham on rye)))
           (assert (eql (car sandwich) 'chicken)
                   ((car sandwich))
                   "I want a ~A sandwich." 'chicken)
           sandwich)



I want a CHICKEN sandwich.
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [CONTINUE] Retry assertion with new value for (CAR SANDWICH).
 1: [RETRY] Retry SLIME REPL evaluation request.
 2: [*ABORT] Return to SLIME's top level.
 3: [ABORT] abort thread (#&lt;THREAD "new-repl-thread" RUNNING {1004FB0003}&gt;)

Backtrace:
  0: (SB-KERNEL:ASSERT-ERROR (EQL (CAR SANDWICH) (QUOTE CHICKEN)) 1 (CAR SANDWICH) HAM ((CAR SANDWICH)) "I want a ~A sandwich." CHICKEN)
  1: ((LAMBDA ()))
  2: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((SANDWICH #)) (ASSERT (EQL # #) (#) "I want a ~A sandwich." (QUOTE CHICKEN)) SANDWICH) #&lt;NULL-LEXENV&gt;)
  3: (EVAL (LET ((SANDWICH #)) (ASSERT (EQL # #) (#) "I want a ~A sandwich." (QUOTE CHICKEN)) SANDWICH))
 --more--



</pre>
</div>




<p>
It's also possible to establish new handlers, but most programmers will only take advantage of this possibility indirectly, by using <a href="#orge6ba26a">macros</a> like <code>ignore-errors</code>. This macro behaves like <code>progn</code> if none of its arguments cause an error. But if an error is signalled during the evaluation of one of its arguments, execution will not be interrupted. Instead the <code>ignore-errors</code> expression will immediately return two values: <code>nil</code> and the condition that was signalled.<br />
</p>



<p>
For example, if at some point you want the user to be able to enter an expression, but you don't want an error to interrupt execution if the input is syntactically ill-formed, you could write:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">(defun user-input (prompt)
  (format t prompt)
  (let ((str (read-line)))
    (or (ignore-errors (read-from-string str))
        nil)))
</pre>
</div>


<p>
This function just return <code>nil</code> if the input contains syntax errors:<br />
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (user-input "Please type an expression&gt; ")
Please type an expression&gt; #123
NIL
CL-USER&gt; (user-input "Please type an expression&gt; ")
Please type an expression&gt; (+ 1 1)
(+ 1 1)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org73f3296" class="outline-2">
<h2 id="org73f3296"><span class="section-number-2">16.</span> NEEDLES</h2>
<div class="outline-text-2" id="text-16">
</div>
<div id="outline-container-orgd8c29ec" class="outline-3">
<h3 id="orgd8c29ec"><span class="section-number-3">16.1.</span> TO GET HELP INFORMATION</h3>
<div class="outline-text-3" id="text-16-1">
</div>
<div id="outline-container-orgb934ac6" class="outline-4">
<h4 id="orgb934ac6"><span class="section-number-4">16.1.1.</span> <code>documation</code></h4>
<div class="outline-text-4" id="text-16-1-1">
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (documentation '+ 'function)
"Return the sum of its arguments. With no args, returns 0."  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc146f85" class="outline-4">
<h4 id="orgc146f85"><span class="section-number-4">16.1.2.</span> <code>describe</code></h4>
<div class="outline-text-4" id="text-16-1-2">
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (describe '+)
COMMON-LISP:+
  [symbol]

+ names a special variable:
  Declared type: T
  Declared always-bound.
  Value: (DESCRIBE 'MAP)
  Documentation:
    the value of the most recent top level READ

+ names a compiled function:
  Lambda-list: (&amp;REST NUMBERS)
  Declared type: (FUNCTION (&amp;REST NUMBER) (VALUES NUMBER &amp;OPTIONAL))
  Derived type: (FUNCTION (&amp;REST T) (VALUES NUMBER &amp;OPTIONAL))
  Documentation:
    Return the sum of its arguments. With no args, returns 0.
  Known attributes: foldable, flushable, unsafely-flushable, movable, commutative
  Source file: SYS:SRC;CODE;NUMBERS.LISP
; No value
</pre>
</div>
</div>
</div>

<div id="outline-container-org34f9b36" class="outline-4">
<h4 id="org34f9b36"><span class="section-number-4">16.1.3.</span> <code>inspect</code></h4>
<div class="outline-text-4" id="text-16-1-3">
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (inspect '+)

The object is a SYMBOL.
0. Name: "+"
1. Package: #&lt;PACKAGE "COMMON-LISP"&gt;
2. Value: (DOCUMENTATION '+ 'FUNCTION)
3. Function: #&lt;FUNCTION +&gt;
4. Plist: NIL  
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org2badd12" class="outline-3">
<h3 id="org2badd12"><span class="section-number-3">16.2.</span> FUNCTION BOUND PREDICATE</h3>
<div class="outline-text-3" id="text-16-2">
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (fboundp '+)
#&lt;FUNCTION +&gt;  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce5282a" class="outline-3">
<h3 id="orgce5282a"><span class="section-number-3">16.3.</span> BOUND PREDICATE</h3>
<div class="outline-text-3" id="text-16-3">
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (boundp '+)
T
CL-USER&gt; (boundp *print-array*)
T  
</pre>
</div>
</div>
</div>

<div id="outline-container-org86fae85" class="outline-3">
<h3 id="org86fae85"><span class="section-number-3">16.4.</span> TYPE</h3>
<div class="outline-text-3" id="text-16-4">
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (typep 123 'number)
T  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (type-of 123)
(INTEGER 0 4611686018427387903)  
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mingming Li</p>
<p class="date">Created: 2024-03-13 Wed 09:54</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>