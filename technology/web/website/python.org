* TODO [#A] Develop a website that is relavant to my job
* Basic Application Structure
** A Complete Application
#+begin_src python
  from flask import
  Flask app = Flask(__name__)

  @app.route('/')
  def index():
      return '<h1>Hello World!</h1>'  
#+end_src

All Flask applications must create an application instance.
The web server passes all requests it receives from clients to this object for handling, using a protocol called Web Server Gateway Interface (WSGI).

Clients send requests to the web server, which in turn sends them to the Flask application instance.
The Flask application instance needs to know what code it needs to run for each URL requested, so it keeps a mapping of URLs to Python functions.
The association between a URL and the function that handles it is called a route.



** Development Web Server
Flask applications include a development web server.
It can be started with:
#+begin_src python
  python hello.py

  # or
  export FLASK_APP=hello.py
  flask run

  # or
  flask run --app=hello.py
#+end_src
** Dynamic Routes
Dynamic routes enable you to send dynamic data.
The data is passed to the handler function as a parameter or parameters.


#+begin_src python
  @app.route('/user/<name>')
  def user(name):
      return '<h1>Hello, {}!</h1>'.format(name)
#+end_src

The =name= is the dynamic data.
** Debug Mode
In this mode, two very convenient modules of the development server called the reloader and the debugger are enabled by default.
When the reloader is enabled, Flask watches all the source code files of your project and automatically restarts the server when any of the files are modified.

#+begin_src python
  export FLASK_DEBUG=1

  # or
  flask run --debug
#+end_src
** Command-Line Option

#+begin_src python
  flask --help
  flask run --help
#+end_src
* Templates
A template is a file that contains the text of a response, with placeholder variables for the dynamic parts that will be known only in the context of a request.
The process that replaces the variables with actual values and returns a final response string is called rendering.
For the task of rendering templates, Flask uses a powerful template engine called Jinja2.


#+name: templates/user.html: Jinja2 template
#+begin_src html
<h1>Hello, {{ name }}!</h1>
#+end_src

#+name: hello.py: rending a template
#+begin_src python
  from flask import Flask, render_template

  @app.route('/user/<name>')
  def user(name):
    return render_template('user.html', name=name)
#+end_src
** Variables
#+begin_src html
  <p>A value from a dictionary: {{ mydict['key'] }}.</p>
  <p>A value from a list: {{ mylist[3] }}.</p>
  <p>A value from a list, with a variable index: {{ mylist[myintvar] }}.</p>
  <p>A value from an object's method: {{ myobj.somemethod() }}.</p>

  <!-- filters -->
  Hello, {{ name|capitalize }}
#+end_src

#+name: Jinjia2 variable filters
| Filter name | Description                                                                      |
|-------------+----------------------------------------------------------------------------------|
| safe        | Renders the value without applying escaping                                      |
| capitalize  | Converts the first character of the value to uppercase and the rest to lowercase |
| lower       | Converts the value to lowercase characters                                       |
| upper       | Converts the value to uppercase characters                                       |
| title       | Capitalizes each word in the value                                               |
| trim        | Removes leading and trailing whitespace from the value                           |
| striptags   | Removes any HTML tags from the value before rendering                            |
** Control Structure
#+begin_src html
<!-- if -->
{% if user %}
    Hello, {{ user }}!
{% else %}
    Hello, Stranger!
{% endif %}

<!-- for loop -->
<ul>
    {% for comment in comments %}
        <li>{{ comment }}</li>
    {% endfor %}
</ul>

<!-- macro -->
{% macro render_comment(comment) %}
    <li>{{ comment }}</li>
{% endmacro %}
<ul>
    {% for comment in comments %}
        {{ render_comment(comment) }}
    {% endfor %}
</ul>
#+end_src
** Blocks

Blocks enable you inherite and overide the content you want.
Base templates define blocks that can be overriden by derived templates.

For example:
#+name: base.html
#+begin_src html
<html>
<head>
    {% block head %}
        <title>{% block title %}{% endblock %} - My Application</title> 
    {% endblock %}
</head>
<body>
{% block body %}
{% endblock %}
</body>
</html>
#+end_src

#+begin_src html
{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    <style>
    </style>
{% endblock %}
{% block body %}
    <h1>Hello, World!</h1>
{% endblock %}
#+end_src
** Custom Error Pages
#+begin_src python
from flask import render_template

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404


@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500  
#+end_src
** Links
Flask provides the =url_for()= helper function, which generates URLs from the information stored in the applicationâ€™s URL map.
In its simplest usage, this function takes the view function name as its single argument and returns its URL.
#+begin_src python
  url_for('index')                
#+end_src

Dynamic URLs can be generated with =url_for()= by passing the dynamic parts as keyword arguments.
#+begin_src python
  url_for('user', name='aike', _external=True)
#+end_src

Keyword arguments sent to =url_for()= are not limited to arguments used by dynamic routes.
The function will add any arguments that are not dynamic to the query string.

#+begin_src python
  url_for('user', name='aike', page=2, version=1)
#+end_src

For static files:
#+begin_src python
  <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">  
#+end_src



* Extensions
** flask-bootstrap
Bootstrap provides lots of web page examples.
This save you time for develop the web pages from the start.



** flask-moment
** flask-wtf
** flask-sqlalchemy
** flask-migrate
** flask-mail
