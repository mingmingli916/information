
\chapter{Lisp Data Types}
\label{cha:lisp-data-types}

A Lisp \keyword{object} is a piece of data used and manipulated by Lisp programs.
A \keyword{type} or \keyword{data type} is a set of possible objects.

Every object belongs to at least one type.
Objects of the same type have similar structures and may usually be used in the same contexts.
Types can overlap, and objects can belong to two or more types.
Consequently, we can ask whether an object belongs to a particular type, but not for the type of an object.
(This may differ from other programming language)


A few fundamental object types are built into Emacs.
These, from which all other types are constructed, are called \keyword{primitive types}.
Each object belongs to \keyword{one and only one} primitive type.
These types include \keyword{integer, float, cons, symbol, string, vector, hash-table, subr, byte-code function}, and \keyword{record}, plus several special types, such as \keyword{buffer}, that are related to editing.

Each primitive type has a corresponding Lisp function that checks whether an object is a member of that type.

Lisp is unlike many other languages in that its objects are \keyword{self-typing}: the primitive type of each object is \keyword{implicit} in the object itself.
For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.


In most languages (like Java), the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data.
Such type declarations do not exist in Emacs Lisp.
A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. 

\section{Printed Representation and Read Syntax}
\label{sec:print-repr-read}

The \keyword{printed representation} of an object is the format of the output generated by the Lisp printer (the function \keyword{prin1}) for that object.
Every data type has a \keyword{unique} printed representation.
The \keyword{read syntax} of an object is the format of the input accepted by the Lisp reader (the function \keyword{read}) for that object.
This is not necessarily unique; many kinds of object have more than one syntax.

In most cases, an object’s printed representation is also a read syntax for the object.

In other languages, an expression is text; it has no other form.
In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object’s read syntax.


\section{Special Read Syntax}
\label{sec:special-read-syntax}

Emacs Lisp represents many special objects and constructs via special hash notations.
\begin{itemize}
\item \keyword{\#<...>} \\
  Objects that have no read syntax are presented like this.
\item \keyword{\#\#}\\
  The printed representation of an interned symbol whose name is an empty string.
\item \keyword{\#\('\)}\\
  This is a shortcut for \keyword{function}.
\item \keyword{\#:}\\
  The printed representation of an uninterned symbol whose name is \argument{foo} is \argument{\#:foo}.
\item \keyword{\#N}\\
  When printing circular structures, this construct is used to represent where the structure loops back onto itself, and ‘N’ is the starting list count:
\begin{lstlisting}
(let ((a (list 1)))
  (setcdr a a))
;; => (1 . #0)
\end{lstlisting}
\item \keyword{\#N=}
\item \keyword{\#N\#}\\
  \keyword{\#N=} gives the name to an object and \keyword{\#N\#} represents that object, so when reading back the object, they will be the same object instead of copies.
\item \keyword{\#xN}\\
  `n' represented as a hexadecimal number (\argument{\#x2a}).
\item \keyword{\#oN}\\
  `N' represented as an octal number (\argument{\#o52}).
\item \keyword{\#bN}\\
  `N' represented as a binary number (\argument{\#b101010}).
\item \keyword{\#(...)}\\
  String text properties.
\item \keyword{\#\textasciicircum{}}\\
  A char table.
\item \keyword{\#s(hash-table ...)}\\
  A hash table.
\item \keyword{?C}\\
  A character.
\item \keyword{\#\$}\\
  The current file name in byte-compiled files.
\item \keyword{\#@N}\\
  Skip the next ‘N’ characters.
\item \keyword{\#f} \\
  Indicates that the following form isn’t readable by the Emacs Lisp reader. This is only in text for display purposes and will never appear in any Lisp file.
\end{itemize}


\section{Comments}
\label{sec:comments}

A \keyword{comment} is text that is written in a program only for the sake of humans that read the program, and that has no effect on the meaning of the program.
In Lisp, an unescaped semicolon (\keyword{;}) starts a comment if it is not within a string or character constant.
The comment continues to the end of line.




\section{Programming Types}
\label{sec:programming-types}

There are two general categories of types in Emacs Lisp:
\begin{itemize}
\item those having to do with Lisp programming. (exist in many Lisp implementation.)
\item those having to do with editing. (unique to Emacs Lisp.)
\end{itemize}

Type in Emacs Lisp is like class in structure in C, class in Java and Python.



\subsection{Integer Type}
\label{sec:integer-type}

There are two kinds of integers:
\begin{itemize}
\item small integers, called \keyword{fixnums}
\item large integers, called \keyword{bignums}.
\end{itemize}


The range of values for a fixnum depends on the machine.
The minimum range is \(-2^{29}\) to \(2^{29}-1\) but many machines provide a wider range.
Bignums can have arbitrary precision.
Operations that overflow a fixnum will return a bignum instead.


All numbers can be compared with \argument{eql} or \argument{=}; fixnums can also be compared with \argument{eq}.
To test whether an integer is a fixnum or a bignum, you can use predicates \argument{fixnump} and \argument{bignump}.


The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end.
The printed representation produced by the Lisp interpreter never has a leading ‘+’ or a final ‘.’.

\begin{lstlisting}
-1   ; -1
1    ; 1
1.   ; 1
+1   ; 1
\end{lstlisting}


\subsection{Floating-Point Type}
\label{sec:floating-point-type}

Emacs uses the C data type \argument{double} to store the floating-point value.

The printed representation for floating-point numbers requires either a decimal point (with at least one digit following), an exponent, or both.
\begin{lstlisting}
;; 1500
1500.0
+15e2
15.0e+2
+1500000e-3
.15e4
\end{lstlisting}

\subsection{Character Type}
\label{sec:character-type}

A character in Emacs Lisp is nothing more than an integer.
In other words, characters are represented by their character codes.
For example, the character A is represented as the integer 65.


\subsubsection{Basic Char Syntax}
\label{sec:basic-char-syntax}

Since characters are really integers, the printed representation of a character is a decimal number.
This is also a possible read syntax for a character, but writing characters that way in Lisp programs is not clear programming.
You should \keyword{always} use the special read syntax formats that Emacs Lisp provides for characters.
These syntax formats start with a question mark.


The usual read syntax for alphanumeric characters is a question mark followed by the character; thus, ‘?A’ for the character A, ‘?B’ for the character B, and ‘?a’ for the character a.
\begin{lstlisting}
?A                                      ; 65
?B                                      ; 66
?a                                      ; 97
\end{lstlisting}


You can use the same syntax for punctuation characters.
However, if the punctuation character has a special syntactic meaning in Lisp, you must quote it with a ‘\textbackslash{}’.
For example, ‘\lstinline|?\(|’ is the way to write the open-paren character.
Likewise, if the character is ‘\textbackslash’, you must use a second ‘\textbackslash’ to quote it: ‘?\textbackslash\textbackslash’.

\begin{lstlisting}

?\a                                     ; control-g
?\b                                     ; backspace, BS
?\t                                     ; tab, TAB
?\n                                     ; newline
?\\                                     ; backslash character, \
?\d                                     ; delete character, DEL
?\e                                     ; escape character, ESC
?\r                                     ; carriage return, RET

\end{lstlisting}

These sequences which start with backslash are also known as \keyword{escape sequences}, because backslash plays the role of an escape character.
A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, ‘?\textbackslash{}+’ is equivalent to ‘?+’.



\subsubsection{General Escape Syntax}
\label{sec:gener-escape-synt}

In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-ASCII text characters.
\begin{itemize}
\item You can specify characters by their Unicode names, if any.
  ?\textbackslash{}\{NAME\} represents the Unicode character named NAME.
  \lstinline|?\N{LATIN SMALL LETTER A WITH GRAVE}|.
\item You can specify characters by their Unicode values.
  \lstinline|?\N{U+X}| represents a character with Unicode code point X, where X is a hexadecimal number.
  \lstinline|?\N{U+E0}|.
\item You can specify characters by their hexadecimal character codes.
  A hexadecimal escape sequence consists of a backslash, ‘x’, and the hexadecimal character code.
  \lstinline|?\x41|.
\item You can specify characters by their character code in octal.
  An octal escape sequence consists of a backslash followed by up to three octal digits.
  \lstinline|?\101|.
\end{itemize}



\subsubsection{Control-Character Syntax}
\label{sec:contr-char-synt}


Control characters can be represented using yet another read syntax.
This consists of a question mark (\keyword{?}) followed by a backslash (\keyword{\textbackslash{}}), caret (\keyword{\textasciicircum{}}), and the corresponding non-control character, in either upper or lower case.
Instead of the \keyword{\textasciicircum{}}, you can use \keyword{C-}.
\begin{lstlisting}
?\^I                                    ; C-i
?\^i                                    ; C-i
?\C-I                                   ; C-i
?\C-i                                   ; C-i
\end{lstlisting}


\subsubsection{Meta-Character Syntax}
\label{sec:meta-char-synt}

A \keyword{meta} character is a character typed with the META modifier key.
The read syntax for meta characters uses \keyword{\textbackslash{}M-}.
\begin{lstlisting}
?\M-A                                   ; M-A
?\M-\C-b                                ; C-M-b
?\C-\M-b                                ; C-M-b

\end{lstlisting}


\subsubsection{Other Character Modifier Bits}
\label{sec:other-char-modif}

The case of a graphic character is indicated by its character code; for example, ASCII distinguishes between the characters ‘a’ and ‘A’.
But ASCII has no way to represent whether a control character is upper case or lower case.
Emacs uses the 25th bit (\(2^{25}\)) to indicate that the shift key was used in typing a control character.
This distinction is possible only on a graphical display such as a GUI display on X; text terminals do not report the distinction.
The X Window System defines three other modifier bits that can be set in a character: hyper, super and alt.
The bit values are 22th (\(2^{22}\)) for alt, 23th \(2^{23}\) for super and 24th \(2^{24}\) for hyper.

\begin{lstlisting}
\S-                                     ; shift
\H-                                     ; hyper
\s-                                     ; super
\A-                                     ; alt
\end{lstlisting}

\subsection{Symbol Type}
\label{sec:symbol-type}

A \keyword{symbol} in GNU Emacs Lisp is an object with a name.
The symbol name serves as the printed representation of the symbol.
In ordinary Lisp use, with one single obarray, a symbol’s name is unique -{}-no two symbols have the same name.


A symbol can serve as a variable, as a function name, or to hold a property list.
Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably.
In a given context, usually only one of these uses is intended.
But you can use one symbol in all of these ways, independently.


A symbol whose name starts with a colon (‘:’) is called a keyword symbol.
These symbols automatically act as constants, and are normally used only by comparing an unknown symbol with a few specific alternatives.

A symbol name can contain any characters whatever.
If a symbol name looks like a number, you need to write a ``\textbackslash{}'' at the beginning of the name to force interpretation as a symbol.
The characters \lstinline|-+=*/_~!@$%^&:<>{}?| requires no special punctuation.
Any other characters my be included in a symbol's name by escaping them with a backslash.
In contract to its use in string, a backslash in the name of a symbol simply quotes the single character that follows the backslash.
For example, in a string, ‘\textbackslash{}t’ represents a tab character; in the name of a symbol, however, ‘\textbackslash{}t’ merely quotes the letter ‘t’.
To have a symbol with a tab character in its name, you must actually use a tab (preceded with a backslash).
But it’s rare to do such a thing.

\begin{lstlisting}
foo                                     ; A symbol named 'foo'
FOO                                     ; A symbol named 'FOO'
1+                                      ; A symbol named '1+'
\+1                                     ; A symbol named '+1'
+-*/_~!@$%^&=:<>{}                      ; A symbol named '+-*/_~!@$%^&=:<>{}'

\end{lstlisting}


As an exception to the rule that a symbol’s name serves as its printed representation, ‘\#\#’ is the printed representation for an interned symbol whose name is an empty string.
Furthermore, ‘\#:foo’ is the printed representation for an uninterned symbol whose name is foo.

\subsection{Sequence Types}
\label{sec:sequence-types}


A \keyword{sequence} is a Lisp object that represents an ordered set of elements.
There are two kinds of sequence in Emacs Lisp: lists and arrays.


A list can hold elements of any type, and its length can be easily changed by adding or removing elements.

Arrays are fixed-length sequences.
They are further subdivided into:
\begin{itemize}
\item strings\\
   Elements can only be characters.
\item vectors \\
  Elements can by any types.
\item char-tables\\
  Like vectors except that they are indexed by any valid character code.
\item bool-vectors\\
  Elements must be \argument{t} or \argument{nil}.  
\end{itemize}

It is generally impossible to read the same sequence twice, since sequences are always created a new upon reading.
If you read the read syntax for a sequence twice, you get two sequences with equal contents.
There is one exception: the empty list () always stands for the same object, \argument{nil}.


\subsection{Cons Cell and List Types}
\label{sec:cons-cell-list}

A \keyword{cons cell} is an object that consists of two slots, called the \keyword{car} slot and the \keyword{cdr} slot.
Each slot can hold any Lisp object. 

A list is a series of cons cells, linked together so that the cdr slot of each cons cell holds either the next cons cell or the empty list.
The empty list is actually the symbol nil.
Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a \keyword{list structure}.


Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell.
These objects are called \keyword{atoms}.

The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis.
\begin{lstlisting}
(A 2 "A")            ; A list of three elements.                      
()                   ; A list of no elements (the empty list).        
nil                  ; A list of no elements (the empty list).        
("A ()")             ; A list of one element: the string "A ()".      
(A ())               ; A list of two elements: A and the empty list.  
(A nil)              ; Equivalent to the previous.                    
((A B C))            ; A list of one element (which is a list of three elements).           
\end{lstlisting}

Upon reading, each object inside the parentheses becomes an element of the list.
That is, a cons cell is made for each element.
The car slot of the cons cell holds the element, and its cdr slot refers to the next cons cell of the list, which holds the next element in the list.
The cdr slot of the last cons cell is set to hold \argument{nil}.


The names car and cdr derive from the history of Lisp.
The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; car was an instruction to extract the contents of the address part of a register, and cdr an instruction to extract the contents of the decrement.
By contrast, cons cells are named for the function \keyword{cons} that creates them, which in turn was named for its purpose, the construction of cells.




\subsubsection{Dotted Pair Notation}
\label{sec:dotted-pair-notation}

\keyword{Dotted pair notation} is a general syntax for cons cells that represents the car and cdr explicitly.
In this syntax, \lstinline|(a . b)| stands for a cons cell whose car is the object \argument{a} and whose cdr is the object \argument{b}.
It has the advantage that the cdr does not have to be a list.
However, it is more cumbersome in cases where list syntax would work.
In dotted pair notation, the list \lstinline|(1 2 3)| is written as \lstinline|(1 . (2 . (3 . nil)))|.
When printing a list, the dotted pair notation is only used if the cdr of a cons cell is not a list.


\subsubsection{Association List Type}
\label{sec:assoc-list-type}


An \keyword{association list} or \keyword{alist} is a specially-constructed list whose elements are cons cells.
In each element, the car is considered a \keyword{key}, and the cdr is considered an \keyword{associated value}.
\begin{lstlisting}
(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
\end{lstlisting}

\subsection{Array Type}
\label{sec:array-type}

An \keyword{array} is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory.
(like array in data structure)

\subsection{String Type}
\label{sec:string-type}

Strings in Lisp are constants: evaluation of a string returns the same string.


\subsubsection{Syntax for Strings}
\label{sec:syntax-strings}


The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote (\lstinline|"like this."|).
To include a double-quote in a string, precede it with a backslash (\lstinline|"\""|).
Likewise, you can include a backslash by preceding it with another backslash (\lstinline|"\\"|).


The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string.
But an escaped newline — one that is preceded by ‘\textbackslash{}’—does not become part of the string; i.e., the Lisp reader ignores an escaped newline while reading a string.
An escaped space ‘\textbackslash{} ’ is likewise ignored.


\subsubsection{Non-ASCII Characters in Strings}
\label{sec:non-ascii-characters}

There are two text representations for non-ASCII characters in Emacs strings:
\begin{itemize}
\item multibyte\\
  Its value maybe between 0 and 4194303 (\(2^{22}-1\)).
  It store raw bytes.
\item unibyte\\
  Its value is between 0 and 255 (\(2^{8}-1\)).
  It store human-readable text.
\end{itemize}
In both cases, characters above 127 are non-ASCII.

You can include a non-ASCII character in a string constant by writing it literally.
Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. 

\subsubsection{Nonprinting Characters in Strings}
\label{sec:nonpr-char-strings}

You can use the same backslash escape-sequences in a string constant as in character literals (but do not use the question mark that begins a character constant).
\begin{lstlisting}
"\t"                                    ; tab
"\C-a"                                  ; C-a
\end{lstlisting}

However, not all of the characters you can write with backslash escape-sequences are valid in strings.
The only control characters that a string can hold are the ASCII control characters.
Strings do not distinguish case in ASCII control characters.

Properly speaking, strings cannot hold meta characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of ASCII characters in a string.
If you use the ‘\textbackslash{}M-’ syntax to indicate a meta character in a string constant, this sets the \(2^{7}\) bit of the character in the string.
If the string is used in \argument{define-key} or \argument{lookup-key}, this numeric code is translated into the equivalent meta character.

Strings cannot hold characters that have the hyper, super, or alt modifiers.

\subsubsection{Text Properties in Strings}
\label{sec:text-prop-strings}

A string can hold properties for the characters it contains, in addition to the characters themselves.
This enables programs that copy text between strings and buffers to copy the text’s properties with no special effort.
Strings with text properties use a special read and print syntax:
\begin{lstlisting}
#("characters" property-data...)
\end{lstlisting}
where \argument{property-data} consists of zero or more elements, in groups of three as follows:
\begin{lstlisting}
beg end plist
\end{lstlisting}
The elements \argument{beg} and \argument{end} are integers, and together specify a range of indices in the string; \argument{plist} is the property list for that range.
For example:
\begin{lstlisting}
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
\end{lstlisting}


\subsection{Vector Type}
\label{sec:vector-type}

The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket.
This is also the read syntax.
Like numbers and strings, vectors are considered constants for evaluation.


\begin{lstlisting}
[1 "two" (three)]                       ; A vector of three elements.
\end{lstlisting}

\subsection{Char-Table Type}
\label{sec:char-table-type}

Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes — for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes.
A char-table can also specify a single value for a whole character set.

The printed representation of a char-table is like a vector except that there is an extra \keyword{\#\textasciicircum{}} at the beginning.


\subsection{Bool-Vector Type}
\label{sec:bool-vector-type}

The printed representation of a bool-vector is like a string, except that it begins with \keyword{\#\&} followed by the length.
The string constant that follows actually specifies the contents of the bool-vector as a bitmap—each character in the string contains 8 bits, which specify the next 8 elements of the bool-vector (1 stands for t, and 0 for nil).
The least significant bits of the character correspond to the lowest indices in the bool-vector.
\begin{lstlisting}
(make-bool-vector 3 t)                  ; #&3"^G"
(make-bool-vector 3 nil)                ; #&3"^@"
\end{lstlisting}
These results make sense, because the binary code for ‘C-g’ is 111 and ‘C-@’ is the character with code 0.


If the length is not a multiple of 8, the printed representation shows extra elements, but these extras really make no difference.
For instance, in the next example, the two bool-vectors are equal, because only the first 3 bits are used:
\begin{lstlisting}
(equal #&3"\377" #&3"\007")             ; t
\end{lstlisting}


\subsection{Hash Table Type}
\label{sec:hash-table-type}

The printed representation of a hash table specifies its properties and contents, like this:
\begin{lstlisting}
(make-hash-table)
;; #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data ( ...))
\end{lstlisting}

\subsection{Function Type}
\label{sec:function-type}

Lisp functions are executable code.
Functions are also Lisp objects.
A non-compiled function is a lambda expression: that is, a list whose first element is the symbol \argument{lambda}.

In Lisp, a function has no intrinsic name.
A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an \keyword{anonymous function}.
A named function in Lisp is just a symbol with a valid function in its function cell.

Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs.
However, you can construct or obtain a function object at run time and then call it with the primitive functions \argument{funcall} and \argument{apply}.

\subsection{Macro Type}
\label{sec:macro-type}


A \keyword{Lisp macro} is a user-defined construct that extends the Lisp language.
It is represented as an object much like a function, but with different argument-passing semantics.
A Lisp macro has the form of a list whose first element is the symbol \argument{macro} and whose cdr is a Lisp function object, including the \argument{lambda} symbol.


Lisp macro objects are usually defined with the built-in \argument{defmacro} macro, but any list that begins with \argument{macro} is a macro as far as Emacs is concerned.




\subsection{Primitive Function Type}
\label{sec:prim-funct-type}

A \keyword{primitive function} is a function callable from Lisp but written in the C programming language.
Primitive functions are also called \keyword{subrs} or \keyword{built-in functions}.
(The word “subr” is derived from “subroutine”.)
Most primitive functions evaluate all their arguments when they are called.
A primitive function that does not evaluate all its arguments is called a \keyword{special form}.


Primitive functions have no read syntax and print in hash notation with the name of the subroutine.
\begin{lstlisting}
;; symbol-function: access the function cell of the symbol
(symbol-function 'car)                  ; #<subr car>
;; To check if it is a primitive function.
(subrp (symbol-function 'car))          ; t
\end{lstlisting}

\subsection{Byte-Code Function Type}
\label{sec:byte-code-function}

\keyword{Byte-code function objects} are produced by byte-compiling Lisp code.
Internally, a byte-code function object is much like a vector; however, the evaluator handles this data type specially when it appears in a function call.
The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional \argument{\#} before the opening \argument{[} (i.e. start with \argument{\#[}).


\subsection{Record Type}
\label{sec:record-type}

A \keyword{record} is much like a \argument{vector}.
However, the first element is used to hold its type as returned by \argument{type-of}.
The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.


\subsection{Type Descriptors}
\label{sec:type-descriptors}

A \keyword{type descriptor} is a \argument{record} which holds information about a type.
Slot 1 in the record must be a symbol naming the type, and \argument{type-of} relies on this to return the type of \argument{record} objects.
No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.


\subsection{Autoload Type}
\label{sec:autoload-type}

An \keyword{autoload object} is a list whose first element is the symbol \argument{autoload}.
It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition.
The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary.
It contains the name of the file, plus some other information about the real definition.


After the file has been loaded, the symbol should have a new function definition that is not an autoload object.
The new definition is then called as if it had been there to begin with.
From the user’s point of view, the function call works as expected, using the function definition in the loaded file.


\subsection{Finalizer Type}
\label{sec:finalizer-type}

A \keyword{finalizer object} helps Lisp code clean up after objects that are no longer needed.
A finalizer holds a Lisp function object.
When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer’s associated function object.
When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves.


Errors in finalizers are printed to \argument{*Messages*}.
Emacs runs a given finalizer object’s associated function exactly once, even if that function fails.


\begin{lstlisting}
(make-finalizer function)
\end{lstlisting}
Make a finalizer that will run \argument{function}.
\argument{function} will be called after garbage collection when the returned finalizer object becomes unreachable.
If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run \argument{function}.
\argument{function} will be run once per finalizer object.



\section{Editing Types}
\label{sec:editing-types}

\subsection{Buffer Type}
\label{sec:buffer-type}

A \keyword{buffer} is an object that holds text that can be edited.
Most buffers hold the contents of a disk file so they can be edited, but some are used for other purposes (like *scratch* buffer).
Most buffers are also meant to be seen by the user, and therefore displayed, at some time, in a window.
But a buffer need not be displayed in any window.
Each buffer has a designated position called point; most editing commands act on the contents of the current buffer in the neighborhood of point.
At any time, one buffer is the \keyword{current buffer}.


Many of the standard Emacs functions manipulate or test the characters in the current buffer.
Several other data structures are associated with each buffer:
\begin{itemize}
\item a local syntax table
\item a local keymap
\item a list of buffer-local variable bindings
\item overlays
\item text properties for the text in the buffer
\end{itemize}

The local keymap and variable list contain entries that individually override global bindings or values.
These are used to customize the behavior of programs in different buffers, without actually changing the programs.

Buffers have no read syntax.
They print in hash notation, showing the buffer name.
\begin{lstlisting}
(current-buffer)                        ; #<buffer *scratch*>
\end{lstlisting}


A \keyword{marker} denotes a position in a specific buffer.
Markers therefore have two components: one for the buffer, and one for the position.
Changes in the buffer’s text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.


Markers have no read syntax.
They print in hash notation, giving the current character position and the name of the buffer.
\begin{lstlisting}
(point-marker)                          ; #<marker at 3035 in *scratch*>
\end{lstlisting}

\subsection{Window Type}
\label{sec:window-type}

A \keyword{window} describes the portion of the screen that Emacs uses to display buffers.
Every live window has one associated buffer, whose contents appear in that window.
By contrast, a given buffer may appear in one window, no window, or several windows.
Windows are grouped on the screen into \keyword{frames}; each window belongs to one and only one frame.


Though many windows may exist simultaneously, at any time one window is designated the selected window.
This is the window where the cursor is (usually) displayed when Emacs is ready for a command.
The selected window usually displays the current buffer, but this is not necessarily the case.


Windows have no read syntax.
They print in hash notation, giving the window number and the name of the buffer being displayed.
The window numbers exist to identify windows uniquely, since the buffer displayed in any given window can change frequently.
\begin{lstlisting}
(selected-window)                       ; #<window 3 on *scratch*>
\end{lstlisting}


\subsection{Frame Type}
\label{sec:frame-type}

A \keyword{frame} is a screen area that contains one or more Emacs windows; we also use the term \keyword{frame} to refer to the Lisp object that Emacs uses to refer to the screen area.


Frames have no read syntax.
They print in hash notation, giving the frame’s title, plus its address in core (useful to identify the frame uniquely).
\begin{lstlisting}
(selected-frame)                        ; #<frame *scratch* 0x7fdcdc0e2630>
\end{lstlisting}

\subsection{Termial Type}
\label{sec:termial-type}

A \keyword{terminal} is a device capable of displaying one or more Emacs frames.

Terminals have no read syntax.
They print in hash notation giving the terminal’s ordinal number and its TTY device file name.
\begin{lstlisting}
;; on my macbook
(get-device-terminal nil)               ; #<terminal 1 on Mingmings-MacBook-Pro.local>

;; on linux
(get-device-terminal nil)               ; #<terminal 1 on /dev/tty>
\end{lstlisting}

\subsection{Window Configuration Type}
\label{sec:wind-conf-type}

A \keyword{window configuration} stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.

Window configurations do not have a read syntax; their print syntax looks like \argument{\#<window-configuration>}.


\subsection{Frame Configuration Type}
\label{sec:frame-conf-type}

A \keyword{frame configuration} stores information about the positions, sizes, and contents of the windows in all frames.
It is not a primitive type.
It is actually a list whose car is \argument{frame-configuration} and whose cdr is an alist.
Each alist element describes one frame, which appears as the car of that element.


\subsection{Process Type}
\label{sec:process-type}

The word \keyword{process} usually means a running program.
Emacs itself runs in a process of this sort.
However, in Emacs Lisp, a process is a Lisp object that designates a subprocess created by the Emacs process.
Programs such as shells, GDB, ftp, and compilers, running in subprocesses of Emacs, extend the capabilities of Emacs.
An Emacs subprocess takes textual input from Emacs and returns textual output to Emacs for further manipulation.
Emacs can also send signals to the subprocess.


Process objects have no read syntax.
They print in hash notation, giving the name of the process:
\begin{lstlisting}
(process-list)                          ; (#<process shell> #<process server> #<process ispell>)
\end{lstlisting}


\subsection{Thread Type}
\label{sec:thread-type}

A \keyword{thread} in Emacs represents a separate thread of Emacs Lisp execution.
It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept.

Thread objects have no read syntax.
They print in hash notation, giving the name of the thread (if it has been given a name) or its address in core:
\begin{lstlisting}
(all-threads)                           ; (#<thread 0x10b588b80>)
\end{lstlisting}


\subsection{Mutex Type}
\label{sec:mutex-type}

A \keyword{mutex} is an exclusive lock that threads can own and disown, in order to synchronize between them.

Mutex objects have no read syntax.
They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:
\begin{lstlisting}
(make-mutex "my-mutex")                 ; #<mutex my-mutex>
(make-mutex)                            ; #<mutex 0x7fdcdf9deb60>
\end{lstlisting}

\subsection{Condition Variable Type}
\label{sec:cond-vari-type}

A \keyword{condition variable} is a device for a more complex thread synchronization than the one supported by a mutex.
A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.

Condition variable objects have no read syntax.
They print in hash notation, giving the name of the condition variable (if it has been given a name) or its address in core:
\begin{lstlisting}
(make-condition-variable (make-mutex))  ; #<condvar 0x7fdcdfd33980>
\end{lstlisting}

\subsection{Stream Type}
\label{sec:stream-type}

A \keyword{stream} is an object that can be used as a source or sink for characters — either to supply characters for input or to accept them as output.
Many different types can be used this way: markers, buffers, strings, and functions.
Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a *Help* buffer, or to the echo area.

The object \argument{nil}, in addition to its other meanings, may be used as a stream.
It stands for the value of the variable \argument{standard-input} or \argument{standard-output}.
Also, the object \argument{t} as a stream specifies input using the minibuffer or output in the echo area.

Streams have no special printed representation or read syntax, and print as whatever primitive type they are.

\subsection{Keymap Type}
\label{sec:keymap-type}

A \keyword{keymap} maps keys typed by the user to commands.
This mapping controls how the user’s command input is executed.
A keymap is actually a list whose car is the symbol \argument{keymap}.

\begin{lstlisting}
(symbol-value 'lisp-mode-map)
;; (keymap
;;  (3 keymap
;;     ;; C-c C-z
;;     (26 . run-lisp))
;;  (27 keymap
;;      ;; C-M-x, treated as ESC C-x
;;      (24 . lisp-send-defun))
;;  ;; This part is inherited from lisp-mode-shared-map. keymap
;;  ;; DEL
;;  (127 . backward-delete-char-untabify)
;;  (27 keymap
;;      ;; C-M-q, treated as ESC C-q
;;      (17 . indent-sexp)))
\end{lstlisting}


\subsection{Overlay Type}
\label{sec:overlay-type}

An \keyword{overlay} specifies properties that apply to a part of a buffer.
Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values).
Overlay properties are used to present parts of the buffer temporarily in a different display style. (narrowing)

Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.
\begin{lstlisting}
(setq foo (make-overlay 1 10)) ; #<overlay from 1 to 10 in scratch.el>
\end{lstlisting}


\subsection{Font Type}
\label{sec:font-type}

A \keyword{font} specifies how to display text on a graphical terminal.
There are actually three separate font types — \keyword{font objects}, \keyword{font specs}, and \keyword{font entities} — each of which has slightly different properties.
None of them have a read syntax; their print syntax looks like \argument{\#<font-object>}, \argument{\#<font-spec>}, and \argument{\#<font-entity>} respectively.



\section{Read Syntax for Circular Objects}
\label{sec:read-syntax-circular}

To represent shared or circular structures within a complex of Lisp objects, you can use the reader constructs \argument{\#n=} and \argument{\#n\#}.

Use \argument{\#n=} before an object to label it for later reference; subsequently, you can use \argument{\#n\#} to refer the same object in another place.
Here, \argument{n} is some integer.

\begin{lstlisting}
;; make a list in which the first element recurs as the third element
(#1=(a) b #1#)

;; This differs from ordinary syntax such as this
((a) b (a))

(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))                ; t

(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))                ; nil
\end{lstlisting}


You can also use the same syntax to make a circular structure, which appears as an element within itself. 
\begin{lstlisting}
;; This makes a list whose second element is the list itself.
#1=(a #1#)
\end{lstlisting}


\section{Type Predicates}
\label{sec:type-predicates}

The Emacs Lisp interpreter itself does not perform type checking on the actual arguments passed to functions when they are called.
It could not do so, since function arguments in Lisp do not have declared data types, as they do in other programming languages.
It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use.


All built-in functions do check the types of their actual arguments when appropriate, and signal a wrong-type-argument error if an argument is of the wrong type.


If you want your program to handle different types differently, you must do explicit type checking.
The most common way to check the type of an object is to call a \keyword{type predicate} function.
Emacs has a type predicate for each type, as well as some predicates for combinations of types.


A type predicate function takes one argument; it returns t if the argument belongs to the appropriate type, and nil otherwise.
Following a general Lisp convention for predicate functions, most type predicates’ names end with \argument{p}.

Here is a table of predefined type predicates, in alphabetical order:
\begin{itemize}
\item atom
\item arrayp
\item bignump
\item bool-vector-p
\item booleanp
\item bufferp
\item byte-code--function-p
\item case-table-p
\item char-or-string-p
\item char-table-p
\item commandp
\item condition-variable-p
\item consp
\item custom-variable-p
\item fixnump
\item floatp
\item fontp
\item frame-configuration-p
\item frame-live-p
\item framep
\item functionp
\item hash-table-p
\item integer-or-marker-p
\item integerp
\item keymapp
\item keywordp
\item listp
\item markerp
\item mutexp
\item nlistp
\item number-or-marker-p
\item numberp
\item overlayp
\item processp
\item recordp
\item sequencep
\item string-or-null-p
\item stringp
\item subrp
\item symbolp
\item syntax-table-p
\item treadp
\item vectorp
\item wholenump
\item window-configuration-p
\item window-live-p
\item windowp
\end{itemize}


The most general way to check the type of an object is to call the function \argument{type-of}.
Each object belongs to one and only one primitive type; \argument{type-of} tells you which one.
But \argument{type-of} knows nothing about non-primitive types.
In most cases, it is more convenient to use type predicates than \argument{type-of}.

\section{Equality Predicates}
\label{sec:equality-predicates}

Here we describe functions that test for equality between two objects.

\begin{itemize}[itemsep=10pt]
\item \lstinline|(eq object1 object2)|\\
  This function returns \argument{t} if \argument{object1} and \argument{object2} are the same object, and \argument{nil} otherwise.

  \begin{itemize}
  \item If \argument{object1} and \argument{object2} are symbols with the same name, they are normally the same object (there are exceptions\footnote{
      The \argument{make-symbol} function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression.
      Distinct symbols with the same name are not \argument{eq}.}).
  \item For other non-numeric types (e.g., lists, vectors, strings), two arguments with the same contents or elements are not necessarily \argument{eq} to each other: they are \argument{eq} only if they are the same object, meaning that a change in the contents of one will be reflected by the same change in the contents of the other.
  \item If \argument{object1} and \argument{object2} are numbers with differing types or values, then they cannot be the same object and \argument{eq} returns \argument{nil}.
  \item If they are fixnums with the same value, then they are the same object and \argument{eq} returns \argument{t}. 
  \item If they were computed separately but happen to have the same value and the same non-fixnum numeric type, then they might or might not be the same object, and \argument{eq} returns \argument{t} or \argument{nil} depending on whether the Lisp interpreter created one object or two.
  \end{itemize}

\item \lstinline|(equal object1 object2)|\\
  This function returns t if object1 and object2 have equal components, and nil otherwise.

  Comparison of strings is case-sensitive, but does not take account of text properties — it compares only the characters in the strings.

  The \argument{equal} function recursively compares the contents of objects if they are inte gers, strings, markers, vectors, bool-vectors, byte-code function objects, char-tables, records, or font objects.
  Other objects are considered \argument{equal} only if they are \argument{eq}.
  For example, two distinct buffers are never considered equal, even if their textual contents are the same.

  
\item \lstinline|(equal-including-properties object1 object2)|\\
  This function behaves like \argument{equal} in all cases but also requires that for two strings to be equal, they have the same text properties.
  
  
\end{itemize}


\section{Mutability}
\label{sec:mutability}

Some Lisp object should or can never change.
But some Lisp objects can change, we say they are \keyword{mutable}.

A mutable object stops being mutable if it is part of expression that is evaluated.


\section{Summary}
\label{sec:summary}

\begin{figure}[H]
  \centering
  \myfigure{data-type}
  \caption{List data types}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "elisp"
%%% End:
