
\chapter{Strings and Characters}
\label{cha:strings-characters}

A string is an array that contains an ordered sequence of characters.


\section{String and Character Basics}
\label{sec:string-char-basic}

A character is a Lisp object which represents a single character of text.
In Emacs Lisp, characters are simply integers; whether an integer is a character or not is determined only by how it is used.

A string is a fixed sequence of characters.
It is a type of sequence called a \keyword{array}, meaning that its length is fixed and cannot be altered once it is created 

There are two text representations for non-ASCII characters in Emacs strings (and in buffers): unibyte and multibyte. 

Strings cannot hold characters that have the hyper, super or alt modifiers; they can hold ASCII control characters, but no other control characters.
They do not distinguish case in ASCII control characters.


\section{Predicates for Strings}
\label{sec:predicates-strings}

\begin{itemize}
\item \lstinline|(stringp object)|\\
  This function returns \argument{t} if \argument{object} is a string, \argument{nil} otherwise.
\item \lstinline|(string-or-null-p object)|\\
  This function returns \argument{t} if \argument{object} is a string or \argument{nil}.
  It returns \argument{nil} otherwise
\item \lstinline|(char-or-string-p object)|\\
  This function returns \argument{t} if \argument{object} is a string or a character (i.e., an integer), \argument{nil} otherwise.
\end{itemize}



\section{Creating Strings}
\label{sec:creating-strings}

\begin{itemize}[itemsep=10pt]
\item \lstinline|(make-string count character &optional multibyte)|\\
  This function returns a string made up of \argument{count} repetitions of \argument{character}.
  If \argument{count} is negative, an error is signaled.
\begin{lstlisting}
(make-string 5 ?x)                      ; "xxxxx"
\end{lstlisting}
  Normally, if \argument{character} is an ASCII character, the result is a unibyte string.
  But if the optional argument \argument{multibyte} is non-nil, the function will produce a multibyte string instead. 
\item \lstinline|(string &rest characters)|\\
  This returns a string containing the characters \argument{characters}.
\begin{lstlisting}
(string ?a ?b ?c)                       ; "abc"
\end{lstlisting}
\item \lstinline|(substring string &optional start end)|\\
  This function returns a new string which consists of those characters from \argument{string} in the range from (and including) the character at the index \argument{start} up to (but excluding) the character at the index \argument{end}.
  The first character is at index zero.

  If the characters copied from \argument{string} have text properties, the properties are copied into the new string also
\begin{lstlisting}
(substring "abcdefg" 0 3)               ; "abc"
(substring "abcdefg" -3 -1)             ; "ef"
(substring "abcdefg" -3 nil)            ; "efg"
(substring "abcdefg" 0)                 ; "abcdefg"
\end{lstlisting}
\item \lstinline|(substring-no-properties string &optional start end|\\
  This works like \argument{substring} but discards all text properties from the value.
\item \lstinline|(concat &rest sequences)|\\
  This function returns a string consisting of the characters in the arguments passed to it (along with their text properties, if any).
  The arguments may be strings, lists of numbers, or vectors of numbers; they are not themselves changed.
  If \argument{concat} receives no arguments, it returns an empty string.
\begin{lstlisting}
(concat "abc" "-def")                   ; "abc-def"
(concat "abc" (list 120 121) [122])     ; "abcxyz"
(concat "abc" nil "-def")               ; "abc-def"
(concat)                                ; ""
\end{lstlisting}
\item \lstinline|(split-string string &optional separators omit-nulls trim)|\\
  This function splits \argument{argument} into substrings based on the regular expression \argument{separators}.
  Each match for \argument{separators} defines a splitting point; the substrings between splitting points are made into a slit, which is returned.

  If \argument{separators} is \argument{nil} (or omitted), the default is the value of \argument{split-string-default-separators} and the function behaves as if \argument{omit-nulls} were \argument{t}.
  
  If \argument{omit-nulls} is \argument{nil} (or omitted), the result contains null strings whenever there are two consecutive matches for separators, or a match is adjacent to the beginning or end of string.
  If \argument{omit-nulls} is \argument{t}, these null strings are omitted from the result.

  If the optional argument \argument{trim} is non-\argument{nil}, it should be a regular expression to match text to trim from the beginning and end of each substring.
  If trimming makes the substring empty, it is treated as null.
\begin{lstlisting}
(split-string " two words ")            ; ("two" "words")
(split-string "  two words "
              split-string-default-separators) ; ("" "two" "words" "")
(split-string "Soup is good food" "o")         ; ("S" "up is g" "" "d f" "" "d")
(split-string "Soup is good food" "o" t)       ; ("S" "up is g" "d f" "d")
(split-string "Soup is good food" "o+")        ; ("S" "up is g" "d f" "d")
\end{lstlisting}
\item \lstinline|split-string-default-separators|\\
  The default value of separators for \argument{split-string}.
\item \lstinline|(string-clean-whitespace string)|\\
  Clean up the whitespace in \argument{string} by collapsing stretches of whitespace to a single space character, as well as removing all whitespace from the start and the end of \argument{string}.
  \lstinline|(string-trim-left string &optional regexp)|\\
  Remove the leading text that matches \argument{regexp} from \argument{string}. 
\item \lstinline|(string-trim-right string &optional regexp)|
\item \lstinline|(string-trim string &optional trim-left trim-right)|\\
  Remove the leading text that matches \argument{trim-left} and trailing text that matches \argument{trim-right} from string. 
\item \lstinline|(string-fill string length)|\\
  Attempt to Word-wrap \argument{string} so that no lines are longer than \argument{length}.
  Filling is done on whitespace boundaries only.
\item \lstinline|(string-limit string length &optional end coding-system)|\\
  If \argument{string} is shorter than \argument{length} characters, \argument{string} is returned as is.
  Otherwise, return a substring of \argument{string} consisting of the first \argument{length} characters.
  If the optional \argument{end} parameter is given, return a string of the \argument{length} last characters instead.

  If \argument{coding-system} is non-\argument{nil}, \argument{string} will be encoded before limiting.
\item \lstinline|(string-lines string &optional omit-nulls)|\\
  Split \argument{string} into a list of strings on newline boundaries.
  If \argument{omit-nulls}, remove empty lines from the results.
\item \lstinline|(string-pad string length &optional padding start)|\\
  Pad \argument{string} to be of the given \argument{length} using \argument{padding} as the padding character.
  \argument{padding} defaults to the space character.
  If \argument{string} is longer than \argument{length}, no padding is done.
  If \argument{start} is \argument{nil} or omitted, the padding is appended to the characters of \argument{string}, and if it’s non-\argument{nil}, the padding is prepended to \argument{string}’s characters.
  \lstinline|(string-chop-newline string)|\\
  Remove the final newline, if any, from \argument{string}.
\end{itemize}


\section{Modifying Strings}
\label{sec:modifying-strings}

\begin{itemize}[itemsep=10pt]
\item\lstinline|(aset string idx char)|\\
  This function stores \argument{char} into \argument{string} at character index \argument{idx}.
\item \lstinline|(store-substring string idx obj)|\\
  This function alters part of the contents of the specified \argument{string}, by storing \argument{obj} starting at character index \argument{idx}.
\item \lstinline|(clear-string string)|\\
  This makes \argument{string} a unibyte string and clears its contents to zeros.
  It may also change \argument{string}'s length.
\end{itemize}

\section{Comparsion of Characters and Strings}
\label{sec:comp-char-strings}

\begin{itemize}[itemsep=10pt]
\item \lstinline|(char-equal character1 character2)|\\
  This function returns \argument{t} if the arguments represent the same character, \argument{nil} otherwise.
  This function ignores differences in case if \argument{case-fold-search} is non-\argument{nil}.
\item \lstinline|(string= string1 string2)|\\
  This function returns \argument{t} if the characters of the two strings match exactly.
  Symbols are also allowed as arguments, in which case the symbol names are used.
  Case is always significant, regardless of \argument{case-fold-search}.
\item \lstinline|(string-equal string1 string2)|\\
  another name for \argument{string=}
\item \lstinline|(string-collate-equalp string1 string2 &optional locale ignore-case)|\\
  This function returns \argument{t} if \argument{string1} and \argument{string2} are equal with respect to collation rules.
  A \keyword{collation rule} is not only determined by the lexicographic order of the characters contained in \argument{string1} and \argument{string2}, but also further rules about relations between these characters.
  Usually, it is defined by the \argument{locale} environment Emacs is running with and by the Standard C library against which Emacs was linked.

  The optional argument \argument{locale}, a string, overrides the setting of your current locale identifier for collation.
  The value is system dependent.

  If \argument{ignore-case} is non-\argument{nil}, characters are converted to lower-case before comparing them.

\item \lstinline|(string< string1 string2)|\\
  This function compares two strings a character at a time.
  It scans both the strings at the same time to find the first pair of corresponding characters that do not match.
  If the lesser character of these two is the character from \argument{string1}, then \argument{string1} is less, and this function returns \argument{t}.
  If the lesser character is the one from \argument{string2}, then \argument{string1} is greater, and this function returns \argument{nil}.
  If the two strings match entirely, the value is \argument{nil}.
  
\item \lstinline|(string-lessp string1 string2)|\\
  another name for \argument{string<}
\item \lstinline|(string-greaterp string1 string2)|\\
  This function returns the result of comparing \argument{string1} and \argument{string2} in the opposite order, i.e., it is equivalent to calling \lstinline|(string-lessp string2 string1)|.
\item \lstinline|(string-collate-lessp string1 string2 &optional locale ignore-case)|\\
  This function returns \argument{t} if \argument{string1} is less than \argument{string2} in collation order.
  
\item \lstinline|(string-version-lessp string1 string2)|\\
  This function compares strings lexicographically, except it treats sequences of numerical characters as if they comprised a base-ten number, and then compares the numbers.
  So ‘foo2.png’ is “smaller” than ‘foo12.png’ according to this predicate, even if ‘12’ is lexicographically “smaller” than ‘2’.
\item \lstinline|(string-prefix-p prefix string &optional ignore-case)|\\
  This function returns non-\argument{nil} if \argument{prefix} is a prefix of \argument{string}.
\item \lstinline|(string-suffix-p suffix string &optional ignore-case)|\\
  This function returns non-\argument{nil} if \argument{suffix} is a suffix of \argument{string}.
  
\item \lstinline|(compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case)|\\
  The strings are compared by the numeric values of their characters.

  If the specified portions of the two strings match, the value is \argument{t}.
  Otherwise, the value is an integer which indicates how many leading characters agree, and which string is less.
  Its absolute value is one plus the number of characters that agree at the beginning of the two strings.
  The sign is negative if \argument{string1} (or its specified portion) is less.
  
\item \lstinline|(string-distance string1 string2 &optional bytecompare)|\\
  This function returns the \keyword{Levenshtein distance} between the source string \argument{string1} and the target string \argument{string2}.
  The Levenshtein distance is the number of single character changes — deletions, insertions, or replacements — required to transform the source string into the target string; it is one possible definition of the edit distance between strings.

  
\end{itemize}

\section{Conversion of Characters and Strings}
\label{sec:conv-char-strings}

This section describes functions for converting between characters, strings and integers.

\begin{itemize}[itemsep=10pt]
\item \lstinline|(number-to-string number)|\\
  This function returns a string consisting of the printed base-ten representation of number.
\item \lstinline|(string-to-number string &optional base)|\\
  This function returns the numeric value of the characters in string.
  If \argument{string} cannot be interpreted as a number, this function returns 0.
  
\end{itemize}

\section{Formatting Strings}
\label{sec:formatting-strings}

\keyword{Formatting} means constructing a string by substituting computed values at various places in a constant string.
This constant string controls how the other values are printed, as well as where they appear; it is called a \keyword{format string}.

\begin{itemize}[itemsep=10pt]
\item \lstinline|(format string &rest objects)|\\
  This function returns a string equal to \argument{string}, replacing any format specification with encodings of the corresponding \argument{objects}.
  The argument \argument{objects} are the computed values to be formatted.

  The characters in \argument{string}, other than the format specifications, are copied directly into the output, including their text properties, if any.
  Any text properties of the format specifications are copied to the produced string representations of the argument \argument{objects}.

\begin{lstlisting}
(format "hello, %s" "Ming")             ; "hello, Ming"
\end{lstlisting}

\item \lstinline|(format-message string &rest objects)|\\
  This function acts like \argument{format}, except it also converts any grave accents (‘) and apostrophes (’) in string as per the value of \argument{text-quoting-style}.
\begin{lstlisting}
(format "hello, '%s'" "Ming")           ; "hello, 'Ming'"
(format-message "hello, '%s'" "Ming")   ; "hello, ’Ming’"
\end{lstlisting}
\end{itemize}



A \keyword{format specification} is a sequence of characters beginning with a \argument{\%}.
Certain format specifications require values of particular types.
If you supply a value that doesn’t fit the requirements, an error is signaled.

Here is a list of valid format specifications:
\begin{itemize}[itemsep=10pt]
\item \argument{\%s}\\
  Replace the specification with the printed representation of the object, made without quoting.
\item \argument{\%S}\\
  Replace the specification with the printed representation of the object, made with quoting.
\begin{lstlisting}
(format "%s" "hello")                   ; "hello"
(format "%S" "hello")                   ; "\"hello\""
\end{lstlisting}
\item \argument{\%o}\\
  Replace the specification with the base-eight representation of an integer.
\item \argument{\%d}\\
  Replace the specification with the base-ten representation of a signed integer.
\item \argument{\%x}\\
  Replace the specification with the base-sixteen representation of an integer using lower case.
\item \argument{\%X}\\
  Replace the specification with the base-sixteen representation of an integer using upper case.
\item \argument{\%c}\\
  Replace the specification with the character which is the value given.
\item \argument{\%e}\\
  Replace the specification with the exponential notation for a floating-point number.
\item \argument{\%f}\\
  Replace the specification with the decimal-point notation for a floating-point number.
\item \argument{\%g}\\
  Replace the specification with notation for a floating-point number, using either exponential notation or decimal-point notation. 
\item \argument{\%\%}\\
  Replace the specification with a single \argument{\%}.
  This format specification is unusual in that its only form is plain \argument{\%\%} and that it does not use a value.
\begin{lstlisting}
(format "%% %d" 30)                     ; "% 30"
\end{lstlisting}

\end{itemize}


By default, format specifications correspond to successive values from \argument{objects}.
Thus, the first format specification in string uses the first such value, the second format specification uses the second such value, and so on.
Any extra format specifications (those for which there are no corresponding values) cause an error.
Any extra values to be formatted are ignored.


A format specification can have a \keyword{field number}, which is a decimal number immediately after the initial \argument{\%}, followed by a literal dollar sign \argument{\$}.
It causes the format specification to convert the argument with the given number instead of the next argument.
Field numbers start at 1.
A format can contain either numbered or unnumbered format specifications but not both, except that \argument{\%\%} can be mixed with numbered specifications.
\begin{lstlisting}
(format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
;;  "y, z, %, x"
\end{lstlisting}




After the \argument{\%} and any field number, you can put certain \keyword{flag characters}.
\begin{itemize}
\item \argument{+}\\
  Insert a plus sign before a nonnegative number.
  They are ignored except for \argument{\%d, \%e, \%f, \%g}.
\item \argument{space character}\\
  Insert a space before a nonnegative number.
  They are ignored except for \argument{\%d, \%e, \%f, \%g}.
  If both \argument{+} and \argument{space character} are used, \argument{+} takes precedence.  
\item \argument{\#}\\
  Specifies an alternate form which depends on the format in use.
  \begin{itemize}
  \item For \argument{\%o}, it ensures that the result begins with a \argument{0}. 
  \item For \argument{\%x} and \argument{\%X}, it prefixes nonzero results with \argument{0x} or \argument{0X}.
  \item  For \argument{\%e} and \argument{\%f}, it include a decimal point even if the precision is zero.
  \item  For \argument{\%g}, it always includes a decimal point, and also forces any trailing zeros after the decimal point to be left in place where they would otherwise be removed.
  \end{itemize}
\item \argument{0}\\
  Ensures that the padding consists of \argument{0} characters instead of spaces.
  This flag is ignored for non-numerical specification characters like \argument{\%s}, \argument{\%S} and \argument{\%c}.
  These specification characters accept the \argument{0} flag, but still pad with spaces.
\item \argument{-}\\
  Causes any padding inserted by the width, if specified, to be inserted on the right rather than the left.
  If both \argument{-} and \argument{0} are present, the \argument{0} flag is ignored.
\end{itemize}


\begin{lstlisting}
(format "%06d is padded on the left with zeros" 123)
;;  "000123 is padded on the left with zeros"
(format "'%-6d' is padded on the right" 123)
;;  "'123   ' is padded on the right"
(format "The word '%-7s' actually has %d letters in it."
        "foo" (length "foo"))
;;  "The word 'foo    ' actually has 3 letters in it."
\end{lstlisting}


A specification can have a \keyword{width}, which is a decimal number that appears after any field number and flags.
If the printed representation of the object contains fewer characters than this width, \argument{format} extends it with padding.
Any padding introduced by the width normally consists of spaces inserted on the left.
If the width is too small, format does not truncate the object’s printed representation.
\begin{lstlisting}
(format "%5d is padded on the left with spaces" 123)
;;  "  123 is padded on the left with spaces"
(format "The word '%7s' has %d letters in it."
        "specification" (length "specification"))
;;  "The word 'specification' has 13 letters in it."
\end{lstlisting}

All the specification characters allow an optional \keyword{precision} after the field number, flags and width, if present.
The precision is a decimal-point \argument{.} followed by a digit-string.
\begin{itemize}
\item For the floating-point specifications (\argument{\%e} and \argument{\%f}), the precision specifies how many digits following the decimal point to show; if zero, the decimal-point itself is also omitted.
\item  For \argument{\%g}, the precision specifies how many significant digits to show (significant digits are the first digit before the decimal point and all the digits after it). If the precision of \argument{\%g} is zero or unspecified, it is treated as 1.
\item  For \argument{\%s} and \argument{\%S}, the precision truncates the string to the given width.
\item  For other specification characters, the effect of precision is what the local library functions of the \argument{printf} family produce.
\end{itemize}

\section{Custom Format Strings}
\label{sec:cust-form-strings}

\begin{lstlisting}
(format-spec template spec-alist &optional ignore-missing split)
\end{lstlisting}
This function returns a string produced from the format string \argument{template} according to conversion specified in \argument{spec-alist}, which is an alist of the form \lstinline|(letter . replacement)|.
Each specification \argument{\%letter} in \argument{template} will be replaced by \argument{replacement} when formatting the resulting string.

Using an alist to specify conversions gives rise to some useful properties:
\begin{itemize}
\item If \argument{spec-alist} contains more unique \argument{letter} keys than there are unique specification characters in \argument{template}, the unused keys are ignored.
\item If \argument{spec-alist} contains more than one association with the same \argument{letter}, the closest on to the start of the list is used.
\item If \argument{template} contains the same specification character more than once, then the same \argument{replacement} found in \argument{spec-alist} is used as a basis for all of that character's substitutions.
\item The order of specification in \argument{template} need not to correspond to the order of association in \argument{spec-alist}.
\end{itemize}


The optional argument \argument{ignore-missing} indicates how to handle specification characters in template that are not found in \argument{spec-alist}.
If it is \argument{nil} or omitted, the function signals an error; if it is \argument{ignore}, those format specifications are left verbatim in the output, including their text properties, if any; if it is \argument{delete}, those format specifications are removed from the output; any other non-\argument{nil} value is handled like ignore, but any occurrences of \argument{\%\%} are also left verbatim in the output.


If the optional argument \argument{split} is non-\argument{nil}, instead of returning a single string, \argument{format-spec} will split the result into a list of strings, based on where the substitutions were performed.
\begin{lstlisting}
(format-spec "foo %b bar" '((?b . "zot")) nil t)
;; ("foo " "zot" " bar")
\end{lstlisting}

Unlike \argument{format}, which assigns specific meanings to a fixed set of specification characters, \argument{format-spec} accepts arbitrary specification characters and treats them all equally. For example:
\begin{lstlisting}

(setq my-site-info
      (list (cons ?s system-name)
            (cons ?t (symbol-name system-type))
            (cons ?c system-configuration)
            (cons ?v emacs-version)
            (cons ?e invocation-name)
            (cons ?p (number-to-string (emacs-pid)))
            (cons ?a user-mail-address)
            (cons ?n user-full-name)))

(format-spec "%e %v (%c) Emacs User: %n" my-site-info)
;; "Emacs-x86_64-10_14 28.2 (x86_64-apple-darwin18.7.0) Emacs User: Mingming Li"
\end{lstlisting}

A format specification can include any number of the following flag characters immedi- ately after the \argument{\%}.
\begin{itemize}
\item \argument{0}\\
  Causes any padding specified by the width to consist of \argument{0} characters instead of spaces.
\item \argument{-}\\
  Causes any padding specified by the width to be inserted on the right rather than the left.
\item \argument{<}\\
  Causes the substitution to be truncated on the left to the given width and precision, if specified.
\item \argument{>}\\
  Causes the substitution to be truncated on the right to the given width, if specified.
\item \argument{\textasciicircum{}}\\
  Converts the substituted text to upper case.
\item \textasciicircum{\_}\\
  Converts the substituted text to lower case.
\end{itemize}

As is the case with \argument{format}, a format specification can include a width, which is a decimal number that appears after any flags, and a precision, which is a decimal-point \argument{.} followed by a decimal number that appears after any flags and width.


If a substitution contains fewer characters than its specified width, it is padded on the left.
If a substitution contains more characters than its specified precision, it is truncated on the right.

\begin{lstlisting}
(setq my-battery-info
      (list (cons ?p "73")      ; Percentage
            (cons ?L "Battery") ; Status
            (cons ?t "2:23")    ; Remaining time
            (cons ?c "24330")   ; Capacity
            (cons ?r "10.6")))  ; Rate of discharge

(format-spec "%>^-3L : %3p%% (%05t left)" my-battery-info)
;; "BAT :  73% (02:23 left)"
\end{lstlisting}


\section{Case Conversion in Lisp}
\label{sec:case-conversion-lisp}

The character case functions change the case of single characters or of the contents of strings.
The functions normally convert only alphabetic characters (the letters ‘A’ through ‘Z’ and ‘a’ through ‘z’, as well as non-ASCII letters); other characters are not altered. You can specify a different case conversion mapping by specifying a case table.

These functions do not modify the strings that are passed to them as arguments.
\begin{itemize}
\item \lstinline|(downcase string-or-char)|
\item \lstinline|(upcase string-or-char)|  
\item \lstinline|(capitalize string-or-char)|
\item \lstinline|(upcase-initials string-or-char)|
\end{itemize}

\begin{lstlisting}
;; downcase
(downcase "The cat in the hat")         ; "the cat in the hat"
(downcase ?X)                           ; 120

;; upcase
(upcase "The cat in the hat")           ; "THE CAT IN THE HAT"
(upcase ?x)                             ; 88

;; capitalize
(capitalize "The cAt in the hat")       ; "The Cat In The Hat"
(capitalize ?x)                         ; 88

;; upcase-initials
(upcase-initials "The cAt in the hat")  ; "The CAt In The Hat"
(upcase-initials ?x)                    ; 88
\end{lstlisting}

\section{The Case Table}
\label{sec:case-table}

You can customize case conversion by installing a special \keyword{case table}.
A case table specifies the mapping between upper case and lower case letters.
It affects both the case conversion functions for Lisp objects and those that apply to text in the buffer.
Each buffer has a case table; there is also a standard case table which is used to initialize the case table of new buffers.


A case table is a char-table whose subtype is \argument{case-table}.
This char-table maps each character into the corresponding lower case character.
It has three extra slots, which hold related tables:
\begin{itemize}
\item \argument{upcase}\\
  The upcase table maps each character into the corresponding upper case character.
\item \argument{canonicalize}\\
  The canonicalize table maps all of a set of case-related characters into a particular member of that set.
\item \argument{equivalences}\\
  The equivalences table maps each one of a set of case-related characters into the next character in that set.
\end{itemize}


In simple cases, all you need to specify is the mapping to lower-case; the three related tables will be calculated automatically from that one.


For some languages, upper and lower case letters are not in one-to-one correspondence.
There may be two different lower case letters with the same upper case equivalent.
In these cases, you need to specify the maps for both lower case and upper case.


The extra table \argument{canonicalize} maps each character to a canonical equivalent; any two characters that are related by case-conversion have the same canonical equivalent character.
For example, since ‘a’ and ‘A’ are related by case-conversion, they should have the same canonical equivalent character (which should be either ‘a’ for both of them, or ‘A’ for both of them).

The extra table \argument{equivalences} is a map that cyclically permutes each equivalence class (of characters with the same canonical equivalent).
(For ordinary ASCII, this would map ‘a’ into ‘A’ and ‘A’ into ‘a’, and likewise for each set of equivalent characters.)



When constructing a case table, you can provide \argument{nil} for \argument{canonicalize}; then Emacs fills in this slot from the lower case and upper case mappings.
You can also provide \argument{nil} for \argument{equivalences}; then Emacs fills in this slot from \argument{canonicalize}.
In a case table that is actually in use, those components are non-\argument{nil}.


\section{Summary}
\label{sec:summary-2}

\begin{figure}[H]
  \centering
  \myfigure[0.8]{string-and-character}
  \caption{String and Character}
\end{figure}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "elisp"
%%% End:
