% Created 2022-04-10 Sun 15:27
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Mingming Li}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={Mingming Li},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}

\begin{document}

\tableofcontents

\section{{\bfseries\sffamily DONE} Getting Started}
\label{sec:org6dbc28c}
\subsection{Version Constrol}
\label{sec:org907cdb0}
A system that records changes of a file or set of files.\\
\subsection{Evolution}
\label{sec:org3e83215}
\begin{enumerate}
\item Local Version Control Systems\\
\item Centralized Version Control Systems\\
\item Distributed Version Control Systems\\
\end{enumerate}


\subsection{Git Basics}
\label{sec:org369b067}
\subsubsection{Snapshots, Not Differences}
\label{sec:org75b66ea}
Git thinks of its data more like a set of snapshots of a miniature filesystem. Every time you commit, or save the state of your project in Git, it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot.\\
To be efficient, if files have not changed, Git doesn't store the file again, just a link to the previous identical file it has already stored.\\

\subsubsection{Nearly Every Operation Is Local}
\label{sec:orgac383b4}

\subsubsection{Git Has Integrity}
\label{sec:orgdb40209}
Everything in Git is check-sumed before it is stored and is then referred to by that checksum. The mechanism that Git uses for this checksumming is called a SHA-1 hash. In fact, Git stores everything in its database not by file name but by the hash value of it contents.\\

\subsubsection{Git Generally Only Adds Data}
\label{sec:org3cf22ec}

\subsubsection{The Three States}
\label{sec:org7e4403b}
Git has three main states that your files can reside in:\\

\begin{center}
\begin{tabular}{ll}
Name & Meaning\\
\hline
Committed & means that the data is safely stored in your local database.\\
Modified & means that you have changed the file but have not committed it to you database yet.\\
Staged & means that you have marked a modified file in its current version to go into your next commit snapshot.\\
\end{tabular}
\end{center}

This leads us to the three main sections of a Git project:\\
the Git directory, working directory, and the staging area.\\
The Git directory is where Git stores the metadata and object database for your project. This is the most important part of Git, and it is what is copied when you clone a repository from another computer.\\
The working directory is a single checkout of one version of the project. These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.\\
The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit.\\


\subsection{First-Time Git Setup}
\label{sec:org94c77e6}
Git comes with a tool called "git config" that lets you get and set configuration variables that control all aspects of how Git looks and operates.\\
These variables can be stored in three different places:\\
\begin{enumerate}
\item /etc/gitconfig file: Contains values for every user on the system and all their repositories. If you pass the option --system to git config, it reads and writes from this file specifically.\\
\item \textasciitilde{}/.gitconfig or \textasciitilde{}/.config/git/config file: Specific to your user. You can make git read and write to this file specifically by passing the --global option.\\
\item config file in the Git directory (that is, .git/config) of whatever repository you're currently using: Specific to that single repository.\\
\end{enumerate}

Each level overrides values in the previous level.\\

\subsubsection{Your Identity}
\label{sec:org2e85862}
git config --global user.name "Michael Chyson"\\
git config --global user.email chyson@aliyun.com\\

\subsubsection{Your Editor}
\label{sec:orgf15ba56}
git config --global core.editor emacs\\

\subsubsection{Checking Your Settings}
\label{sec:org2a169d4}
git config --list\\
git config user.name\\

\subsection{Getting Help}
\label{sec:orgd6fa561}
\begin{verbatim}
man git
git <cammand> -h  # simple information help
git <command> --help  # verbose information help
\end{verbatim}



\section{{\bfseries\sffamily DONE} Git Basics}
\label{sec:org53bc411}
\subsection{Getting a Git Repository}
\label{sec:orge38dcba}
\subsubsection{Initializing a Repository in an Existing Directory}
\label{sec:orga3ef533}
git init

\begin{verbatim}
git init -h
\end{verbatim}

This creates a new subdirectory named .git that contains all of your necessary repository files -- a Git repository skeleton.\\

\subsubsection{Cloning an Existing Repository}
\label{sec:org407443e}
git clone \url{https://github.com/libgit2/libgit2}\\

That creates a directory named "libgit2", initializes a .git directory inside it, pulls down all the data for that repository, and checks out a working copy of the latest version.\\

git clone \url{https://github.com/libgit2/libgit2} mylibgit\\

The target directory is called mylibgit.\\

\subsection{Recording Changes to the Repository}
\label{sec:orgae728fd}
Each file in your directory can be in one of two states: tracked or untracked.\\
Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged.\\
Untracked files are everyhting else -- any files in your directory that were not in your last snapshot and are not in your staging area.\\

\subsubsection{Checking the Status of Your Files}
\label{sec:org5a0a6bd}
git status\\
\begin{verbatim}
git status -h
\end{verbatim}

\subsubsection{Tracking New Files}
\label{sec:orgdf4a0ba}
git add <file>\\
git add *\\
\begin{verbatim}
git add -h
\end{verbatim}
The git add command takes a path name for either a file or a directory; if it's a directory, the command adds all the files in that directory recursively.\\

\subsubsection{Staging Modified Files}
\label{sec:org7084704}
git add <file>\\


\subsubsection{Short Status}
\label{sec:org201d1c0}
git status -s\\
git status --short\\

new files that aren't tracked have a ?? next to them;\\
new files that have been added to the staging area have an A;\\
modified files have an M;\\


\subsubsection{Ignoring Files}
\label{sec:org6096ad6}
emacs .gitignore (in the project directory)\\
(or .git/info/exclude)\\


\subsubsection{Viewing Your Staged and Unstaged Changes}
\label{sec:org8badc20}
git diff\\

This command compares what is in your working directory with what is in your staging area.\\

to see what you've staged that will go into your next commit, you can use:\\
git diff --staged\\

This command compares your staged changes to your last commit.\\

\subsubsection{Committing Your Changes}
\label{sec:org561d2f8}
\begin{verbatim}
git commit
git commit -h
\end{verbatim}

For an even more explicit reminder of what you've modified, you can pass the -v option to git commit.\\
Doing so also puts the diff of you change in the editor so you can see exactly what changes you're committing:\\
\begin{verbatim}
git commit -v
\end{verbatim}

you can type your commit message inline:\\
\begin{verbatim}
git commit -m "Story 182: Fix benchmarks for speed"
\end{verbatim}


\subsubsection{Skipping the Staging Area}
\label{sec:orgdda6f58}
If you want to skip the staging area, adding the -a option to the git commit command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the git add part:\\
\begin{verbatim}
git commit -a
\end{verbatim}


\subsubsection{Removing Files}
\label{sec:org45f1de3}
\begin{verbatim}
git rm <file>
git rm -h
\end{verbatim}

remove a file from your tracked files and removes the file from your working directory.\\

If you modified the file and added it to the index already, you must force the removal with the -f option:\\
git rm -f <file>\\

to keep the file in your working tree but remove it from your staging area:\\
git rm --cached <file>\\


\subsubsection{Moving Files}
\label{sec:org52c3fe1}
Git doesn't explicitly track file movement.\\
If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file.\\
However, Git is pretty smart about figuring that out after the fact.\\

If you want to rename a file in Git:\\
git mv <file\_from> <file\_to>\\

is same as:\\
mv <file\_from> <file\_to>\\
git rm <file\_from>\\
git add <file\_to>\\


\subsection{Viewing the Commit History}
\label{sec:orgd647cac}
The most basic and powerful tool to see what has happened:\\
\begin{verbatim}
git log
git log -h
git log --help
\end{verbatim}

By default, with no argument, git log lists the commit made in that repository in reverse chronological order.\\

\subsubsection{commain options}
\label{sec:org9db2588}
\begin{center}
\begin{tabular}{ll}
Options & Meaning\\
\hline
-p & shows the difference introduced in each commit (patch)\\
-2 & limits the output to only the last two entries\\
--stat & to see some abbreviated stats for each commit\\
--pretty & change the log output to formats other than the default\\
--graph & adds a nice little ASCII graph showing your branch and merge history\\
\end{tabular}
\end{center}

\begin{verbatim}
git log --pretty=oneline
\end{verbatim}


The most interesting option is format, which allows you to specify your own log output format. This is especially useful when you're generating output for machine parsing.\\
\begin{verbatim}
git log --pretty=format:"%h - %an, %ar : %s"
\end{verbatim}


\subsubsection{userfull option for git log --pretty=format}
\label{sec:orgaacbc63}
(lowercase: abbreviated)\\
\begin{center}
\begin{tabular}{|l|l|}
\hline
\%H & commit hash \\
\hline
\%h & abbreviated commit hash \\
\hline
\%T & tree hash \\
\hline
\%t & abbreviated tree hash \\
\hline
\%P & parent hashes \\
\hline
\%p & abbreviated parent hashes \\
\hline
\%an & author name \\
\hline
\%ae & author email \\
\hline
\%ad & author date \\
\hline
\%ar & author date, relative \\
\hline
\%cn & commit name \\
\hline
\%ce & commite email \\
\hline
\%cd & commit date \\
\hline
\%cr & commit date, relative \\
\hline
\%s & subject \\
\hline
\end{tabular}
\end{center}

The author is the person who originally wrote the work, whereas the commiter is the person who last applied the work.\\


\subsubsection{options to limit the output of git log}
\label{sec:org1f7b88b}

\begin{center}
\begin{tabular}{|l|l|}
\hline
-(n) & shwo only the last n commits \\
\hline
--since, --after & limite the commits to those made after the specified date \\
\hline
--until, --before & limit the commits to those made before the specified date \\
\hline
--author & only show commits in which the author entry matches the specified \\
 & string \\
\hline
--commiter & only show commits in which the committer entry matches the \\
 & specified string \\
\hline
--grep & only show commits with a commit message containing the string \\
\hline
-S & only show commits adding or removing code matching the string \\
\hline
\end{tabular}
\end{center}
\begin{verbatim}
git log --sine=2.weeks
\end{verbatim}

note that: if you want to specify both author and grep options, you have to add --all-match or the command will match commits with either.\\
\begin{verbatim}
git log -Sfunction_name
\end{verbatim}

If you specify a directory or file name, you can limit the log output to commits that introduced a change to those files.\\
This is always the last option and is generally preceded by double dashes(--) to seperate the paths from the options.\\

to see which commits modifying test files in the Git source code hisotry are merged and were committed by Junio Hamano in the month of October 2008:\\
\begin{verbatim}
git log --pretty="%h - %s" --author="Junio Hamano" --since="2008-10-01" --before="2008-10-01" --no-merges -- test
\end{verbatim}


\subsection{Undoing Things}
\label{sec:org439448e}
One of the common undos takes place when you commit too early and possibly forget to add some files, or you mess up your commit message. If you want to try that commit again, you can run commit with the --amend option:\\
\begin{verbatim}
git commit --amend
\end{verbatim}


you end up with a single commit -- the second commit replaces the result of the first.\\

\subsubsection{Unstaging a Staged File}
\label{sec:org649e381}
to unstage:\\
\begin{verbatim}
git reset HEAD <file>
git reset -h
git reset --help  # verbose help information
\end{verbatim}


\subsubsection{Unmodifying a Modified File}
\label{sec:org5b5711d}
to discard changes in working directory:\\
\begin{verbatim}
git checkout -- <file>
git checkout -h
\end{verbatim}

It's important to understand that git checkout -- <file> is a dangerous command. Any changes you made to that file are gone.\\


\subsection{Working with Remotes}
\label{sec:orgc76c204}
\subsubsection{Showing Your Remotes}
\label{sec:orga2b2134}
\begin{verbatim}
git remote
git remote -v
git remote -h
\end{verbatim}


\subsubsection{Fetching and Pulling from Your Remotes}
\label{sec:org99f9a9e}
\begin{verbatim}
git fetch [remote-name]
git fetch -h
\end{verbatim}

If you clone a repository, the command automatically adds that remote repository under the name "origin".\\

The git fetch command only downloads the data to your local repository - it doesn't automatically merge it with any of your work or modify what you're currently working on.\\

\begin{verbatim}
git pull [remote-name]
git pull -h
\end{verbatim}
If your current branch is set up to track a remote branch, you can use the git pull command to automatically fetch and then merge that remote branch into your current branch.\\

\subsubsection{Pushing to Your Remotes}
\label{sec:orgc917af4}
\begin{verbatim}
git push [remote-name] [branch name]
git push -h
\end{verbatim}
If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected. You'll have to fetch their work first and incorporate it into yours before you'll be allowed to push.\\

\subsubsection{Inspecting a Rmote}
\label{sec:org7e8ee5a}
\begin{verbatim}
git remote show [remote-name]
\end{verbatim}

\subsubsection{Removing and Renaming Remotes}
\label{sec:org645007e}
\begin{verbatim}
git remote rename [remote_name_from] [remote_name_to]
git remote rm [remote_name]
\end{verbatim}



\subsection{Tagging}
\label{sec:org4d03e6e}
Git has the ability to tag specific points in history as being important.\\

\subsubsection{Listing Your Tags}
\label{sec:org34aaa02}
\begin{verbatim}
git tag
git tag -l <pattern>
git tag --list <pattern>

git tag -l "v1.8.5*"

git tag -h
\end{verbatim}

\subsubsection{Creating Tags}
\label{sec:org3ebba5c}
Git uses two main types of tags: lightweight and annotated.\\
A lightweight tag is very much like a branch that doesn't change - it's just a pointer to a specific commit.\\
Annotated tags are stored as full objects in the Git database. They are checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).\\

\begin{enumerate}
\item Annatated Tags
\label{sec:orgd0a14f9}
\begin{verbatim}
git tag -a v1.4 -m "my version 1.4"
# a: annotated
# m: message
# s: sign

git show v1.0
\end{verbatim}


\item Lightweight Tags
\label{sec:orge25a775}
to create a lightweight tag, don't supply tha -a, -s, or -m option:\\
\begin{verbatim}
git tag v1.0-lw
\end{verbatim}
\end{enumerate}


\subsubsection{Tagging Later}
\label{sec:orgdba76ad}
to see the checksums:\\
\begin{verbatim}
git log --pretty=oneline
\end{verbatim}


to tag that commit, you specify the commit checksum (or part of it):\\
\begin{verbatim}
git tag -a v1.1 <checksum>
\end{verbatim}



\subsubsection{Sharing Tags}
\label{sec:org45d9313}
By default, the git push command doesn't transfer tags to remote servers.\\

\begin{verbatim}
git push origin [tagname]
git push origin --tags  # transfer all of your tags to the remote server that are not already there.
\end{verbatim}



\subsection{Git Aliases}
\label{sec:orgd6df188}
Git doesn't automatically infer your command if you type it in partially. If you don't want to type the entire text of the Git commands, you can easily set up an alias for each command using git config.\\
\begin{verbatim}
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.last 'log -1 HEAD'
\end{verbatim}

This technique can also be very useful in creating commands that you think should exist.\\
\begin{verbatim}
git config --global alias.unstage 'reset HEAD --'
\end{verbatim}

This makes the following two commands equivalent:\\
\begin{verbatim}
git unstage fileA
git reset HEAD -- fileA
\end{verbatim}


\section{Git Branching}
\label{sec:org4475f22}
Branching means you diverge from the main line of development and continue to do work without messing with that main line.\\

\subsection{Branching in a Nutshell}
\label{sec:orgcfb6bea}
A branch in Git is simply a lightweight movable pointer to one of the commits.\\

The "master" branch in Git is not special branch. It is exactly like any other branch. The only reason nearly every repository has one is that the git init command creates it by dafault and most people don't bother to change it.\\

\subsubsection{Creating a New Branch}
\label{sec:org1ef233d}
git branch <branch\_name>\\

What happens if you create a new branch?\\
Doing so creates a new pointer for you to move around.\\

How dose Git know what branch you're currently on?\\
It keeps a special pointer called HEAD.\\

The git branch command only created a new branch - it didn't switch to that branch.\\

to show where the branching pointers are pointing:\\
git log --oneline --decorate\\

\subsubsection{Switching Branches}
\label{sec:org3c4cc21}
git checkout <branch\_name>\\

If your working directory or staging area has uncommitted changes that conflict with the branch you're checking out, Git won't let you switch branches.\\


git log --oneline --decorate --graph --all\\


\subsection{Basic Branching and Merging}
\label{sec:org5a470e6}
\subsubsection{Basic Branching}
\label{sec:org24db867}

to create a branch and switch to it at the same time:\\
git checkout -b <branch\_name>\\

to merge hotfix into master:\\
git checkout master\\
git merge hotfix\\

to delete a branch:\\
git branch -d <branch\_name>\\



master		hotfix\\
\begin{center}
\begin{tabular}{l}
\\
\\
\\
\end{tabular}
\end{center}
C2	  <----------- 	  C4\\

Because the commit C4 pointed to by the branch hotfix you merged in was directly ahead of the commit C2 you're on, Git simply moves the pointer forward.\\
To phrase that another way, when you try merge one commit with a commit that can be reached by following the first commit's history, Git simplifies things by moving the pointer forward because there is no divergent work together -- this is called a "fast-forward".\\

\subsubsection{Basic Merging}
\label{sec:orgb330fea}

git checkout master\\
git merge iss53\\


common            master\\
ancestor     	      			      		 master(result)\\
                                  snapshot to merge into\\
 C2  <-------    	C4   ------------------------------ C6\\
                            $\backslash$ 	   	       	 	    /\\
                       $\backslash$	   	     		   /\\
                        $\backslash$	   	     		  /\\
                         $\backslash$       	   		 /\\
                                 $\backslash$  	  	       	/\\
                                 $\backslash$     	      	       /\\
                                  $\backslash$    	              /\\
                                     C3 -----------  C5\\
                                                       snapshot to merge into\\

iss53\\

Because the commit on the branch you're on isn't a direct ancestor of the branch you're mergingin, Git has to do some work.\\
In this case, Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two.\\
Instead of moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it.\\

\subsubsection{Basic Merge Conflicts}
\label{sec:org479ef4b}

If you changed the same part of the same file differently in the two branches you are merging, Git won't be able to merge them cleanly.\\

to see the merge conflict:\\
git status\\

edit the unmerged files with emacs or vi and git add them.\\

to use a praphical tool to resolve these issues:\\
git mergetool\\

git config --global merge.tool emerge\\

\begin{center}
\begin{tabular}{|l|l|}
\hline
C-] & emerge-abort \\
\hline
. & emerge-find-difference \\
\hline
$<$ & emerge-scroll-left \\
\hline
$>$ & emerge-scroll-right \\
\hline
\^ & emerge-scroll-down \\
\hline
a & emerge-select-A \\
\hline
b & emerge-select-B \\
\hline
e & emerge-edit-mode \\
\hline
f & emerge-fast-mode \\
\hline
j & emerge-jump-to-difference \\
\hline
l & emerge-recenter \\
\hline
m & emerge-mark-difference \\
\hline
n & emerge-next-difference \\
\hline
p & emerge-previous-difference \\
\hline
q & emerge-quit \\
\hline
v & emerge-scroll-up \\
\hline
$|$ & emerge-scroll-reset \\
\hline
c a & emerge-copy-as-kill-A \\
\hline
c b & emerge-copy-as-kill-B \\
\hline
d a & emerge-default-A \\
\hline
d b & emerge-default-B \\
\hline
i a & emerge-insert-A \\
\hline
i b & emerge-insert-B \\
\hline
s a & emerge-auto-advance \\
\hline
s s & emerge-skip-prefers \\
\hline
x 1 & emerge-one-line-window \\
\hline
x C & emerge-combine-versions-register \\
\hline
x c & emerge-combine-versions \\
\hline
x f & emerge-file-names \\
\hline
x j & emerge-join-differences \\
\hline
x l & emerge-line-numbers \\
\hline
x m & emerge-set-merge-mode \\
\hline
x s & emerge-split-difference \\
\hline
x t & emerge-trim-difference \\
\hline
x x & emerge-set-combine-versions-template \\
\hline
\end{tabular}
\end{center}


\subsection{Branch Management}
\label{sec:orge9a8306}
The git branch command does more than just create and delete branches.\\

to get a simple listing of your current branches:\\
git branch\\


to see the last commit on each branch:\\
git branch -v\\

The usefull --merged and --no-merged can filter this lists to branches that you have or have not yet merged into the branch you're currently on:\\
git branch --merged\\

Branches on the list without the * in front of them are generally fine to delete.\\

git branch --unmerged (deprecated)\\
git branch --no-merged (new)\\


\subsection{Branching Workflows}
\label{sec:org0d16962}

\subsubsection{Long-Running Branches}
\label{sec:org48514bf}
Many Git developers have a workflow that having only code that is entirely stable in their master branch. They have another parallel branch named develop that they work from or use to test stability.\\

It's generally easier to think about them as work silos, where sets of commits graduate to a more stable silo when they're fully tested.\\



------------------------------------------------------------------------     master\\
	 $\backslash$\\
	  $\backslash$\\
	   $\backslash$\\
	    $\backslash$\\
	     ------------------------------------------------------------    develop\\
	      $\backslash$\\
	       $\backslash$\\
       	       	$\backslash$\\
		 $\backslash$\\
		  -----------------------------------------------------------  topic\\


The idea is that your branches are at various levels of stability; when they reach a more stable level, they're merged into the branch above them.\\


\subsubsection{Topic Branches}
\label{sec:org3c0dddd}
A topic branch is a short-lived branch that you create and use for a single particular feature or related work.\\

It's important to remember when you're doing all this that these branches are completely local.\\

\subsection{Remote Branches}
\label{sec:org7ce8ed3}
Remote references are references (pointers) in your remote repositories, including branches, tags, and so on.\\

To get a full list of remote references:\\
git ls-remote [remote]\\
git remote show [remote]\\

a more common way is to take advantage of remote-tracking branches:\\
Remote-tracking branches are references to the state of remote branches.\\
They are local references that you can not move; they are moved automatically for you whenever you do any network communication.\\
Remote-tracking branches act as bookmark to remind you where the branches in your remote repositories were the last time you connected to them.\\

form:\\
(remote)/(branch)\\

note:\\
Just like the branch name "master" does not have any special meaning in Git, neither does "origin".\\
"origin" is the default name for a remote when you run git clone.\\


\subsubsection{Pushing}
\label{sec:org256bd4f}
git push <remote> <remote\_branch>\\
git push <remote> <local\_branch>:<remote\_branch>\\

git push origin serverfix\\
This is a shortcut. Git automatically expands the serverfix branchname out to\\
serverfix:serverfix\\

git push origin serverfix:serverfix\\
Take my serverfix and make it the remote's serverfix\\

When you do a fetch that brings down new remote-tracking branches, you don't automatically have local, editable copies of them.\\

git fetch origin (new branch serverfix is pulled suppose)\\
To merge this work into your current working branch, you can run\\
git merge origin/serverfix\\

If you want your own serverfix branch that you can work on, you can base it off your remote-tracking branch:\\
git checkout -b serverfix origin/serverfix\\
b: branch\\

\subsubsection{Tracking Branches}
\label{sec:orgcc90530}
Checking out a local branch from a remote-tracking branch automatically creates what is called a "tracking branch" (and the branch it tracks is called an "upstream branch"). Tracking branches are local branches tha have a direct relationship to a remote branch.\\

If you are on a tracking branch and type git pull, Git automatically knows which server to fetch from and branch to merge into.\\

You can set up other tracking branches if you wish:\\
git checkout -b [branch] [remotename]/[remote\_branch]\\
shorthand:\\
git checkout --track origin/serverfix\\

To have different name with origin:\\
git checkout -b <different\_branchname> <origin>/<branch>\\


If you already have a local branch and want to set it to a remote branch:\\
git branch -u <remote>/<branch>\\
or\\
git branch --set-upstream-to <remote>/<branch>\\

To see what tracking branches you have set up:\\
git branch -vv\\
It is important to note that these numbers are only since the last time you fetch from each server. This command does not reach out to the server.\\

\subsubsection{Pulling}
\label{sec:org10f0792}
git pull\\

This will look up what server and branch your current is tracking, fetching from that server and then try to merge in that remote branch.\\

\subsubsection{Deleting Remote Branches}
\label{sec:org12add91}
git push <remote> --delete <remote\_branch>\\

Basically all this does is remove the pointer from the server. The Git server will generally keep the data there for a while until a garbage collection runs.\\






\subsection{Rebasing}
\label{sec:org88c2789}
In Git, there are two main ways to integrate chages from one branch into another:\\
the merge and the rebase\\

\subsubsection{The Basic Rebase}
\label{sec:org6502bf2}

                             C4\\
                          /\\
                         /   experiment\\
                        /\\
                              /\\
                      /\\
                     /\\
                    /\\
                   /\\
                                /\\
C1 <------------ C2 <----------------C3\\

master\\


you can take the patch of the change that was introduced in C4 and reapply it on top of C3. In Git this is called rebasing.\\
With the rebase command, you can take all the changes that were committed on one branch and replay them on another one.\\

git checkout experiment\\
git rebase master\\

It works by going to the common ancestor of the two branches, getting the diff introduced by each commit of the branch you're on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and finally applying each change in turn.\\



C1 <------------- C2 <----------------- C3 <---------------- C4'\\
                                                  master		      experiment\\

At this point, you can go back to the master branch and do a fast-forward merge\\
git checkout master\\
git merge experiment\\


There is no difference in the end product of the integration (comparing to merge), but rebasing makes for a cleaner history.\\

Rebasing replays changes from one line of work onto another inthe order they are introduced, whereas merging takes the endpoints and merges them together.\\

\subsubsection{More Interesting Rebases}
\label{sec:orgc7d5d7a}
You can have your rebase replay on something other than the rebase target branch.\\

                                     master\\
C1 <------- C2 <------- C5 <--------- C6\\
              $\backslash$\\
               $\backslash$\\
                $\backslash$\\
                 $\backslash$\\
                  $\backslash$\\
                   $\backslash$\\
                    $\backslash$			       	   server\\
                              C3 <---------  C4 <------- C10\\
                        $\backslash$\\
                         $\backslash$\\
                          $\backslash$\\
                           $\backslash$\\
                            $\backslash$\\
                             $\backslash$\\
                                     $\backslash$\\
                               $\backslash$\\
                                $\backslash$  C8 <---------- C9\\
                                                    client\\

You can take the changes on client that aren't on server (C8 and C9) and replay them on your master branch by:\\
git rebase --onto master server client.\\

This basically says, "checkout out the client branch, figure out the patches from the common ancestor of the client and server branches, and then replay them onto master.\\


                                master			client\\
C1 <------ C2 <------ C5 <------ C6 <----- C8' <----- C9'\\
            $\backslash$\\
                    $\backslash$\\
              $\backslash$\\
                      $\backslash$\\
                $\backslash$\\
                               $\backslash$   C3 <------- C4 <------ C10\\
                                           server\\

The Perils of Rebasing\\
Do not rebase commits that exist outside your repository.\\


\subsubsection{Rebase vs. Merge}
\label{sec:orgbeae773}
One point of view is that your repository's commit history is a record of what actually happened.\\
The opposing point of view is that the commit history is the story of how your project was made.\\

It's up to you to decide which one is best for your particular situation.\\

In general the way to get the best of both world is to rebase local changes you've made but haven't shared yet before you push them in order to clean up your story, but never rebase anything you've pushed somewhere.\\



\section{Git on the Server}
\label{sec:org66245df}
Running a Git server is straightforward.\\
First, you choose which protocols you want your server to communicate with.\\
Second, setups using those protocols and get your server running with them.\\

A remote repository is generally a bare repository - a Git repository that has no working directory.\\
In the simplest terms, a bare repository is the contents of your project's .git directory and nothing else.\\

\subsection{The Protocols}
\label{sec:org7ca4f3a}
\subsubsection{Local Protocol}
\label{sec:org27bac3e}
the most basic is the Local Protocol, in which the remote repository is in another directory on disk.\\
\begin{enumerate}
\item When to Use
\label{sec:org93c9e85}
If you have a shared mounted filesystem, then you can clone, push to, and pull from a local file-based repository.\\
\item form
\label{sec:org374e250}
git clone /opt/git/project.git\\
or\\
git clone \url{file:///opt/git/project.git}\\

If you just specify the path, Git tries to use hardlinks or directly copy the files it needs.\\
If youu specify \url{file://}, Git fires up the process that it normally uses to transfer data over a network which is generally a lot less efficient method of transferring the data. The main reason that specify the \url{file://} prefix is if you want a clean copy of the repsitory with extraneous references or objects left out.\\

\item The Pros
\label{sec:orgb222f43}
simple and use existing file permissions and network access.\\

\item The Cons
\label{sec:orge99a739}
shared access is generally more difficult to set up and reach from multiple locations than basic network access.\\
this protocol does not protect the repository against accidental damage.\\
\end{enumerate}


\subsubsection{The Http Protocols}
\label{sec:org356370a}
\begin{enumerate}
\item smart http
\label{sec:org06171a9}
The "smart" http protocol opertates very similarly to the ssh or git protocols but runs over standard http/s prots and can use various http authentication mechanisms.\\
read and write\\

\item dumb http
\label{sec:org0709fb6}
readonly\\

\item The Pros
\label{sec:orgce317dd}
The simplicity of having a single URL for all types of access and having the server prompt only when authentication is needed makes things very easy for the end user.\\

a very fast and efficient protocol similar to the ssh one.\\

\item The Cons
\label{sec:orgcbb7d2e}
Git over HTTP/S can a little more tricky to set up compared to SSH on some servers.\\
\end{enumerate}

\subsubsection{The SSH Protocol}
\label{sec:orgdffaf30}
A common transport protocol for Git when self-hosting is over SSH.\\
\begin{enumerate}
\item form
\label{sec:orgba742c7}
git clone ssh://user@server/project.git\\
or\\
git clone user@server:project.git\\

\item The Pros
\label{sec:org64d09a7}
First, relatively easy to set up.\\
Second, access over SSH is secure.\\
Third, like the HTTP/S, Git and Local protocols, SSH is efficient, making the data as compact as possible before transferring it.\\

\item The Cons
\label{sec:orgf8f6c2b}
you can't server anonymous access of your repository over it.\\
\end{enumerate}

\subsubsection{The Git Protocol}
\label{sec:org3772057}
This is a special daemon that comes packaged with Git; it listens on a dedicated port(9418).\\
In order for a repository to be served over the Git protocol, you must create the git-daemon-export-ok file - the daemon won't serve a repository without that file in it - but other than that there is no security\\

\begin{enumerate}
\item The Pros
\label{sec:org6e6572e}
fatest network transfer protocol available.\\

\item The cons
\label{sec:org7ef0ea4}
the lack of authentication.\\
\end{enumerate}

\subsection{Getting Git on a Server}
\label{sec:org612c15b}
\subsubsection{First, get a bare repository}
\label{sec:org5387e61}
In order to initially set up any Git server, you have to export an existing repository into a new bare repository - a repository that doesn't contain a working directory.\\
git clone --bare my\_project my\_project.git\\
or\\
git init --bare\\

\subsubsection{Second, copy it to a server}
\label{sec:orga28a0bc}
put the bare repository on a server and set up your protocols.\\

suppose, the server called git.example.com, store all your Git repository under the /srv/git directory:\\
scp -r my\_project.git user@git.example.com:/srv/git\\

At this point, other users who have ssh access to the same server which has read-access to the /srv/git directory can clone your repository:\\
git clone user@git.example.com:/srv/git/my\_project.git\\

If a user SSHs into a server and has write access to the /srv/git/my\_project.git directory, they will alse automactically have push access.\\

Git will automatically add group write permissions to a repository properly:\\
cd /srv/git/my\_project.git\\
git init --bare --shared\\

\subsubsection{note}
\label{sec:org5a86826}
to collaborate with a couple of people on a private project, all you need it a SSH sever and a bare repository.\\


\subsubsection{Small Setups}
\label{sec:org107ded2}
One of the most complicated aspects of setting up a Git server is user management.\\

There are a few ways you can give access to everyone on your team:\\
First, set up accounts for everybody.\\
Second, create a single git user on the machine, ask every user who is to have write access to send you an SSH public key, and add that key to the \textasciitilde{}/.ssh/authorized\_keys file of your new git user.\\
Third, have your SSH server authenticate from an LDAP server or some other centralized authentication source.\\

As long as each user can get shell access on the machine, any SSH authentication mechanism you can think of should work.\\

\subsection{Setting Up the Server}
\label{sec:org4400fa1}
sudo adduser git\\
su git\\
cd\\
mkdir .ssh \&\& chmod 700 .ssh\\
touch .ssh/authorized\_keys \&\& chmod 600 .ssh/authorized\_keys\\
cat \emph{tmp/id\_rsa.michael.pub >> \textasciitilde{}}.ssh/authorized\_keys\\
cd /opt/git\\
mkdir project.git\\
cd project.git\\
git init --bare\\

You can easily restrict the git user to only doing Git activities with a limited shell tool called git-shell that comes with Git.\\

cat /etc/shell \# see if 'git-shell' is already in there\\
which git-shell \# make sure git-shell is installed on your system\\
sudo vim /etc/shells \# add the path to git-shell\\

sudo chsh git \# enter the path ot git-shell\\

\subsection{Git Daemon}
\label{sec:org7e5e275}
yum install git-daemon\\

This is common choice for fast, unauthenticated access to your Git data.\\

git daemon --reuseaddr --base-path=/opt/git/ \emph{opt/git}\\

--reuseaddr allows the server to restart without waiting for old connections to timeout, --base-path option allows people to clone projects without specifying the entire path, and the path at the end tells the Git daemon where to look for repositories to export.\\

If you are running a firewall, you will also need to punch a hole in it at port 9418.\\

cd /path/to/project.git\\
touch git-daemon-export-ok\\

\subsection{Smart HTTP (not done)}
\label{sec:org233152b}

\subsubsection{Ubuntu}
\label{sec:org74ad546}
sudo apt-get install apache2 apache2-utils (on Ubuntu)\\

\subsubsection{CentOS}
\label{sec:org83c498f}
yum install httpd\\
yum install gitweb\\

chgrp -R apache /home/git/project.git\\

\subsection{GitLab}
\label{sec:org771cf30}
GitLab is a database-backed web application.\\

\subsubsection{Install}
\label{sec:org9d02813}
\begin{enumerate}
\item Install and configure the necessary dependencies
\label{sec:orgd3b197b}

yum install -y curl policycoreutils-python openssh-server\\
systemctl enable sshd\\
systemctl start sshd\\
firewall-cmd --permanent --add-service=http\\
systemctl reload firewalld\\

Next, install Postfix to send notification emails.\\
yum install postfix\\
systemctl enable postfix\\
systemctl start postfix\\

\item Add the GitLab package repository and intall the package
\label{sec:org48e34f8}
curl \url{https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh} | sudo bash\\

Next, install the GitLab package.\\

sudo EXTERNAL\_URL="\url{http://chyson.net}" yum install -y gitlab-ee\\

\item Browse to the hostname and login
\label{sec:orgd33a62b}
On your first visit, you'll be redirected to a password reset screen. Provide the password for the initial administrator account and you will be redirected back to the login screen. Use the default account's username root to login.\\
\end{enumerate}
\end{document}