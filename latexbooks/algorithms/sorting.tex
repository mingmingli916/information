
\chapter{Sorting}
\label{cha:sorting}

In computer science, we have formal definitions of sorting with respect to ordering relations.

An ordering relation has two key properties:
\begin{enumerate}
\item Given two elements \(a\) and \(b\), exactly one of the following must be true: \(a < b, a = b\) or \(a > b\) (law of trichotomy)
\item If \(a < b\) and \(b < c\) then \(a < c\) (law of transitivity)
\end{enumerate}



A \keyword{sort} is formally defined as a rearrangement of a sequence of elements that puts all elements into a non-decreasing order based on the ordering relation.


An important concept in sorting is \keyword{inversions}.
An inversion in a sequence is defined as a pair of elements that are out of order with respect to the ordering relation.
For example, \(1, 2, 4, 6, 5, 3\).
The inversions are \((4,3), (6,5), (6,3), (5,3)\).
There are 4 inversions in the previous list.


The next important concept in sorting is the \keyword{stability} of sorting algorithms.
The key feature of a stable sorting algorithm is that it will preserve the order of equal elements.
For example, [“hello”, “world”, “we”, “are”, “learning, “sorting”].
We define an ordering relation based on the length of the string.
There are two valid sorts for this sequence:
\begin{enumerate}
\item “we”, “are”, “hello”, “world”, “sorting”, “learning”
\item “we”, “are”, “world”, “hello”, “sorting”, “learning”
\end{enumerate}

We consider (1) to be a stable sort since the equal elements “hello” and “world” are kept in the same relative order as the original sequence.



\section{Comparison Based Sort}
\label{sec:comp-based-sort}

Comparison based sorts are sorting algorithms that require a direct method of comparison defined by the ordering relation.
In a sense, they are the most natural sorting algorithms since, intuitively, when we think about sorting elements, we instinctively think about comparing elements to each other.

\subsection{Selection Sort}
\label{sec:selection-sort}

Suppose we had a collection of elements where every element is an integer.
Selection sort will build up the sorted list by repeatedly \keyword{selecting} the minimum element in that list and moving it to the front of the list through a swap.
It will proceed to swap elements appropriately until the entire list is sorted.

\begin{figure}[H]
  \centering
  \myfigure[0.5]{selection-sort}
  \caption{Selection sort}
\end{figure}

It's time complexity is \(O(n^{2})\) and space complexity is \(O(1)\).
It is not a stable sorting algorithm.

\begin{lstlisting}
class Solution:
    def selection_sort(self, lst: List[int]) -> None:
        """
        Mutates lst so that it is sorted via selecting the minimum element and swapping it with the corresponding index.
        """
        for i in range(len(lst)):
            min_index = i
            for j in range(i + 1, len(lst)):
                # Update minimum index
                if lst[j] < lst[min_index]:
                    min_index = j

            # Swap current index with minimum element in rest of list
            lst[min_index], lst[i] = lst[i], lst[min_index]
\end{lstlisting}



\subsection{Bubble Sort}
\label{sec:bubble-sort}

Suppose we have a collection of integers that we want to sort in ascending order.
Bubble sort proceeds to consider two adjacent elements at a time.
If these two adjacent elements are out of order (in this case, the left element is strictly greater than the right element), bubble sort will swap them.
It then proceeds to the next pair of adjacent elements.
In the first pass of bubble sort, it will process every set of adjacent elements in the collection once, making swaps as necessary.
The core idea of bubble sort is it will repeat this process until no more swaps are made in a single pass, which means the list is sorted.



Bubble sort runtime of \(O(n^{2})\).
The space complexity of bubble sort is \(O(1)\).
Bubble sort is also a stable sorting algorithm since equal elements will never have swapped places, so their relative ordering will be preserved.


Overall, bubble sort is fairly simple to implement, and it’s stable, but outside of that, this algorithm does not have many desirable features.
It’s fairly slow for most inputs and, as a result, it is rarely used in practice.



\begin{lstlisting}[language=python]
class Solution:
    def bubble_sort(self, lst: List[int]) -> None:
        """
        Mutates lst so that it is sorted via swapping adjacent elements until
        the entire lst is sorted.
        """
        has_swapped = True
        # if no swap occurred, lst is sorted
        while has_swapped:
            has_swapped = False
            for i in range(len(lst) - 1):
                if lst[i] > lst[i + 1]:
                    # Swap adjacent elements
                    lst[i], lst[i + 1] = lst[i + 1], lst[i]
                    has_swapped = True          
\end{lstlisting}

\subsection{Selection Sort}
\label{sec:selection-sort-1}

Given a collection of integers, you can sort the list by proceeding from the start of the list, and every time you encounter an element that is out of order, you can continuously swap places with previous elements until it is inserted in its correct relative location based on what you’ve processed thus far.

The time complexity is \(O(n^{2})\) and space complexity is \(O(1)\).
It is a stable sort.


There are cases where insertion sort may actually be the best sort.
\begin{itemize}
\item On almost sorted arrays where the number of inversions is relatively small compared to the size of the array, insertion sort will be quite fast since the number of swaps required will be low on almost sorted arrays.
\item Insertion sort can also be the best choice on small arrays.
\end{itemize}


\begin{lstlisting}
class Solution:
    def insertion_sort(self, lst: List[int]) -> None:
        """
        Mutates elements in lst by inserting out of place elements into appropriate
        index repeatedly until lst is sorted
        """
        for i in range(1, len(lst)):
            current_index = i

            while current_index > 0 and lst[current_index - 1] > lst[current_index]:
                # Swap elements that are out of order
                lst[current_index], lst[current_index - 1] = lst[current_index - 1], lst[current_index]
                current_index -= 1
\end{lstlisting}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "algorithms"
%%% End:
